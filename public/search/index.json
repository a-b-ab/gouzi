[{"content":" ## 连接 MySQL 数据库 `mysql -u root -p` Mysql基础 EXISTS 语法 在 MySQL 中，EXISTS 操作符用来判断一个子查询是否返回数据行。如果一个子查询返回了至少一个数据行，则 EXISTS 的计算结果为 TRUE，否则计算结果为 FALSE。\nLIKE % 匹配零或多个任意字符。 _ 匹配单个任意字符。 如果需要匹配通配符，则需要使用 \\ 转义字符，如 % 和 _。 使用通配符匹配文本时，不区分字母大小写。\n按自定义顺序排序 使用 CASE 实现自定义排序 使用 FIELD() 函数实现自定义排序 在 MySQL 中的升序排序中， NULL 值出现在非 NULL 值之前 当我们使用 ORDER BY 子句降序 DESC 排序时， NULL 值排在非 NULL 值的后面\nMySQL LIMIT 在 MySQL 中，我们使用 LIMIT 子句来限定 SELECT 语句返回的行的数量\n当 DISTINCT 遇到 NULL 值时，只保留一个 NULL 值。因为 DISTINCT 认为所有的 NULL 值都是相同的，这与字段的类型无关。\nMySQL 连接类型 MySQL 支持以下类型的连接：\n内部联接 (INNER JOIN) 左连接 (LEFT JOIN) 右连接 (RIGHT JOIN) 交叉连接 (CROSS JOIN) MySQL 目前不支持全连接 FULL OUTER JOIN 。\n交叉连接返回两个集合的笛卡尔积。也就是两个表中的所有的行的所有可能的组合。这相当于内连接没有连接条件或者连接条件永远为真\n内连接基于连接条件组合两个表中的数据。内连接相当于加了过滤条件的交叉连接。\n内连接将第一个表的每一行与第二个表的每一行进行比较，如果满足给定的连接条件，则将两个表的行组合在一起作为结果集中的一行\n由于两个表都使用相同的字段进行等值匹配，因此您可以使用 USING 以下查询\n左连接是左外连接的简称，左连接需要连接条件。\n两个表左连接时，第一个表称为左表，第二表称为右表。例如 A LEFT JOIN B，A 是左表，B 是右表。\n左连接以左表的数据行为基础，根据连接匹配右表的每一行，如果匹配成功则将左表和右表的行组合成新的数据行返回；如果匹配不成功则将左表的行和 NULL 值组合成新的数据行返回\n右连接是右外连接的简称，右连接需要连接条件。\n右连接与左连接处理逻辑相反，右连接以右表的数据行为基础，根据条件匹配左表中的数据。如果匹配不到左表中的数据，则左表中的列为 NULL 值\n右连接其实是左右表交换位置的左连接，即 A RIGHT JOIN B 就是 B LEFT JOIN A，因此右连接很少使用。\n右连接可以转换为下面的左连接\nGROUP BY HAVING 子句用来过滤 GROUP BY 分组的数据，需要使用逻辑表达式作为条件，其中逻辑表达式中的字段或表达式只能使用分组使用的字段和聚合函数\nGROUP BY 子句用于将结果集根据指定的字段或者表达式进行分组。 GROUP BY 子句的分组字段或表达式至少一个，可以多个。 HAVING 子句是可选的，用来过滤分组数据。 GROUP BY 子句经常用于数据统计汇总，通常使用聚合函数。\nUNION 在 MySQL 中，UNION 操作符是一个集合操作符，它用于合并 2 个结果集中的所有的行。\nSQL 标准中定义了 3 个集合操作符： UNION, INTERSECT 和 MINUS。目前 MySQL 只支持 UNION\nUNION 运算删除了结果集中的重复项，返回一个唯一记录值的结果集。\nUNION 是 UNION DISTINCT 的简写\nUNION ALL 运算 UNION ALL 保留了两个结果集中的所有行\nUNION 排序 当需要对 UNION 运算的结果进行排序时，最需要在 SQL 语句的最后添加 ORDER BY 子句。\nUNION 列数 当对两个结果集进行 UNION 运算的时候，要保证每个结果集具有相同的列数。否则就会产生错误。\n参与 UNION 运算的结果集和字段的名称没有关系，只要列数一样就可以\nUNION 列名 参与 UNION 运算的结果集只要列数一样就可以。返回结果集的列名采用第一个结果集的列名\n别名 列别名 表别名 派生表别名 使用派生表必须指定别名。因为，FROM 子句中的所有表都必须有一个名字\n可以通过 AS 关键字指定别名，但是 AS 关键字是可选的。 当别名中包含空格时，必须使用 反引号 将别名引起来。 除了为字段指定别名，表达式也可以指定别名。 当 SQL 中涉及多个表时，使用表别名很重要。 派生表必须指定别名。\n子查询 派生表 当一个子查询位于 FORM 子句中时，这个子查询被称为派生表。\n子查询是一个嵌套在语句中的查询。 子查询经常做为比较运算的一个操作数被用在 WHERE 子句中。 位于 FORM 子句中的子查询被称为派生表。派生表必须具有别名。\ninsert修饰符 在 MySQL 中， INSERT 语句支持 4 个修饰符: LOW_PRIORITY: 如果你指定了 LOW_PRIORITY 修饰符，MySQL 服务器将延迟执行 INSERT 操作直到没有客户端对表进行读操作。\nLOW_PRIORITY 修饰符影响那些只支持表级锁的存储引擎，比如： MyISAM, MEMORY, 和 MERGE。\nHIGH_PRIORITY: 如果你指定了 HIGH_PRIORITY 修饰符，它会覆盖掉服务器启动时的 \u0026ndash;low-priority-updates 选项。\nHIGH_PRIORITY 修饰符影响那些只支持表级锁的存储引擎，比如： MyISAM, MEMORY, 和 MERGE。\nIGNORE: 如果你指定了 IGNORE 修饰符，MySQL 服务器会在执行 INSERT 操作期间忽略那些可忽略的错误。这些错误最终会作为 WARNING 返回。\nDELAYED: 这个修饰符已经在 MySQL 5.6 版本中弃用，将来会被删除。在 MySQL 8.0 中，这个修饰符可用但会被忽略。\nDELETE 多表删除 只要是 SELECT 语句中允许使用的 JOIN 类型，多表删除语句都可以使用。\n多表删除语句中不能使用 LIMIT 子句和 ORDER BY 子句。\nDELETE 修饰符 LOW_PRIORITY: 如果你指定了 LOW_PRIORITY 修饰符，MySQL 服务器将延迟执行 DELETE 操作直到没有客户端对表进行读操作。这个修饰符影响那些只支持表级锁的存储引擎，比如： MyISAM, MEMORY, 和 MERGE。\nQUICK: 如果你指定了 QUICK 修饰符，MyISAM 存储引擎不会在 DELETE 操作期间合并索引。这在某种程度上会加快 DELETE 操作。\nIGNORE: 如果你指定了 IGNORE 修饰符，MySQL 服务器会在执行 DELETE 操作期间忽略那些可忽略的错误。这些错误最终会作为 WARNING 返回。\nUPDATE 修饰符 LOW_PRIORITY: 如果你指定了 LOW_PRIORITY 修饰符，MySQL 服务器将延迟执行 UPDATE 操作直到没有客户端对表进行读操作。\nLOW_PRIORITY 修饰符影响那些只支持表级锁的存储引擎，比如： MyISAM, MEMORY, 和 MERGE。\nIGNORE: 如果你指定了 IGNORE 修饰符，MySQL 服务器会在执行 UPDATE 操作期间忽略那些可忽略的错误。这些错误最终会作为 WARNING 返回\nREPLACE 语句和 INSERT 语句很像，它们的不同之处在于，当插入过程中出现了重复的主键或者重复的唯一索引的时候，INSERT 语句会产生一个错误，而 REPLACE 语句则先删除旧的行，再插入新的行。\nREPLACE 语句还可以使用 SET 关键词，这只适用于操作单行\nMySQL数据库和表 数据库是存储数据的容器。一个数据库中可以包含多个表。要想创建表，必须首先创建数据库。\n在 MySQL 中，CREATE DATABASE 和 CREATE SCHEMA 语句用来创建数据库 CREATE DATABASE 和 CREATE SCHEMA 的是一样的 DROP DATABASE 语句将永久删除数据库和数据库中的所有表，请谨慎操作。 DROP DATABASE 和 DROP SCHEMA 是一样的。\n登陆时指定数据库 mysql -u root -p -D testdb\n查看当前数据库 使用 SELECT DATABASE() 使用 STATUS 使用 SHOW TABLES CREATE TABLEtestdb.user_hobby(hobby_idINT NOT NULL AUTO_INCREMENT,user_idINT NOT NULL,hobbyVARCHAR(45) NOT NULL,created_atDATETIME NOT NULL, INDEXfk_user_idx (user_id ASC) VISIBLE, PRIMARY KEY (hobby_id), CONSTRAINT fk_user FOREIGN KEY (user_id) REFERENCES testdb.user (user_id) ON DELETE CASCADE ON UPDATE RESTRICT); 这里创建的 user_hobby 表有 4 个字段：\nhobby_id 列的数据类型是 INT，它不能为 NULL，并且它是一个自增列。 user_id 列的数据类型是 INT。它不能为 NULL。它通过外键指向了 user 表的 user_id 列。 hobby 列的数据类型是 VARCHAR，它最多为 45 个字符。 它不能为 NULL。 created_at 列的数据类型是 DATETIME。它不能为 NULL。 user_hobby 表的约束有：\nPRIMARY KEY (hobby_id) 子句表明 hobby_id 列是主键。 INDEX fk_user_idx 设定了在 user_id 列上建立索引。 CONSTRAINT fk_user 设定了一个外键。这个外键将 user_id 列引用了 user 表的 user_id 列\nCREATE TABLE … LIKE 语句可以用来克隆另一个表的定义。它以另一个表的定义为基础创建一个新的空表，包含了原表中定义的列属性和索引\nCREATE TABLE … SELECT 你可以使用 CREATE TABLE \u0026hellip; SELECT 语句从另一个表创建一个新表。该语句会一句 SELECT 子句中的列创建新表，并将 SELECT 的结果集插入到新表中\nALTER TABLE 语法 其中 alter_action 是一个修改动作，包括：\nADD 关键字可用来添加列、索引、约束等，包括：\nADD [COLUMN]: 添加列 ADD INDEX: 添加索引 ADD PRIMARY KEY: 添加主键 ADD FOREIGN KEY: 添加外键 ADD UNIQUE INDEX: 添加唯一索引 ADD CHECK: 添加检查约束 DROP 关键字可用来删除列、索引、约束等，包括：\nDROP [COLUMN] col_name: 删除列 ADD INDEX index_name: 删除索引 DROP PRIMARY KEY: 删除主键 DROP FOREIGN KEY fk_symbol: 删除外键 DROP CHECK symbol: 删除检查约束 MODIFY 关键字用来修改列的定义。与 CHANGE 关键字不同，它不能重命名列。例如: MODIFY [COLUMN] col_name column_definition。\nCHANGE 关键字用来修改列的定义。与 MODIFY 关键字不同，它可以重命名列。例如: CHANGE [COLUMN] old_col_name new_col_name column_definition。\nRENAME 关键字可以重命名列、索引和表。包括：\nRENAME COLUMN old_col_name TO new_col_name: 重命名列。 RENAME INDEX old_index_name TO new_index_name: 重命名索引。 RENAME new_tbl_name: 重命名表。\nALTER TABLE 关键字后面跟要修改的表名。 ADD 关键字可用来添加列、索引、约束等。 DROP 关键字可用来删除列、索引、约束等。 RENAME 关键字可以重命名列、索引和表。 MODIFY 关键字用来修改列的定义。 CHANGE 关键字用来修改列的定义和列名。 RENAME TABLE \u0026hellip; TO \u0026hellip; 用来重命名表。\n您可以在一个 RENAME TABLE 语句中同时重命名多个表。 RENAME TABLE 语句不可以用来重命名临时表，而 ALTER TABLE 语句可以用来重命名临时表。\nMySQL 提供了 RENAME TABLE 和 ALTER TABLE 语句重命名表。\n请记住，在重命名一个表的时候，此表中不能有未完成的事务，并且此表不能是锁定状态。\nTRUNCATE TABLE 语法 如果想要清空一个表， TRUNCATE TABLE 语句比 DELETE 语句更加有效。\nTRUNCATE TABLE 语句相当于先将此表删除掉，再创建一个新表。TRUNCATE TABLE 语句需要对操作的表具有 DROP 权限。\nTRUNCATE 被归类为 DDL 语句，而 DELETE 被归类为 DML 语句。 TRUNCATE 操作无法被回滚，而 DELETE 可以被回滚。 TRUNCATE 操作删除和重建表，它的速度比 DELETE 快得多。 TRUNCATE 操作会重置表的自增值，而 DELETE 不会。 TRUNCATE 操作不会激活删除触发器，而 DELETE 会。 TRUNCATE 操作不返回代表删除行的数量的值，它通常返回 0 rows affected。DELETE 返回删除的行数。 如果一个表被其他表的外键引用，对此表的 TRUNCATE 操作会失败。\n主键可以包含一个列或者多个列。\n添加主键 ALTER TABLE user ADD PRIMARY KEY(id);\n删除主键 ALTER TABLE user DROP PRIMARY KEY;\n如何产生主键值 通常在业务系统中，我们不使用业务字段作为主键，虽然它们也是唯一的。我们一般使用单独的字段作为主键，这主要是出于以下两方面的原因：\n保密业务数据 方便这些业务字段的修改 为了生成唯一的主键值，我们通常采用以下方法：\n将主键字段设置为 AUTO_INCREMENT。\n声明为 AUTO_INCREMENT 的字段会自动生成连续的整数值。\n使用 UUID() 函数。\nUUID() 函数产生一个长度为 36 个字符的字符串，并且永不重复。\nUUID() 适合用在集群环境下。这样即使一个表被分区在多个服务器上，也不会产生相同的主键的记录\n使用 UUID_SHORT() 函数。\nUUID_SHORT() 函数返回一个 64 位无符号整数并全局唯一\n主键 vs 唯一索引 主键和唯一索引都要求值是唯一的，但它们之间存在一些不同：\n一个表中只能定义一个主键，但是能定义多个唯一索引。 主键中的值不能为 NULL，而索引中的值可以为 NULL\n什么是外键 外键相对于主键而言，用来引用其他表。外键通过子表的一个或多个列对应到父表的主键或唯一键值，将子表的行和父表行建立起关联关系\n这里定义了一个外键：\n位于 CONSTRAINT 关键字之后的 fk_city_country 是外键的名字。它是可选的。\n位于 FOREIGN KEY 关键字之后的是作为外键的列名。\n位于 REFERENCES 关键字之后的是被引用的表和列。\nON DELETE 和 ON UPDATE 指定了删除或更新被引用的表中的数据时要采取的约束策略。你可以使用以下 3 个策略中的一个：\nCASCADE：如果被引用的表中的一行被删除或更新，该表中匹配行的值会自动删除或更新。 SET NULL：如果被引用的表中的一行被删除或更新，该表中匹配行的值设置为 NULL。 RESTRICT: 如果被引用的表中的一行在该表中有匹配的行，试图删除或更新被引用的表中行时会引发 MySQL 错误。这是默认的策略。 通常，外键所属的表被称作子表，被外键引用的表被称作父表。\nDROP FOREIGN KEY 后面指定外键名，也就是约束名。 DROP CONSTRAINT 后面指定约束名。它可以通过名字删除任何约束，并不仅仅是外键\nCASCADE 策略 如果外键的 ON DELETE 和 ON UPDATE 使用了 CASCADE 策略：\n当父表的行被删除的时候，子表中匹配的行也会被删除。 当父表的行的键值更新的时候，子表中匹配的行的字段也会被更新\nRESTRICT 策略 MySQL 禁止删除父表中与子表匹配的行。 MySQL 禁止删除父表中与子表匹配的行的键的值\nSET NULL 策略 当父表的行被删除的时候，子表中匹配的行的列的值被设置为 NULL。 当父表的行的键值被更新的时候，子表中匹配的行的列的值被设置为 NULL\n自引用外键 有时，子表和父表可能是同一个表。这种表中的外键被称为自引用外键。\n通常，自引用外键定义在表示树形数据结构的表中。比如一个代表分类的表\n启用或禁用外键约束 要禁用外键约束 SET foreign_key_checks = 0;\n要启用外键约束 SET foreign_key_checks = 1;\n禁用外键约束在批量导入数据的时候很有用\n确定列是否存在 在向表中添加一个列之前，您可以需要首先确定此表中是否存在同名的列。\n要查看一个表中的所有列的信息，您可以使用 DESC 或者 SHOW COLUMNS 两个语句中的一个。这两个语句都可以显示一个表中的所有的列，但是 SHOW COLUMNS 语句更灵活和方便，因为它可以根据您的要求过滤结果集。\nMySQL 为非空的 VARCHAR 列使用空字符串作为默认值\n另外，删除列还可能带来一些隐藏的问题：\n如果要删除的列被外键引用，您需要同步删除外键后才能进行。这可能会破坏数据的完整性。 删除列后，您需要同步修改应用程序中依赖此列的代码。这包括独立的应用程序和触发器、视图、存储过程和函数中的引用。 对于一个大表来说，删除列是一个很耗时的过程。 重要：删除之前请一定要备份表和表中的数据\nMySQL AUTO_INCREMENT 自增列 在 MySQL 中，如果需要一个列的值为一个有序的整数序列，请使用自增列。\n自增列是 MySQL 中的一个特殊的列，该列的值可由 MySQL 服务器自动生成，并且是一个按升序增长的正整数序列。自增列能够被用来为表的新行产生唯一的标识\n当修改了表的 AUTO_INCREMENT 值之后， INFORMATION_SCHEMA.TABLES 表中的 AUTO_INCREMENT 列并不会立刻更新。你可以使用 SHOW CREATE TABLE 语句查看。\n一个表中只能有一个自增列。 自增列的数据类型只能使用整数和浮点数。 自增列的初始值是 1。你可以在创建表的时候设置自增列的初始值，也可以修改自增列的值。 删除一些行后，删除的自增列的值不能重用。 你可以使用 SHOW CREATE TABLE 语句查看自增列的值。\n什么是生成列 在 MySQL 中，生成列（GENERATED COLUMN）是一个特殊的列，它的值会根据列定义中的表达式自动计算得出。并且，你不能直接写入或更新生成列的值。\n生成列有 2 种类型：\n虚拟生成列：列值不会被存储下来。当读取该列时，MySQL 自动计算该列的值。 存储生成列：当插入或修改数据时，MySQL 自动计算该列的值并存储在磁盘上\nMySQL 生成列可以简化我们的工作，让你不用写这么复杂的 SELECT 语句。现在我们要通过以下语句添加一个生成列 ALTER TABLE order_item ADD COLUMN total_amount DECIMAL GENERATED ALWAYS AS (price * quantity) STORED;\n生成列有两种类型： VIRTUAL 和 STORED。他们之间有些不同：\n虚拟生成列不需要存储空间；存储生成列需要存储空间。 虚拟生成列的值在每次读操作的时候都会被重新计算；存储生成列的值在插入行或者修改行的时候被计算。 如果数据经常发生变动，请考虑使用虚拟生成列；如果数据在创建后不经常变动，请考虑使用存储生成列。\n像上面的例子中，一个订单被创建后一般不会再改动，这里很适合使用存储生成列\nMySQL UNIQUE KEY 唯一键 主键列不能包含 NULL 值，而唯一键列可以包含 NULL 值。\n在 MySQL 中，KEY 是 INDEX 的同义词。一个唯一键对应了一个唯一索引\n不像主键，唯一键允许其中的列接受 NULL 值。但是，NULL 值会破坏唯一键约束。也就是唯一键对 NULL 值无效。\nNOT NULL 也是一种特殊的约束\n假设在一个银行系统中有这样的逻辑：\n当用户 A 从自己的银行账户取出 500 元时，用户 A 的余额为 原余额 减去 500。当另一个用户 B 给用户转入 500 元时，用户 A 的余额为 原余额 加上 500。\n如果这两个操作同时发生，则可能导致用户 A 的余额是错误的。\nMySQL 的锁就是为了解决这种并发问题的。MySQL 支持三种类型的锁：表级锁、行级锁和页面所。\nMySQL 允许您在会话中显式地获取表锁，以防止其他会话在您需要独占访问表的期间修改表。\n锁的操作是在当前会话中进行的。一个会话只能为自己获取锁，并只能释放自己的锁。\nMySQL 提供了 LOCK TABLES 和 UNLOCK TABLES 语句用于显式地的获取表锁和释放表锁\n锁类型 表锁支持 READ 和 WRITE 两种类型的锁。 READ 锁用于共享读取表， WRITE 锁用于排斥的读写表，他们的特点如下：\nREAD 锁 持有表锁的会话只能读取表，但不能写入表。\n多个会话可以同时获取一个表的 READ 锁。\n其他会话无需显式获取 READ 锁即可读取该表，但是不能写入表。其他会话的写操作会一直等待知道读锁被释放。\nWRITE 锁 持有锁的会话可以读写表。\n只有持有锁的会话才能访问该表。在释放锁之前，没有其他会话可以访问它。\n持有 WRITE 锁时，其他会话对表的锁请求会阻塞。\n如果您没有显式地的释放表锁，当会话结束后，无论是 READ 锁还是 WRITE 锁，都会被 MySQL 释放掉。\n设置服务器字符集和排序规则 在配置文件中设置 MySQL 服务器的字符集和排序规则 这是推荐的设置方式，它是永久的。在修改配置文件后，请记得重启 MySQL 服务器。\n启动 MySQL 服务器时指定字符集和排序规则\n在命令行修改字符集和排序规则\n要查看数据库的字符集和排序规则 要查看当前数据库的字符集和排序规则，请使用如下语句： SELECT @@character_set_database, @@collation_database;\n要查看指定数据库的字符集和排序规则 SHOW CREATE DATABASE testdb;\nMySQL 提供了各种字符集以有效地存储各种字符。您可以为服务器、数据库、表、和列设置不同的字符级和排序规则。\n如果您需要在不同的字符集之间转换字符串，请使用 MySQL 提供的两个函数： CONVERT 和 CAST\n一个 ENUM 是一个字符串的列表，它定义了一个列中允许的值，列的值只能是创建列时定义的允许值列表中的的一个\nENUM (\u0026lsquo;v1\u0026rsquo;, \u0026lsquo;v2\u0026rsquo;, \u0026hellip;, \u0026lsquo;vn\u0026rsquo;)\n现在，我们已经创建好了 orders 表，其中 state 列为 ENUM 数据类型，并且它将只接受四个值: Unpaid, Paid, Shipped 和 Completed。同时，按照列定义时的顺序，Unpaid, Paid, Shipped 和 Completed 的索引分别为 1, 2, 3, 4\nMySQL 创建索引 索引是一种数据结构，例如 B-Tree，它提高了从表中检索数据行的速度，但需要额外的写入和存储来维护它。\n查询优化器可以使用索引来快速定位数据，而不必针对给定查询扫描表中的每一行。\n当您使用主键 或唯一键创建表时，MySQL 会自动创建一个名为 PRIMARY 的索引。 该索引称为聚集索引。\nPRIMARY 索引是特殊的，因为索引本身与数据一起存储在同一个表中。聚集索引强制执行表中行的顺序。\nPRIMARY 索引以外的其他索引称为二级索引或非聚集索引。\n如果您不指定索引类型，MySQL 将创建 B-Tree 索引。下面显示了基于表的存储引擎允许的索引类型\n让我们使用以下 CREATE INDEX 语句为该列 first_name 创建索引 CREATE INDEX first_name ON actor(first_name);\nMySQL 删除主键索引 DROP INDEX PRIMARY ON t;\nMySQL 唯一索引是一种特殊的索引，它不但可以加快从表中检索数据的速度，还能防止在指定的一个或多个列中出现重复值。\nMySQL 索引提示：USE INDEX MySQL 查询优化器是 MySQL 数据库服务器的一个组件，它为 SQL 语句制定最佳执行计划。 MySQL 优化器通常根据索引基数进行决策。 有时候，虽然你创建了索引，但是你的 SQL 语句却不一定使用索引。 这是因为 MySQL 查询优化器的做出了它认为的更优的选择。\nMySQL 允许您使用 USE INDEX 语句建议查询优化器去使用指定的命名索引。\n但是， MySQL 查询优化器依然有可能不适用您建议的索引。 如果您想 MySQL 必须使用您指定的索引，请使用 FORCE INDEX 子句。\n在 EXPLAIN 显示查询优化器使用错误索引的情况下， USE INDEX 很有用\n从输出可以发现， MySQL 查询优化器选择使用 idx_last_name 索引。\n如果您认为使用 idx_last_name_first_name 更好，则使用 USE INDEX 指定它\nUSE INDEX 告诉 MySQL 用列表中的其中一个索引去做本次查询，但是 MySQL 不一定会用。 FORCE INDEX 强制 MySQL 使用一个特定的索引。\n有时候，虽然你创建了索引，但是你的 SQL 语句却不一定使用索引。 这是因为 MySQL 查询优化器的做出了它认为的更优的选择。\nMySQL 查询优化器是 MySQL 数据库服务器的一个组件，它为 SQL 语句制定最佳执行计划。\n但是，您可以是使用 FORCE INDEX 子句告诉 MySQL 查询优化器必须使用指定的索引。\n要查看该语句的执行计划，请使用 EXPLAIN 语句：\nEXPLAIN SELECT * FROM film WHERE language_id = 1;\n当您定义多列索引时，您应该始终考虑业务上下文以确定哪些列经常用于查找，并在定义索引时将这些列放在列列表的开头\nMySQL 聚集索引 聚集索引是一种特殊的索引，此索引中的键值的顺序决定了表中相应行的物理顺序。作为类比，聚集索引类似于一个词典，词典中的目录相当于聚集索引，目录和词语都是按照字母顺序排序的。\n由于表中的数据只能按照一种顺序进行存储，因此一个表中最多只能有一个聚集索引\nMySQL 索引基数 一个索引的基数是指这个索引的列中的唯一值的数量。它是根据统计信息生成的一个估计值，不一定是准确的。\n索引的基数是 MySQL 查询优化器决定是否使用索引的一个重要依据。索引基数越高，使用索引越有效。\n如果索引的基数很低，全表扫描可能比使用索引更有效。\nMySQL 隐藏索引 MySQL 8 引入了隐藏索引（invisible index）。隐藏索引是实际存在的，但是对 MySQL 查询优化器不可见的索引。即使使用 FORCE INDEX，优化器也不会使用隐藏索引。\n在删除一个索引前，您可以先将索引隐藏。如果这不影响性能，您再去真正的删除索引。\n隐藏索引对 MySQL 查询优化器是不可见的，但是它是真实存在的，并且对写入操作保持最新\nMySQL 允许您使用 VISIBLE 和 INVISIBLE 标识索引是否可见\nMySQL 隐藏索引开关 MySQL 查询优化器默认不使用隐藏索引，但是您可以通过系统变量 optimizer_switch 中的 use_invisible_indexes 修改这一行为\nMySQL 字符串前缀索引 在 MySQL 中，您可以为字符串列的指定长度的前缀创建前缀索引。\n相比于为整个字符串列创建索引，前缀索引能减少磁盘的使用量，并提高索引的写入速度\nMySQL 索引顺序 在 MySQL 中，您可以在创建索引的时候指定索引的顺序。默认情况下，索引按照升序存储。\nLinux 启动/停止 MySQL 启动 MySQL 服务器 sudo systemd start mysqld\n停止 MySQL 服务器 sudo service stop mysqld\n重启 MySQL 服务器 sudo service restart mysqld\n在一些 Linux 发行版中，请使用 mysql 替代上面命令中的 mysqld。\n创建一个名为 sqliz 的新用户 CREATE user \u0026lsquo;sqliz\u0026rsquo;@\u0026rsquo;%\u0026rsquo; IDENTIFIED by \u0026lsquo;SqLiZ9879123!\u0026rsquo;;\n使用以下 DROP USER 语句删除用户 sqliz@localhost： DROP USER sqliz@localhost;\n杀掉已删除用户的会话 如果删除的用户在删除之前已经登录了一个会话，删除后并不会影响此会话，直到会话结束。这也会会带来危险。\n你可以使用以下 SHOW PROCESSLIST 语句查看会话列表，并使用 KILL 语句结束已删除的用户的会话。\n如您所见，用户帐户 sqliz@localhost 会话的 ID 是 26 。\n您可以使用使用 KILL 语句终止会话 26 KILL 26;\n您不能使用一个已有的用户账户作为新的用户账户，否则您将收到错误消息。\nRENAME USER 将旧用户的所有权限转移给新用户。但是，它不会删除或使依赖于旧用户的数据库对象无效。\n选择 mysql 数据库： USE mysql;\n更新密码 UPDATE user SET password = PASSWORD(\u0026lsquo;Db123654\u0026rsquo;) WHERE user = \u0026lsquo;dbadmin\u0026rsquo; AND host = \u0026rsquo;localhost\u0026rsquo;;\n刷新权限 FLUSH PRIVILEGES;\n请注意，从 MySQL 5.7.6 开始，用户表使用列 authentication_string 来存储密码。并且，它删除了 password 列。\n因此，如果您使用 MySQL 5.7.6+，则必须修改 UPDATE 语句中的 authentication_string 列 UPDATE user SET authentication_string = PASSWORD(\u0026lsquo;Db123654\u0026rsquo;) WHERE user = \u0026lsquo;dbadmin\u0026rsquo; AND host = \u0026rsquo;localhost\u0026rsquo;;\n通过使用该 SET PASSWORD 语句，您无需执行该 FLUSH PRIVILEGES 语句即可从授权表重新加载权限 以下语句使用 SET PASSWORD 语句更改用户帐户 dbadmin 的密码 SET PASSWORD FOR \u0026lsquo;dbadmin\u0026rsquo;@\u0026rsquo;localhost\u0026rsquo; = PASSWORD(\u0026lsquo;Db123654\u0026rsquo;);\n请注意，从 5.7.6 版开始，您不需要在 SET PASSWORD 语句中使用 PASSWORD()，而是直接使用明文密码。 SET PASSWORD FOR \u0026lsquo;dbadmin\u0026rsquo;@\u0026rsquo;localhost\u0026rsquo; = \u0026lsquo;Db123654\u0026rsquo;;\n第三种更改用户帐户密码的方法是使用 ALTER USER 带有 IDENTIFIED BY 子句的语句 ALTER USER dbadmin@localhost IDENTIFIED BY \u0026lsquo;Db123654\u0026rsquo;;\n如何在 MySQL 中锁定用户帐户 某些特定的场景下，您可能想要锁定一个用户账户，比如：\n创建一个锁定的用户，等授权完成后再解锁 此用户账户已经不被使用 此用户账户已经被泄露 此用户只是临时使用，使用完成后将用户锁定 要锁定一个已经存在的用户，请使用 ALTER USER .. ACCOUNT LOCK 语句。\n要直接创建一个锁定的用户，请使用 CREATE USER .. ACCOUNT LOCK 语句。\n查询用户的锁定状态 SELECT user, host, account_locked FROM mysql.user;\n在 MySQL 中使用 GRANT 语句给用户授权 作为一个数据库管理员或者维护人员，为了数据库的安全性，您需要更精确的权限控制。您可以给不同的用户赋予不同的权限。\n当您创建了一个新用户之后，这个新的用户可以登录 MySQL 数据库服务器，但是他可能没有任何权限。只有在赋予他数据库和相关表的权限之后，他才可以进行选择数据库和查询等操作。\n在 MySQL 中， GRANT 语句用于给用户赋予权限。 分配全局权限 GRANT ALL ON . TO sqliz@localhost; 这里将全部数据库全部对象的全部权限分配给了用户 sqliz@localhost\n分配数据库全部对象的全部权限 GRANT ALL ON sqliz.* TO sqliz@localhost; 这里将 sqliz 数据库全部对象的全部权限分配给了用户 sqliz@localhost\n分配数据库中某个表的的查询和插入权限 GRANT SELECT, INSERT ON sqliz.test_table TO sqliz@localhost; 这里将 sqliz 数据库中的 test_table 表的 SELECT 和 INSERT 权限分配给了用户 sqliz@localhost\nMySQL REVOKE 语句介绍 MySQL REVOKE 语句用于撤销用户帐户的一项或多项权限。\nMySQL REVOKE 语句有几种形式。\n撤销代理 要撤销代理用户，请使用以下 REVOKE PROXY 命令\n代理用户是 MySQL 中可以模拟另一个用户的有效用户，因此，代理用户拥有它模拟的用户的所有权限。\n在撤销用户的权限之前，使用以下 SHOW GRANTS 语句显示用户帐户的权限是一个好习惯\nMySQL REVOKE 生效时机 REVOKE 语句的生效时机取决于权限级别：\n全局: 当用户帐户在后续会话中连接到 MySQL 服务器时，更改生效。更改不会应用于所有当前连接的用户。\n数据库级别: 更改在下 USE 一条语句后生效。\n表和列级别: 更改对所有后续查询生效。\n在 MySQL 中，您可以使用 REVOKE 语句撤销授予用户的一个或者多个权限。\n显示授予当前用户的权限 SHOW GRANTS;\nGRANT USAGE 是没有权限的代名词。默认情况下，当新用户创建时，它没有权限。\n在 MySQL 中，您可以使用 SHOW GRANTS 语句显示授予用户或角色的权限。\n在 MySQL 中使用角色来简化权限管理 MySQL 角色语法 如果要将同一组权限授予多个用户，请执行以下步骤：\n首先，创建一个新角色。 其次，为角色授予权限。 第三，将角色授予用户。\n角色名称类似于用户帐户，由两部分组成：名称和主机。如果省略主机部分，则默认为 %，表示任何主机。\n如果需要在一个语句中创建多个角色，请使用逗号分隔不同的角色名。\n设置活跃角色 用户帐户可以通过指定哪个授予的角色处于活动状态来修改当前用户在当前会话中的有效权限。\n以下语句将活动角色设置为 NONE，表示没有活动角色 SET ROLE NONE;\n要将活动角色设置为所有授予的角色，请使用 SET ROLE ALL;\n要将活动角色设置为 SET DEFAULT ROLE 语句设置的默认角色，请使用 SET ROLE DEFAULT;\nSHOW SCHEMAS 是 SHOW DATABASES 的同义词，他们具有相同的返回结果。\n如果运行此命令的用户不是超级用户，则只返回用户具有权限的数据库列表。\n您还可以使用 LIKE 对结果进行过滤\nMySQL 中的几个维护数据库表的语句 定期的维护数据表是一个很好的习惯。对提高数据库的性能很有帮助。\nMySQL 提供了几个维护数据库表的语句：\nANALYZE TABLE: 分析表 在一个表中进行了大量数据插入，更新或者删除操作后，键分布可能是不准确的。如果键分布不准确，查询优化器可能会选择错误的查询执行计划，这可能会导致严重的性能问题。\n如果你感觉实际执行计划并不是预期的执行计划，执行一次分析表可能会解决问题\nOPTIMIZE TABLE: 优化表 典型的，在一个表中进行了大量数据更新或者删除操作后，表的物理存储可能变得碎片化。最总导致数据库服务器的性能下降\nCHECK TABLE: 检查表 数据库服务器可能发生一些错误，例如服务器意外关闭、向硬盘写入数据时出错等。这些情况可能导致数据库运行不正确，最坏的情况可能是崩溃。\nMySQL 允许您使用 CHECK TABLE 语句检查数据库表的完整性\nREPAIR TABLE: 修复表 REPAIR TABLE 语句允许您修复数据库表中发生的一些错误。MySQL 不保证 REPAIR TABLE 语句可以修复表可能存在的所有错误\n使用 mysqldump 工具备份数据库 mysqldump 是一个用于备份 MySQL 数据库的工具，它能将 MySQL 数据库导出为一个 sql 文件。\n作为一个数据库管理员或者运维人员，定期备份线上的 MySQL 数据库是一个很有必要的工作。它可能帮你在数据库遭到损坏的时候保留数据或者恢复备份。\nMySQL 提供了 mysqldump 工具用于从 MySQL 数据库服务器中导出数据库结构和数据\nmysqldump 是一个用于备份 MySQL 数据库的工具。它提供了很多选项以应对不同的备份需求\n使用 MySQL SOURCE 命令恢复数据库 使用 mysql 命令恢复 在 MySQL 中， SOURCE 命令可以帮您将数据库备份文件恢复到数据库中。除此之外，您还可以直接使用 mysql 命令恢复数据库\n在 MySQL 中使用 SHOW PROCESSLIST 语句显示连接列表 MySQL 提供了 SHOW PROCESSLIST 命令用来返回当前数据库服务器的所有的连接的信息，包括连接的 ID，用户，主机，数据库，时间和状态等。\nMySQL 将当前服务器的所有的连接信息保存在 information_schema.processlist 表中，您还可以从此表查询所有的连接的信息。\n实际上， SHOW PROCESSLIST 命令只是查询 information_schema.processlist 表的简写形式。\n有时，您可能会收到 MySQL 服务器返回的“连接过多”错误。要找出原因，您可以使用 SHOW PROCESSLIST 命令获取当前所有的连接，并使用 KILL 语句终止空闲线程\nMySQL 创建视图 MySQL 是一种常用的关系型数据库管理系统，提供了 CREATE VIEW 语法，用于创建视图（View）。视图是一种虚拟的表，实际上并不存储数据，而是从一个或多个表中派生出来的查询结果集，具有与表相似的结构。通过创建视图，可以将复杂的查询操作封装成一个简单的视图，方便用户进行查询和数据访问\nCREATE VIEW 是 MySQL 中用于创建视图的语法，通过创建视图，可以将复杂的查询操作封装成一个简单的视图，方便用户进行查询和数据访问。在使用 CREATE VIEW 时，需要指定视图的名称、包含的列名、基表和查询条件等。视图可以在数据权限管理、应用程序开发等场景中起到很大的作用，提高数据库的灵活性和安全性。\n可以使用 SHOW 命令来列出数据库中的所有视图 SHOW FULL TABLES IN database_name WHERE TABLE_TYPE LIKE \u0026lsquo;VIEW\u0026rsquo;;\nSHOW FULL TABLES IN mydb WHERE TABLE_TYPE LIKE \u0026lsquo;VIEW\u0026rsquo;;\nMySQL 可更新视图 WITH CHECK OPTION 是 MySQL 中 CREATE VIEW 的一个有用的子句，它允许在创建视图时限制对视图的插入和更新操作。通过合理使用 WITH CHECK OPTION，可以确保只有符合特定条件的数据才能被插入或更新到视图中，从而保护数据库中的数据完整性。在设计数据库时，可以考虑使用 WITH CHECK OPTION 来实现细粒度的数据访问权限控制，提高数据库的安全性和可靠性\nMySQL 触发器 MySQL 触发器是一种数据库对象，它可以在特定的数据库表上自动执行一系列的操作，例如插入、更新或删除数据，当特定的事件（例如数据的插入、更新或删除）发生时触发。MySQL 触发器是一种强大的工具，可以用于实现数据库的自动化行为，例如数据验证、数据关联、审计日志等。\nMySQL 触发器通常由 SQL 语句组成，定义了触发器要执行的操作。MySQL 支持三种类型的触发器：\nBEFORE 触发器：在执行实际的数据操作之前触发，例如在插入、更新或删除数据之前执行某些操作，例如数据验证、数据转换等。\nAFTER 触发器：在执行实际的数据操作之后触发，例如在插入、更新或删除数据之后执行某些操作，例如生成审计日志、更新相关数据等。\nINSTEAD OF 触发器：在执行实际的数据操作之前触发，并可以在触发器中替代原始的数据操作，例如在插入、更新或删除数据之前执行自定义的数据操作，而不是执行原始的数据操作。\nMySQL 触发器可以在创建表时定义，也可以在表创建后通过 ALTER TABLE 语句来添加、修改或删除。触发器可以基于特定的表和事件（插入、更新、删除）来触发，并可以包含条件、循环、异常处理等复杂逻辑。\nMySQL CREATE TRIGGER 创建触发器 数据验证和约束：可以通过触发器在数据插入、更新或删除前后进行验证和约束，确保数据库中的数据满足特定的业务规则和限制条件。 数据补全和处理：可以通过触发器在数据插入或更新前后进行自动补全和处理，例如自动生成序列号、计算字段值等。 数据审计和日志记录：可以通过触发器在数据插入、更新或删除时记录审计日志，用于追踪数据变更历史和安全审计。 数据复制和同步：可以通过触发器在数据插入、更新或删除时自动将数据复制到其他表或数据库，实现数据的同步和复制\nMySQL 的触发器是一种强大的数据库特性，可以在数据库表上定义一组操作，自动在特定事件发生时触发执行。通过 CREATE TRIGGER 语法，我们可以创建自定义的触发器，用于实现数据验证、数据处理、数据审计等业务需求。但需要注意，滥用触发器可能导致性能问题和复杂性增加，因此在使用触发器时应慎重考虑，并遵循最佳实践\nBEFORE INSERT 触发器的语法如下： CREATE TRIGGER trigger_name BEFORE INSERT ON table_name FOR EACH ROW BEGIN \u0026ndash; 触发器操作 END;\n其中，trigger_name 是触发器的名称，可以自定义；table_name 是触发器所属的表名；FOR EACH ROW 表示对表中的每一行数据都执行触发器操作；BEGIN 和 END 之间是触发器操作的具体内容。\nBEFORE INSERT 触发器通常用于在插入数据之前自动执行一些辅助性的操作，如数据验证、数据补全、数据处理等。以下是一些常见的使用场景：\n数据验证：在插入数据之前，对数据进行验证，例如检查数据的完整性、合法性、唯一性等。 数据补全：在插入数据之前，对缺失的数据进行补全，例如设置默认值、自动生成字段值等。 数据处理：在插入数据之前，对数据进行处理，例如将数据进行格式化、转换、加密等。\n","date":"2024-04-13T13:35:01+08:00","permalink":"https://example.com/p/python/","title":"python"},{"content":"推荐 这是我从一个大佬的个人周刊总结出来可能对我现在或以后有用的项目，资料，软件，网站等，涉及cs学习，日常软件使用，建议结合自己个人去看看\n这是大佬的周刊链接，双手奉上 https://weekly.howie6879.com/\n绝大多数需要在全球最大的同性交流平台上查找————github\n项目 DF-Handling-With-Python 最近刚开源的一款PDF编辑工具[基于Python]（这种类型的库比较少见），你可以对PDF： 提取文本 提取图片 提取表格 提取链接 对PDF进行相关编辑操作\nawesome-productivity-cn 这是一份开放的由中文社区共建的绝妙系列精选资源清单，专注于提升个人生产力的知识方法和工具。此项目从书籍、网站、工具、笔记、任务管理等角度推荐怎么提升个人生产力\nReal-CUGAN 🔥 Real-CUGAN🔥 是一个使用百万级动漫数据进行训练的，结构与Waifu2x兼容的通用动漫图像超分辨率模型。它支持2x\\3x\\4x倍超分辨率，其中2倍模型支持4种降噪强度与保守修复，3倍/4倍模型支持2种降噪强度与保守修复。\nReactive-Resume 免费开源的简历生成器，支持包括中文在内的十几种语言，让你可以快速生成漂亮的简历\nlsky-pro 非常优秀的图床开源项目，如果你手头有服务器，那么可以考虑自建图床服务：\nawesome-wechat-weapp 最近在开发一款微信小程序，第一次上手，发现还是很有意思的。这个项目收集了小程序开发的方方面面，如：工具、插件、组件、Demo等。\n基本上只要找一个开源的小程序，找一个示例跟着写，哪怕你没基础，也能很快开发一款自己的小程序出来，推荐。\naliyundrive-webdav 阿里云盘 WebDAV 服务，主要使用场景为配合支持 WebDAV 协议的客户端 App 如 Infuse 等实现在电视上直接观看云盘视频内容。\n如果你的阿里云盘不少视频，每次播放没必要下载下来，用这个构建一个基于阿里云盘的 WebDAV 服务，然后就可以通过 WebDAV 协议在相关视频软件上播放，我这里就利用 Infuse 连接上了，可以直接看阿里云的相关视频：\n500lines 如果工作中用Python比较多的朋友，应该会听过500lines项目，它是aosabook项目（下面网站部分有介绍）的第四本书。\n这个项目由 18 个独立的章节组成，每个章节都是由该领域的大牛完成，每个章节都试图用 500 行或者更少的代码，让大家了解一个功能或需求的简单实现，比如有：\n持续集成系统 分布式系统 异步爬虫 等等\ncomputer_book_list 该项目整理了豆瓣和goodreads的和计算机，互联网有关的几乎所有书籍。根据不同版本，两个平台的总评价人数和评分求出平均分，按从高到低排列，为寻找经典计算机书籍的朋友提供帮助\nReal-ESRGAN Real-ESRGA目标是做一款针对照片、动画图片的分辨率放大工具，其内置了一个预训练模型，可以提升 4 倍分辨率，具体效果大家可以看看下面的截图：\npython-mini-projects 最近在热榜上挺火的一个项目，这个项目是由一个个 Python 小项目构成，可以慢慢练习，增强 Python 技巧，项目还提供了网站访问\nfree-api 作者创建此开源项目的目的如下：\n为了方便广大的开发者，特此统计了网上诸多的免费API，为您收集免费的接口服务，做一个API的搬运工，以后会每月定时更新新的接口。有些接口来自第三方，在第三方注册就可以成为他们的会员，免费使用他们的部分接口。\n包含域名拦截检测、OCR 识别、文本分类、新闻搜索、天气查询、单词翻译、图灵机器人、随机头像获取等接口：\ndocker-wechat 盒装微信，在linux下基于Docker技术使用微信客户端：\npersonal-management-system 该项目可以很方便的管理个人数据，如目标规划/笔记/联系人/密码/附件/图片/文件等等：\nAI-Writer AI 写小说，生成玄幻和言情网文等等。中文预训练生成模型。采用作者的 RWKV 模型，类似 GPT-2 。\nmelody 你的音乐精灵，旨在帮助你更好地管理音乐；目前的主要能力是帮助你将喜欢的歌曲或者音频上传到音乐平台的云盘。\n主要特性为：\n支持在各大音乐和视频网站检索歌曲。目前支持 咪咕、网易云、QQ 音乐、酷狗、bilibili 等站点 用链接搜索歌曲 一键解锁无法播放的歌曲（实验性功能，目前仅支持网易云） 比如搜索周杰伦的青花瓷，可以直接播放且上传到云盘：\nCleanMyWechat 自动删除 PC 端微信缓存数据，包括从所有聊天中自动下载的大量文件、视频、图片等数据内容，解放你的空间：\nawesome-chatgpt-prompts-zh ChatGPT 中文调教指南，各种场景使用指南，学习怎么让它听你的话：\nlaw-cn-ai AI 法律助手:\nmanga-image-translator 一键翻译各类图片内文字，针对群内、各个图站上大量不太可能会有人去翻译的图片设计，让我这种日语小白能够勉强看懂图片，主要支持日语，汉语、英文和韩语，支持图片修补和嵌字:\nbackground-removal-js 在浏览器环境中直接删除图像背景，不需要额外的成本或隐私问题，在线体验\nsigma-file-manager Sigma File Manager 是一个免费、开源、快速发展的现代文件管理器（资源管理器/查找器）应用程序，适用于Windows\u0026amp;Linux，支持智能搜索、自定义主页、文件共享、文件下载、智能拖放、文件保护等功能：\ndraw-a-ui 利用 tldraw + gpt-4-vision api 将绘制的图转换成 html 代码：\ntvapk 收集各大 AndroidTV 的 apk 应用，可免费看各种vip和国外电影电视：\nwebdesk 一键将网站转化为桌面应用程序：\ngitstars Github 作为开发者的第一社交平台，拥有数不胜数的优秀开源项目，给工作和学习带来巨大方便，遇到自己需要或是喜爱的项目只需点击 Star 便可收入囊中。\nStar is easy，可随着 Starred Repositories 增长，在需要使用到某个项目时难免记不清叫什么，而 Github 又只提供简单的搜索，找到目标 Starred Repository 竟也成了件小小的麻烦事。\n所以拥有自己的 Github Stars Repositories Manager 也算是开发者的必备需求。Gitstars 由此诞生 💡\nimsyy/home 简单优雅的个人主页项目：\n载入动画 站点简介 Hitokoto 一言 日期及时间 实时天气 时光进度条 音乐播放器 移动端适配\nfre123-nav 这是老胡上个月做的一个导航网站，不少人想基于这套进行二次开发，所以开源出来，希望能帮到大家：\nfre123-nav：导航页面源码 fre123-info-flow：信息流页面源码 Fre123 导航网站搭建教程\npaper-ai 利用人工智能撰写论文\n人工智能书写功能： 点击 “AI 写作 “进行正常对话互动。人工智能将根据您的输入提供写作建议或回答问题。 Paper2AI功能： 点击 “Paper2AI”，根据输入的关键词在Semantic Scholar或arxiv中搜索论文。系统将把信息整合到您的论文中。 介绍视频：引用真实文献的AI写论文网站\nczkawka 一款简单、快速和免费的开源跨平台应用程序，可以从您的计算机中删除不必要的文件。\n支持扫描计算机上重复、空文件夹、大文件、相似图像/视频/音乐、无效/损坏文件等内容，扫描速度极快。\n12306spy 从12306购票，从A点到B点没有票，但是可以补票或者多买一段票。这个项目可以让你通过这种方式买到票：\nRaptor 使用 Qt 和 C++ 构建的低内存、小而美的第三方阿里云盘 Windows 桌面应用客户端🚀\n🧬 用户 - 持久化登录，多用户登录，多用户切换 📉 文件（夹） - 创建/多级创建文件夹/重命名/搜索 💅 文件（夹） - 移动/复制 ✅ 文件（夹） - 上传/下载/唤起第三方下载器下载 🎪 视频 - MPV/VLC/PotPlayer 💸 分享 - 创建分享/导入分享 🦹🏻‍♀️ 秒传 - 创建秒传/导入秒传 ⭐️ 收藏 - 收藏/取消收藏/搜索 🕵️‍♂️ 回收站 - 清空/删除/恢复 📚 Plus - 跨网盘文件复制 🏅 UI - 可自由修改的字体，图标与主题\n软件 Joplin 我推崇的一个跨平台笔记软件，更新迭代快速，插件生态也还不错，各大平台都有支持，对于数据存储，你可以：\n自建服务端 第三方如坚果云等 也可以基于云商，如腾讯云的COS\nscrcpy 在GNU/Linux, Windows 和 macOS上显示并控制通过 USB (或 TCP/IP) 连接的安卓设备，不需要任何 root 权限。\n它专注于：\n轻量 (原生，仅显示设备屏幕) 性能 (30~60fps) 质量 (分辨率可达 1920×1080 或更高) 低延迟 (35~70ms) 快速启动 (最快 1 秒内即可显示第一帧) 无侵入性 (不会在设备上遗留任何程序)\n全是漫画 全是漫画App，是替代网页浏览器，专门阅读漫画的工具，无需注册完全免费，基本上覆盖了所有的漫画网站\nuPic uPic是原生强大且美观的MacOS图床软件，支持多种图片上传方式：smms, UPYUN USS, qiniu KODO, Aliyun OSS, TencentCloud COS, BaiduCloud BOS, Weibo, Github, Gitee, Amazon S3, Imgur, custom upload api, …\nBob 同样是我的必备软件，Bob 是一款 Mac 端翻译软件，支持划词翻译、截图翻译以及手动输入翻译。\n[x] 划词翻译 [x] 截图翻译 [x] 输入翻译 [x] 翻译多开 [x] 自定义插件 [x] 自动识别语种 [x] 驼峰拆分、蛇形拆分 [x] AppleScript 调用 [x] PopClip 调用\napifox Apifox 是 API 文档、API 调试、API Mock、API 自动化测试一体化协作平台，定位 Postman + Swagger + Mock + JMeter。通过一套系统、一份数据，解决多个系统之间的数据同步问题。只要定义好 API 文档，API 调试、API 数据 Mock、API 自动化测试就可以直接使用，无需再次定义；API 文档和 API 开发调试使用同一个工具，API 调试完成后即可保证和 API 文档定义完全一致。高效、及时、准确！\nSmart-Scientific-Reader Hammer PDF，一款由北京理工大学计算机学院 DataHammer 研究组开发维护的全新科技智能阅读器，能够快速分析 PDF 学术文献，实时提供可靠的学术信息。增进科研生产力就看这里！\nHammer PDF 将论文、作者、报告视频、数据集、代码、博客等学术资源通过数据关联和知识挖掘等手段组成一个有机整体，不仅提供基础的 PDF 阅读功能，还支持信息抽取、语义分析等自然语言处理任务，大大扩展传统 PDF 阅读器的功能，为研究人员提供最新可靠的扩展信息，显著提升学术研究的工作效率。\n支持网页端、桌面端，非常强大。\nCatchMouse 如果你在工作过程中有两个及以上显示器，那么可能在日常会经常移动鼠标到对应屏幕，这个过程是耗时的，可以使用CatchMouse快速解决这个问题，分别为每个显示器设置快捷键即可。\nvnote VNote是免费、开源的，致力于成为一个舒适的笔记平台（平台支持）\nBulk-Crap-Uninstaller Bulk Crap Uninstaller 是一款免费开源的 Windows 卸载软件，它能够快速删除大量不需要的应用程序，甚至是便携或未注册的程序与游戏，并且能自动扫描残留文件、注册表遗留内容\npot-desktop 🌈 一个跨平台的划词翻译软件，对标 Bob：\npho 一个用于查看和上传照片的无服务端应用，该应用的目的是替代手机上的自带相册应用，并且能够将照片同步到网络储存：\nToastFish 这是一个利用 Windows 通知栏背单词的软件，可以让你在上班、上课等环境下安全地背单词：\nLKY_OfficeTools 一键自动化 下载、安装、激活 Office 的利器。绿色、开源、安全、无毒：\n一键快速下载、安装、激活最新版 Microsoft Office 软件。 用户可在安装 Word、PPT、Excel 的同时，根据软件提示，自助安装其它组件，包括： Outlook、OneNote、Access、Visio、Project、Publisher、Teams、OneDrive、Lync/Skype 工具可自动识别不同的操作系统架构，自动下载适配版本的 Office。 本工具激活 Office 的方式为正版激活模式，不会篡改任何系统文件。 当系统中存在多个冗余 Office 版本时，本工具在用户同意的情况下，可实现自动升级。\nVPet 虚拟桌宠模拟器 一个开源的桌宠软件, 可以内置到任何 WPF 应用程序，支持各种互动投喂等. 开源免费并且支持创意工坊：\nAndroid-Touch-Helper 李跳跳下线了，还有开源的出来，开屏跳过-安卓系统的开屏广告自动跳过助手。\n开屏跳过可以帮助用户自动跳过一些应用的开屏广告，基于Android的无障碍服务实现。\n使用广告跳过程序，最大的风险是个人隐私被泄露。因为这种软件都需要开启Accessibility 无障碍服务，可以获取屏幕上的所有内容，从而可以检测广告，帮助用户自动跳过。\n本程序是开源程序，不需要网络权限，不需要存储权限，不会收集或者上传任何信息！绝无隐私问题：\nGeekDesk 小巧、美观的桌面快速启动管理工具，同时集成了 Everything 搜索，仅支持 Windows：\nlyrebird 基于 Python 和 GTK 编写的变声器，专门适用于 Linux 系列：\n干净简洁的UI 内置效果可实现准确的男声和女声 创建\u0026amp;加载自定义预设的能力 创建自己的临时虚拟输入设备\nGitUp 简洁的 Git 客户端：\nPicList PicList 是一款高效的跨平台云存储和图床平台管理工具，在 PicGo 的基础上经过深度的二次开发，不仅完整保留了 PicGo 的所有功能，还增添了许多新的特性：例如：\n相册支持同步云端删除文件 内置图床额外添加了 WebDav、本地图床和 SFTP 增加了完整的云存储管理功能 等等\nwinlator 使用 Wine \u0026amp; Box86/Box64 的安卓应用程序，此项目特点是可以运行 Windows 应用程序。\nTran 简洁, 快速, 划词翻译：\n开箱即用 永久免费使用 谷歌翻译镜像\ngitbutler Git 分支管理工具，从头开始构建，用于现代工作流：\nFluentRead 一个开源油猴脚本，拥有基于上下文语境的人工智能翻译引擎，为网站提供更加友好的翻译，让所有人都能够拥有基于母语般的阅读体验：\ncrow-translate 一个简单而轻巧的翻译器，可以使用 Google、Yandex Bing、LibreTranslate\u0026amp;Lingva 来翻译和朗读文本：\n资料 influential-cs-books 该项目整理了计算机领域最具有影响力的编程\u0026amp;计算机科学书籍，书单的来源是stackoverflow上一个名为What is the single most influential book every programmer should read? 的回答。\npdai Java 全栈知识体系，包含: Java 基础, Java 部分源码, JVM, Spring, Spring Boot, Spring Cloud, 数据库原理, MySQL, ElasticSearch, MongoDB, Docker, k8s, CI\u0026amp;CD, Linux, DevOps, 分布式, 中间件, 开发工具, Git, IDE, 源码阅读，读书笔记, 开源项目…\n穷佐罗的Linux书 emojimix 一个表情融合网站，图一个乐呵，效果如下：\ncoder2gwy 互联网首份程序员考公指南，由3位已经进入体制内的前大厂程序员联合献上。\n网道 前面资料部分有介绍阮一峰老师的c语言教程，其实那个教程属于这个网道项目的一部分，这个项目的目标是，提供高质量的、拥有自主版权的、可以自由使用的中文软件文档。\ncs-self-learning 计算机自学指南，作者目标是让一个刚刚接触计算机的小白，可以完全凭借这些开源社区的优质资源，少走弯路，在2-3年内成长为一个有扎实的数学功底和代码能力，经历过数十个千行代码量的Project的洗礼，掌握至少C/C++/Java/JS/Python/Go/Rust等主流语言，对算法、电路、体系、网络、操统、编译、人工智能、机器学习、计算机视觉、自然语言处理、强化学习、密码学、信息论、博弈论、数值分析、统计学、分布式、数据库、图形学、Web开发、云服务、超算等等方面均有所涉猎的全能程序员。\nmissing-semester-cn 计算机教育中缺失的一课，翻译自麻省理工的《The Missing Semester of Your CS Education》。\n在传统的计算机科学课程中，从操作系统、编程语言到机器学习，这些高大上课程和主题已经非常多了。 然而有一个至关重要的主题却很少被专门讲授，而是留给学生们自己去探索。 这部分内容就是：精通工具。\nLeetCode-Py 算法通关手册，超详细的「算法与数据结构」基础讲解教程，「LeetCode」650+ 道题目 Python 版的详细解析。通过「算法理论学习」和「编程实战练习」相结合的方式，从零基础到彻底掌握算法知识。\nCS-Notes 📚 技术面试必备基础知识、Leetcode、计算机操作系统、计算机网络、系统设计:\nleetcode 本项目包含 LeetCode、《剑指 Offer（第 2 版）》、《剑指 Offer（专项突击版）》、《程序员面试金典（第 6 版）》等题目的相关题解。所有题解均由多种编程语言实现，包括但不限于：Java、Python、C++、JavaScript、C#、Go，日常更新。\nleetcode-master LeetCode 刷题攻略：200道经典题目刷题顺序，共60w字的详细图解，视频难点剖析，50余张思维导图，支持C++，Java，Python，Go，JavaScript等多语言版本，从此算法学习不再迷茫！本项目同样提供了在线访问地址：programmercarl\nwhys-the-design 为什么这么设计（Why’s THE Design）是一系列关于计算机领域中程序设计决策的文章，我们在这个系列的每一篇文章中都会提出一个具体的问题并从不同的角度讨论这种设计的优缺点、对具体实现造成的影响。\n猴子都能懂的GIT入门 一份免费的简单易懂的 Git 入门教程，分为入门篇和高级篇\nlean-side-bussiness 精益副业：程序员如何优雅地做副业:\ndeveloper-roadmap 开发人员学习成长路线图：\nStudent-resources 本文介绍的是利用学生、教职工身份可以享受到的相关学生优惠、教育优惠或教师优惠的权益，但也希望各位享受权利的同时不要忘记自己的义务，不要售卖、转手自己的学生优惠、教育优惠的资格，使得其他同学无法受益。\nmysql-tutorial 从零开始学习MySQL，主要是面向MySQL数据库管理系统初学者：\nlinux-command Linux命令大全搜索工具，内容包含Linux命令手册、详解、学习、搜集\nawesome-mongodb 关于 MongoDB，最全面的免费学习向导：\n学习资源：文档书籍教程等 第三方库：各种编程语言的兼容库 各种工具：比如桌面应用、Web GUI、迁移工具等\nhello-algo Hello 算法是一本动画图解、能运行、可提问的数据结构与算法入门书，本书面向数据结构与算法初学者，致力于达成以下目标：\n开源免费，所有同学都可在网上获取本书； 新手友好，适合算法初学者自主学习入门； 动画讲解，尽可能地保证平滑的学习曲线； 代码导向，提供精简、可运行的算法代码； 讨论学习，提问一般能在三日内得到回复；\n计算机底层的秘密 以图解的方式通俗易懂地讲解计算机系统中各项技术的本质，包括编程语言的本质是什么、操作系统、进程线程协程等的本质是什么、到底什么是内存、什么是堆区栈区、内存分配等是怎么一回事、怎样从晶体管构建出CPU、I/O是如何实现的等等，从根源出发，一步步讲解一项技术到底是怎么来的，同时内容可视化——辅助大量精心设计的插图，几乎做到了平均一页有一图，把对技术的理解门槛尽量降低-在线阅读(需要pdf可联系我私发)：\ntuning_playbook_zh_cn 深度学习调优指南中文版，一本系统地教你将深度学习模型的性能最大化的战术手册：\none-python-craftsman 来自一位 Pythonista 的编程经验分享，内容涵盖编码技巧、最佳实践与思维模式等方面：\nhzpt-inet-club/english-note 从0开始学习英语语法的开源项目：\nsql-mother 免费的闯关式 SQL 自学教程网站，从 0 到 1 带大家掌握常用 SQL 语法，纯前端实现，简单易学\nnote-hack 《打造超人笔记》是一本关于如何有效记录和整理笔记的书籍。\n作者认为，笔记是一个看起来复杂但实际上比学习和阅读更简单的问题。通过拆解笔记的流程，作者发现主要问题的结构变得非常简单。此外，随着科技的发展，许多快速记录工具和笔记整理软件已经被发明出来，使笔记搜寻变得更加容易。\n在本书中，作者探讨了如何通过做笔记和整理笔记来挖掘和整理自己对一个领域的各种答案。通过阅读本书，读者可以学习到如何使用各种工具和方法来提高自己的笔记能力，成为一个笔记超人。\nGolangStudy 《GolangStudy》：从简单到难最全总结，go基础，数据结构，算法，设计模式：\nMySQL\u0026amp;PG 数据库教程 一个专门讲数据库教程的资料网站\nsmartexcel 使用 ChatGPT，在几秒钟内生成您所需的 Excel 公式\nLinux 101 本书由中国科学技术大学 Linux 用户协会的数名优秀成员协力编写，用于配套和延展“Linux 101”校内社团活动。其面向 Linux 零基础读者，从计算机操作系统和 Linux 的起源讲起，深入浅出带领读者一步步逐渐掌握最必要的 Linux 实用知识，并在其中感悟到社区开源文化的魅力：\nv2rayA v2rayA 是一个支持全局透明代理的 V2Ray 客户端，同时兼容 SS、SSR、Trojan(trojan-go)、Tuic \u0026amp; Juicity 协议， 致力于提供最简单的操作，满足绝大部分需求，得益于 Web 客户端的优势，你不仅可以将其用于本地计算机，还可以轻松地将它部署在路由器或 NAS 上。\nPaperlib 一个简单好用的开源论文管理工具，全平台支持：\n为多学科定制元数据搜索器，尤其是 CS 学科，及其精准的会议论文metadata 匹配。 macOS spotlight 一样的快速复制粘贴 bibtex 引用。 支持插件。 干净整洁的 UI。 订阅 RSS 获取最新论文 全文搜索，评价，星标，标签，组，MD 纯文本笔记等 云同步，三平台支持：macOS, Windows, Linux\nSam Altman的创业手册 Sam Altman 的创业手册文本，给YC系创始人们的建议里面最通用的一部分提炼出来变成一个创业手册。\nwaytoagi AI 知识库和工具站\n网站 Connected Papers Connected Papers是一个旨在帮助科研工作者搜索文献的全新工具，除了搜索目标论文外，它还可以在线进行分析文献的引文信息并以图网络的形式展现出来\ncleanup.pictures 百分百免费的一款图片橡皮擦工具，可以擦涂图片上的一些背景和无关图案，获得过producthunt周榜首荣誉，并且也开源在 github 值得尝试，下面是擦除前后对比：\nPython Tutor 这个网站可以将Python代码执行并可视化展示，目前共支持Python、Java、C、C++、JavaScript、Ruby等编程语言，新手教学、教程编写可以引用可视化结果来方便理解：\nQwerty Learner 这也是一个开源项目，作者将英语单词的记忆与英语键盘输入的肌肉记忆的锻炼相结合，可以在背诵单词的同时巩固肌肉记忆。\n网站提供了常用的 CET-4 、CET-6 、GMAT 、GRE 、IELTS 、SAT 、TOEFL 、考研英语、专业四级英语、专业八级英语，也有程序员常见英语单词以及多种编程语言 API 等词库。\ncalmcode 非常适合Python开发者的一个学习网站，里面通过短视频介绍了各种有用的工具，看了几分钟就可以上手，能快速扩充你的知识面。\nYYeTsBot 人人影视bot，完全对接人人影视全部无删减资源，用户除了通过浏览器访问，还可以通知TG访问：\nregexlearn 一个正则表达式学习网站，一步一步带你从新手到高级阶段，值得一试：\n即时工具 该网站提供了视频工具、音频工具、图片工具、PDF 工具、办公辅助、设计工具、文本工具、数字工具、加密工具、单位转换等工具共计 200 多款，无需登录无任何限制免费试用。\nregex101 regex101主要解决的是不同语言开发时怎么快速测试正则表达式的问题，目前网站支持以下语言：\nPHP Python JS Go Java\nlearngitbranching @妙才投稿，在线学习git命令的网站：\nsci-hub 这是科研界女神Alexandra Elbakyan做的论文下载网站，诞生以来就一直受到相关领域的打击，甚至一度即将消亡，但是作者不屈不挠这次甚至做了更新！\nElbakyan 表示：「 Sci-Hub 更新了，现在用户可以实时查看下载统计、每月统计等，并在将来会增加更多内容。」\n用户可通过以下方式访问新版本：\nhttps://sci-hub.se/ https://sci-hub.ru/ https://sci-hub.st/\ndevtool.tech 开发者武器库，作者提供了83个开发者常用的工具：\nwatermarkremover 通过AI技术去除图片水印：\njsonvisio 将你的Json数据进行可视化，该项目也开源在github-jsonvisio：\ncook 一个开源的做菜项目，作者提供了做菜网页版让用户可以很方便地进行交互，比如我选择番茄，下面就会有很多选项：\nmyfirstnft 我的第一个NFT，在这个网站，你可以：\n理解NFT的价值 铸造一个免费的NFT 了解Web3.0\nmusetransfer MuseTransfer 是一款轻便高效的大文件在线传输工具，无需注册登录，打开网页即可免费全速上传或下载超大文件\npixabay Pixabay 是全球知名的图库网站及充满活力的创意社区，拥有上百万张免费正版高清图片素材，涵盖照片、插画、矢量图、视频等分类，你可以在任何地方使用 Pixabay 图库中的素材，无惧版权风险：\nsayhello 面向开发者的搜索引擎。搜索结果可以直接显示出来相关代码片段：\ndevdocs 提供在线快速查找API接口文档的网站：\nmeow.tg TG喵-可能是最懂你的Telegram资源搜索引擎:\njsont.run 一个简洁的在线 JSON 解析器：\nphotoroom 利用人工智能生成背景图片（基于Stable Diffusion license），还提供了智能去除图片背景的功能\nsmalldev.tools 开发者常用工具集：\nwantquotes.net 清华大学计算机系自然语言处理实验室出品的一款根据意思查询名言\u0026amp;佳句\u0026amp;诗词\u0026amp;网络\u0026amp;台词的网站：\ntldraw 小巧强大的在线绘图工具：\ncleverpdf 几十个强大的PDF在线工具，无需注册会员，永久免费：\nextractcss 提取 html 结构里面的 css 代码：\n帮小忙 腾讯出品的小工具合集，轻松办公，工具助你一臂之力，功能一应俱全、简单好用的线上工具宝：\nscribblediffusion.com 随便画一画，生成美观的图片\nchatpdf 和任何 PDF 进行沟通交流：\nchatdoc ChatDOC 让你可以和文档进行聊天沟通，它是一个基于 ChatGPT 的文件读取助手，它可以从 PDF 中快速提取、定位和总结信息：\nifixit 一个免费教授人们如何修理任何物品的网站：\nfusionbrain.ai 文字生成图片网站，效果和速度都还可以：\nonepdf 免费的 PDF 格式转换网站，支持PDF 转 Word 、PDF 转 Excel 、PDF 转 PPT 、PDF 转 JPG 、PDF 转 PNG 、Word 转 PDF 、Excel 转 PDF 、PPT 转 PDF 、JPG 转 PDF 、PNG 转 PDF 、CAD 转 PDF 功能：\ntgscan 免费开源的 Telegram 搜索：让你轻松找到频道、群组和聊天记录：\n纸砚双拼 一个好看的双拼学习网站\n123apps 网站提供了一系列的小工具，包含分类：\n视频工具 音频工具 PDF 工具 转换器 \u0026hellip;\u0026hellip;\nroadmap.sh 这是一个开源免费的项目，主要是提供了各种技术栈的学习路线：\nonemodel 为软件工程师量身定制的绘图工具，网站提供很多软件架构的图标、素材、模板：\ntranshumans 免费可商用的人物插图：\nAnyBT 种子搜索引擎，下载你想要的资源：\nstockai.trade AI 选股分析网站（基于 ChatGPT）完全免费，无需注册:\ntik.fail 国内能直接刷TikTok的在线网站，支持搜索和下载\n最佳平替 同一件商品，不同的搜索词，价格可能会天差地别。这个工具旨在帮助你找到最便宜的搜索词: 输入你想搜索的商品名，AI会给出低价的替代品，结果可能不准，开心就好：）\naiwallpaper AI 生成高清壁纸，项目开源在：all-in-aigc/aiwallpaper。\n开源代码包括：\nnextjs 全栈开发 API 和 Web dalle-3 绘图对接 aws s3 图片上传 postgres 数据读写 谷歌登录 stripe 非常适合参考学习，用来做一些小而美的 AI 应用。\n","date":"2024-03-28T13:28:01+08:00","permalink":"https://example.com/p/%E5%A5%BD%E4%B8%9C%E8%A5%BF%E5%93%A6/","title":"好东西哦！"},{"content":" 在搭建个人博客时，遇到了各种阴间问题，为此我删了起码七个库，都是泪，归根到底就是两个问题，一是主题配置，二是远程连接\nhugo（静态网站生成器） 其实不管什么东西，我都是建议先去看官方文档的，就像我师兄说的，你看别人教程就像别人消化后la给你，就像人体蜈蚣，哈哈哈，但是说实在，我也是过来人，有些东西确实需要别人指点一二，抛砖引玉，我写的博客一是为了自己复盘，二是想成为那个砖，帮助那些像我在学习时一样的朋友引出自己的玉，说多了\n总之，先给官方文档 https://www.gohugo.org/\n看的懂最好，看不懂，那就看看我的或别人的\n这一步可以参照网上很多人的文档，最推荐官方，下载链接如下： https://github.com/gohugoio/hugo/releases\n选择对应的压缩包版本，这里注意一下有extend的区别，我看了一下，extend只是多了一些可以自己操作的东西，新手还是建议老老实实的\n下载好压缩包之后，不论你是解压到哪里，都需要配置路径才能使用，因此一般推荐安装在除C盘之外的盘，例如我放在D盘中，新建一个文件夹Hugo，将解压的内容放进去，你可以看到最主要的其实就是一个.exe的二进制文件(意味着人家已经编译好了，我们直接拿来用就可以)，并将源文件夹的名字修改为bin\n解释一下，为什么要改文件夹名字？ 为了添加环境变量\n为什么文件夹的名字是bin？ “约定俗成”，二进制的英文是 binary ，取前三个字母，其实没有什么特殊的含义，你要高兴，取你自己的名字都行，只要把.exe文件添加进环境变量就行\n什么是环境变量？ emmmn，好问题，详细的无法解释，粗略一点，只有程序被添加到环境变量中后，才能被我们的操作系统识别并调用。\n如何添加环境变量？ 请善用搜索引擎，有很多写得超级详细\n以上信息是别人博主发的，我懒得写，哈哈\n生成站点 使用Hugo快速生成站点，比如希望生成到 /path/to/site 路径：\n在cmd输入哦\n$ hugo new site /path/to/site\n这样就在 /path/to/site 目录里生成了初始站点，进去目录：\n$ cd /path/to/site\n站点目录结构：\n▸ archetypes/ ▸ content/ ▸ layouts/ ▸ static/ config.toml\n在这个目录下，最主要的是对hugo.toml，themes/的配置。创建的所有.md文件都放置在content/文件下，所有文章的图片都放在static/下面\n创建文章 创建一个 about 页面\n$ hugo new about.md\nabout.md 自动生成到了 content/about.md ，打开 about.md 看下\n+++\rdate = \u0026quot;2015-10-25T08:36:54-07:00\u0026quot;\rdraft = true #这个东西是草稿的意思，我建议是你每发一篇博客都改为false，以后你每一篇博客都是每一篇文章\rtitle = \u0026quot;about\u0026quot;\r+++\r正文内容\n创建第一篇文章，放到 post 目录，方便之后生成聚合页面\n$ hugo new post/first.md\n安装皮肤 一个好看的主题是必要的，但是完全自己去写就太麻烦了，hugo中有很多精美的主题，比较方便的操作是在Hugo项目目录里面使用Git命令来克隆themes：你需要提供主题的 Git 仓库 URL。通常，主题的仓库 URL 可以在 Hugo Themes 官方网站或主题的文档中找到。\ngit clone https://github.com/author/theme-name.git themes/theme-name\n或者直接下载主题的压缩包，将其解压到themes/文件夹下，这样的话，就需要你对hugo.toml文件进行一点过的修改。\ngit的介绍可以看看官方文档或者我的博客也有，基本都是我从官方文档中学习的\n配置hugo.toml 好多教程里面直接就说会生成config.yml文件，但事实上新版的都是生成的hugo.toml，这不免让第一次配置的人感到迷惑，这两种的使用都是可以的，只是在语法结构上会有区别(类似于c++和python)，如果你想要完全自己手搓，按照你喜欢的语言就好，如果像我一样，只想点点鼠标，那就主要观察你下载的themes里面它使用的是什么，跟着用就行。\n例如，我下载的主题是PaperMod，其提供的范例里面用config.yml替代了hugo.toml，所以在使用时，可以直接将范例中的文件替代掉你创建的站点下的hugo.toml文件，并在里面进行一定的修改\n使用主题前最好看一下主题相应的配置教程，不同的主题是不一样，主题就是别人写好的网站的模板，而你就是去套用别人的模板。\ntheme = \u0026ldquo;my-theme\u0026rdquo; // my-theme是你下载的theme的主题名，要和你解压的文件名一致\n生成网站 需要注意的是，虽然我们做了这么多，但是在这个结构下(在 my-site这个结构下)，我们网站的页面实际上是还没有生成的，要想生成静态网站页面，必须运行如下命令\nhugo\n命令运行后，在上文提到my-site这个结构下会产生一个public/文件夹，里面保存生成的静态页面，后面将其在GitHub上面布置，实际上就是将public/中的内容远程推送到Github仓库中后进行展示。\nhugo server\n可以在本地预览你生成的网站，点击链接就可以在你本地的电脑看到自己搭建的网页的，但是这只是完成了一半，你需要将其托管到github page上，别人才能通过网址找到你的网站，github page是最简单且免费的方法，当然便宜的东西是有缺陷的，如果以后自己想深入，就需要买个域名和服务器了\n推送到GitHub 首先在GitHub上创建一个仓库，名字最好和你自己的名字一样，其实也无所谓，但是好多人都这么做，但是我不是\n在pubilc文件夹中创建仓库 记得cd 进入对应的文件夹\n其实远程连接在我的git博客上有详细的教程，这里我大概说一下\ngit init 初始化仓库 git add. 增加所有修改的意思 git commit -m \u0026ldquo;备注\u0026rdquo; 提交到远程仓库“备注随便写，你写我是傻逼都行”\n将两个仓库链接起来 这一步是最恶心我的，不知道为什么，不能用http链接，只能用ssh链接 大概就是你需要在你的电脑生成一个ssh链接，然后将其放到GitHub的配置上\n这步是参考别人的\n打开git bash命令窗口 生成ssh key ssh-keygen -t rsa -b 4096 -C \u0026ldquo;your_email@example.com\u0026rdquo;\nyour_email@example.com为github上你注册的email地址。\n然后直接三个enter不管他\n上面默认生成在用户主目录的.ssh目录下，可以自己输入自定义位置\n把ssh key添加到github 复制文件c/Users/Administrator/.ssh/id_rsa.pub内容，把key添加到：github \u0026gt; settings \u0026gt; SSH and GPG keys \u0026gt; New SSH key \u0026gt; 粘贴保存。\n测试SSH连接 $ ssh -T git@github.com\n如果成功的话你就可以通过SSH方式来clone及提交代码了\n// 创建一个分支 git branch -M main //使用 git remote add 命令将远程仓库添加到仓库配置中 git remote add origin https://github.com/your-username/your-repo.git //使用 SSH 连接后，可以使用 SSH URL 推送到 GitHub 仓库 git remote set-url origin git@github.com:your-username/your-repo.git //推送文件 git push -u origin main\n后续提交 //在站点中运行 hugo\n//进入public/文件夹下 cd public/\n//提交文件\ngit add .\ngit commit -m \u0026ldquo;备注\u0026rdquo; //推送到远程：在ssh已连接的情况下 git push -u origin main\n","date":"2024-03-27T13:28:01+08:00","permalink":"https://example.com/p/%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA%E5%91%80/","title":"个人博客搭建呀"},{"content":"\nWindow与Linux双系统安装与卸载Linux 如果你事先在window上安装的ubuntu,但是因为种种原因需要重装，那么你需要先卸载装在你电脑上的ubuntu系统才能安装新的Ubuntu\n重装unbuntu记得先保存好ubuntu想保存的文件\nUbuntu卸载 删除ubuntu所在卷 进入windows系统，右键此电脑-管理-磁盘管理-删除ubuntu所在的卷，使这些区域成为“可用空间”\n删除unbuntu EFI分区 Win + R 输入cmd打开终端，输入 diskpart 进入磁盘工具\n输入 list disk 查看磁盘，输入 select disk 1 （我的Ubuntu EFI分区在磁盘1，根据自己的情况选择）\n输入 list partition ，输入 select partition * （*为Ubuntu EFI分区号）\n删除Ubuntu系统启动项 Win + R 输入cmd打开终端，输入 diskpart 进入磁盘工具\n输入 list disk 查看磁盘，输入 select disk 1\n输入 list partition ，输入 select partition * （*为Windows EFI分区，一般为260M）\n输入 assign letter=J（分配盘符）\n管理员模式打开记事本，记事本选择文件-打开-选中磁盘J\n打开 EFI 文件夹，删除Ubuntu文件夹\n返回 Distpart 界面，输入 remove letter=J\n磁盘分区（如果你是第一次装Ubuntu） 1.打开计算机管理 2.找到磁盘管理 3.选择你要压缩的盘，你压缩掉的空间将作为新系统的空间 4.右键打开你要压缩的盘符，点击压缩卷 安装ubuntu系统 强烈建议安装最新lts版本，我写这篇博客时是22.04版 我就是因为第一次装的是18.04版所以才重装的，QAQ\n下载Linux镜像 1.下载 Ubuntu 镜像，这里可以去官方下载，但是官方在国外，默认外网链接可能网速有点小慢。（科技玩家例外） 更好的选择是国内的资源镜像网站，比如说清华大学开源软件镜像站\n清华大学开源软件镜像站 https://mirrors.tuna.tsinghua.edu.cn/\n准备u盘刻盘工具 我用的是UltralSO\n下载后打开，找到你下载的镜像文件，找到后，点击右上角的启动-\u0026gt;写入硬盘映像\n写入时记得插入u盘，这个u盘将作为启动盘 写入时，这个u盘的数据全会被格式化，谨慎操作\n然后点击写入就可以了\n开机引导界面 将写好的映像文件的U盘插入你需要的电脑，在开始时按f12，本人用的是联想，不同电脑可能不同，正常都是f12\n在引导界面可以看到几个选项，选择你的u盘作为启动项，反正不是window和network就是了\n启动后你会进入系统选择界面，使用方向键选择 ubuntu 后回车就进入了 Ubuntu 的安装引导界面。在侧边栏中选择系统语言，English、Chinese都可，看自己喜好，然后点击 Install Ubuntu 进入安装，选择安装方式，选择正常安装就行，会默认安装火狐浏览器等软件。或者选择最小安装的话可以在安装完成后自行安装需要的软件，两种方式影响不大。下面的安装第三方软件选项也可以选上，也可以不选，后面再根据需要手动安装。我这里就只选择了正常安装，然后点击继续，在安装类型选择时，建议自己手动分区，说一下分区情况吧，我找了大部分教程都是分为四个区：\n分区方案 /boot : 1G（最好） 主分区。系统的boot启动引导项安装位置\n/ : 随意（尽量大） 主分区。根目录，所有目录的根节点，其下包含很多子目录，如/usr /tmp等\n/home : 自定义（尽量大，一般最后分） 逻辑分区。一般放置自己的数据\nswap : 16G 逻辑分区。交换空间，一般是物理内存的1~2倍就行了\n具体操作，首先找到 free space 空间，如下，选中该空间，点击左下角的加号+，进行内存分配\n安装后-\u0026gt;选择地区（上海或香港都可以，我选的是上海）-\u0026gt;设置账户密码-\u0026gt;重启-\u0026gt;输入密码，ok\n我和同学在重启时都出现，黑屏跳一堆数据的情况，我们当时都很慌，但是我们最后强制关机重启后，发现没有大问题，起码我们没发现问题\n以后你每次开机时都可以选择windo和Linux之一的系统进行启动\n","date":"2024-03-26T18:28:01+08:00","permalink":"https://example.com/p/linux%E9%87%8D%E8%A3%85/","title":"Linux重装"},{"content":"\nroots.txt协议： 君子协议：规定了网站中的哪些数据可以被爬虫爬取，哪些不能碰\nhttp协议： 概念：就是服务器和客户端进行数据交互的一种形式\r常用请求头信息 user-agent:请求载体的身份标识\rconnection：请求完毕后，是断开连接还是保持连接\r常用响应头信息： content-type：服务器响应回客户端的数据类型\rhttps协议： 安全的超文本传输协议\r加密方式： 对称密钥加密\r非对称密钥加密\r证书密钥加密\rreques模块 python中原生的一款基于网络请求的模块，功能强大，简单便携，效率极高\r作用：模拟浏览器发请求\r如何使用： 指定URL\r发起请求\r获取响应数据\r数据解析\r持久化存储\r有些数据可能是动态请求加载出来的，不能通过url直接请求出来\n数据解析 ： 解析的局部的文本内容都会在标签之间或标签对应的属性中进行存储 1.进行指定标签的定位\r2.标签或者标签对应的属性中存储的数据值进行提取（解析）\r聚焦爬虫：爬取页面中指定的页面内容 正则 bs4 xpath\ntext(字符串) content(二进制) json()(对象)\nbs4进行数据解析 1.实例化一个BeautifulSoup对象，并将页面源码数据加载到该对象中\r2.通过调用BeautifulSoup对象中相关的属性或方法进行标签定位和数据提取\rxpath解析:最常用且便携高效的一种解析方式，通用性 -xpath解析原理：\r1.实例化一个etree的对象，且需要将被解析的页面源码数据加载到该对象中\r2.调用etree对象中的xpath方法结合着xpath表达式实现标签的定位和内容的捕获\r-环境安装\r-如何实例化一个etree对象：from lxml import etree\r1.将本地的html文档的源码数据加载到etree对象中：\retree.parse(filePath)\r2.可以将从互联网上获取的源码数据加载到该对象中：\retree.HTML('page_text')\r- xpath('xpath表达式')\r1./表示的是从根节点开始定位。表示的是一个层级\r2.//表示的是多个层级。可以表示从任意位置开始定位\r3.属性定位：//div[@class='song'] tag[@attrName=\u0026quot;attrValue\u0026quot;]\r4.索引定位：//div[@class='song']/p[3] 索引是从1开始的\r5.取文本：\r/text()获取的是标签中直系的文本内容\r//text()标签中非直系的文本内容\r6.取属性：\r/@attrName ==\u0026gt;img/src\r验证码识别 反爬机制：验证码。识别验证码图片中的数据，用于模拟登录操作\n识别验证码的操作： 人工肉眼识别 第三方自动识别\ncookie:用来让服务器端记录客户端的相关状态 1.手动处理：通过抓包工具获取cookie值，将值封装到headers中\r2.自动处理：\rcookie值来自登录post请求后，由服务器端创建\rsession会话对象：\r作用：\r1.可以进行请求的发送\r2.如果请求过程中产生了cookie，则该cookie会被自动存储/携带在该session对象中\r创建一个session对象：session=requests.Session()\r使用session对象进行模拟登录post请求的发送（cookie就会被存储在session中）\rsession对象对个人主页对应的get请求进行发送（携带了cookie）\r代理：破解封ip这种反爬机制 什么是代理：代理服务器\r代理的作用：\r突破自身ip访问的限制\r隐藏自身真实ip\r代理相关的网站：\r快代理\r西si代理\rwww.goubanjia.com\r代理ip的类型：\rhttp:应用到http协议对应的url中\rhttps：应用到https协议对应的url中\r代理ip的匿名度：\r透明：服务器知道该次请求使用了代理，也知道请求对应的真实ip\r匿名：服务器知道该次请求使用了代理，不知道请求对应的真实ip\r高匿：服务器不知道该次请求使用了代理，不知道请求对应的真实ip\r高性能异步爬虫 目的：在爬虫中使用异步实现高性能的数据爬取操作 异步爬虫的方式： 1.多线程，多进程（不推荐）\r好处：可以认为相关阻塞的操作单独开启线程或者进程，阻塞操作就可以异步执行\r弊端：无法无限制的开启多线程或者多进程\r2.线程池，进程池（适当的使用）\r好处：我们可以降低系统对进程或者线程创建和销毁的一个频率，从而很好的降低系统的开销\r弊端：池中线程或者进程的数量是有上限的\r3.单线程+异步协程（推荐）\revent_loop：事件循环：相当于一个无限循环，我们可以把一个函数注册到这个事件循环上，当满足某些条件时，函数就会被循环执行\rcoroutine:协程对象，我们可以将协程对象注册到事件循环中，它会被事件循环调用。我们可以使用async关键字来定义一个方法。这个方法在调用时不会被立即执行，而是返回一个协程对象。\rtask：任务，它是对协程对象的进一步封装，包含了任务的各个状态\rfuture：代表将来执行或还没被执行的任务，实际上和task没有本质区别\rasync:定义一个协程\rawait：用来挂起阻塞方法的执行\r在异步协程中如果出现了同步模块相关的代码，就无法实现异步 当在asyncio中遇到阻塞操作时必须进行手动挂起 异步模块中 text()文本 read()二进制 json()json对象 获取响应数据操作之前一定要使用await进行手动挂起\nselenium模块的基本使用 问题：selenium模块和爬虫之间具有怎样的关联 便携的获取网站中动态加载的数据 便携实现模拟登录\n什么是selenium模块 基于浏览器自动化的一个模块\nselenium使用流程： 环境安装 下载一个浏览器的驱动程序 实例化一个浏览器的映射关系 便携基于浏览器自动化的操作代码 发起请求:get(url) 标签定位:find系列方法 标签交互:send_keys(\u0026lsquo;xxx\u0026rsquo;) 执行js程序:excute_script(\u0026lsquo;jsCode\u0026rsquo;) 前进，后退:back(),forward() 关闭浏览器:quit()\nselenium处理iframe\r如果定位的标签存在于iframe标签之中的则必须进行标签定位，使用switch_to.frame(id)\r动作链(拖动)：from selenium.webdriver import ActionChains\r实例化一个动作链对象：action = ActionChains(bro)\rclick_and_hold(div):长按且点击操作\rmove_by_offset(x,y)\rperform()让动作链立即执行\raction.release()释放动作链对象\r无头浏览器 12306模拟登录 超级鹰：http://www..chaojiying.com/about.html\r注册：普通用户\r登录：普通用户\r提分查询：充值\r创建一个软件（id）\r下载示例代码\r12306模拟登录编码流程：\r使用selenium打开登录页面\r对当前selenium打开的这张页面进行截图\r对当前图片局部区域（验证码图片）进行裁剪\r好处：将验证吗图片和模拟登录进行一一对应\r使用超级鹰识别验证码图片（坐标）\rscrapy框架 什么是框架 就是一个集成了很多功能并且具有很强通用性的一个项目模板\n如何学习框架 专门学习框架封装的各种功能的详细用法\n什么是scrapy 爬虫中封装好的一个明星框架。功能：高性能的持久化存储，异步的数据下载，高性能的数据解析，分布式\n基本使用 环境的安装\r测试：在终端里录入scrapy指令，没有报错就是成功\r创建一个工程：scrapy startproject xxPro\rcd xxxPro\r在spiders子目录中创建一个爬虫文件\rscrapy genspider spiderName www.xxx.com\r执行工程\rscrapy crawl spiderName\rscrapy数据解析 基于终端指令：\r要求：只可以将prase方法的返回值存储到本地的文本文件中\r注意：持久化存储对应的文本文件的类型只可以是：\u0026quot;json,jsonlines,jl,csv,xml\r指令：scrapy crawl xxx -o filePath\r好处：简介高效便携\r缺点：局限性比较强（数据只可以存储到指定后缀的文本文件中）\r基于管道：\r编码流程：\r数据解析\r在item类中定义相关的属性\r将解析的数据封装存储到item类型的对象\r将item类型的对象提交给管道进行持久化存的操作\r在管道类的process_item中要将其接受到的item对象中存储的数据进行持久化存储操作\r在配置文件中开启管道\r好处：\r通用性强\rxpath返回的是列表，但是列表元素一定是Selector类型的对象 extract可以将Selector对象中data参数存储的字符串提取出来 列表调用了extract之后，则表示将列表中的每一个Selector对象中data对应的字符串提取出来\nprocess_item方法 专门用来出来item类型对象 该方法可以接收爬虫文件提交过来的item对象 该方法每接收到一个item就会被调用一次\nparse方法 用作于数据解析:response参数表示的就是请求成功后对应的响应对象\nyield item 将item提交给了管道\n管道文件中一个管道类对应将一组数据存储到一个平台或者载体中\n显示指定类型的日志信息 LOG_LEVEL = \u0026ldquo;ERROR\u0026rdquo;\n面试题：将爬取的数据一份存储到本地，一份存储到数据库，如何实现？ 管道文件中一个管道类对应的是将数据存储到一种平台 爬虫文件提交的item之后给管道文件中第一个别执行的管道类接收 process_item中的return item 表示将item传递给下一个即将被执行的管道类\n手动请求发送:callback回调函数是专门用作于数据解析\n基于Spider的全站数据爬取 就是将网站中某板块下的全部页码对应的页面数据进行爬取\r需求\r实现方式：\r将所有页面的url添加到start_urls列表（不建议）\r自动手动进行请求发送（推荐）\r手动请求发送:\ryield scrapy.Request(url,callback):callback专门用做于数据解析\r五大核心组件 引擎（Scrapy）\r用来处理整个系统的数据流处理，触发事务（框架核心）\r调度器（Scheduler）\r用来接受引擎发过来的请求，压入队列中，并在引擎再次请求的时候返回，可以想象为一个URL（抓取网页的网址或者说是链接）的优先队列，由他来决定下一个要抓取的网址是什么，同时去除重复的网址\r下载器（Downloader） 用于下载网页的内容，并将网页内容返回给蜘蛛(Scrapy下载器是建立在twisted这个高效的异步模型上的)\r爬虫（Spiders）\r爬虫是主要干活的，用于从特定的网页中提取自己需要的信息，即所谓的实体（Item）。用户也可以从中提取出链接，让Scrapy继续爬取下一个页面\r项目管道（Pipeline）\r负责处理爬虫从网页中抽取的实体，主要的功能是持久化实体，验证实体的有效性，清除不需要的信息，当页面被爬虫解析后，将被发送到项目管道，并经过几个特定的次序处理数据\r请求传参 使用场景：如果爬取解析的数据不在同一张页面上（深度爬取）\r需求\r图片数据爬取之ImagesPipeline 基于scrapy爬取字符串类型的数据和爬取图片类型的区别？\r字符串：只需要基于xpath进行解析且提交管道进行持久化存储\r图片：xpath解析出图片src的属性值，单独的对图片地址发起请求获取图片二进制类型的数据\rImagesPipeline:\r只需将img的src属性值进行解析，提交到管道，管道就会对图片的src进行请求发送获取图片的二进制\r需求\r使用流程:\r数据解析(图片的地址)\r将存储图片地址的item提交到制定的管道类\r在管道文件中自定制一个基于ImagePipeLine的一个管道类\rget_media_request\rfile_path\ritem_completed\r在配置文件中：\r指定图片存储的目录：IMAGES_STORE = './imgs_bobo'\r指定开启的管道：自定制的管道类\r中间件 下载中间件\r位置：引擎和下载器之间\r作用：批量拦截到整个工程中所有的请求和响应\r拦截请求：\rUA伪装:process_request\r代理IP:process_exception:return request\r拦截响应：\r篡改响应数据，响应对象\r需求：爬取网易新闻中的新闻数据（标题和内容）\r1.通过网页新闻的首页解析出五大板块对应的详情页的url（没有动态加载）\r2.每一个板块对应的新闻标题都是动态加载出来的（动态加载）\r3.通过解析出每一条新闻详情页的url获取详情页的页面源码，解析出新闻内容\rprocess_response 该方法拦截五大板块对应的响应对象，进行篡改\n链接提取器：根据制定规则（allow=\u0026ldquo;正则\u0026rdquo;）进行指定链接的提取 规则解析器：将链接提取器提取到的链接进行指定规则（callback）的解析的操作 follow=True :可以将链接提取器继续作用到连接提取器提取到的链接所对应的页面中\nCrawlSpider类：Spider的一个子类 全站数据爬取的方式 基于Spider：手动请求 基于CrawlSpider CrawlSpider的使用： 创建一个工程 cd xxx 创建爬虫文件（CrawlSpider）： scrapy genspider -t crawl xxx www.xxxx.com 链接提取器： 作用：根据指定的规则（allow）进行指定连接的提取 规则解析器 作用：将连接提取器提取到的连接进行指定规则（callback）的解析 需求：爬取sun网址中的编号，新闻标题，新闻内容，标号 分析:爬取的数据没有在同一张页面中 1.可以使用链接提取器提取所有的页码链接 2.让链接提取器提取所有的新闻详情页的链接\n分布式爬虫 概念：我们需要搭建一个分布式的机群，让其对一组资源进行分布联合爬取。\n作用：提升爬取数据的效率\n如何实现分布式? 安装一个scrapy-redis的组件 原生的scarapy是不可以实现分布式爬虫，必须要让scrapy结合着scrapy-redis组件一起实现分布式\n为什么原生的scrapy不可以实现分布式？ 调度器不可以被分布式机群共享 管道不可以被分布式机群共享\nscrapy-redis组件作用： 可以给原生的scrapy框架提供可以被共享的管道和调度器\n实现流程\n创建一个工程\r创建一个基于CrawlSpider的爬虫文件\r修改当前的爬虫文件：\r导包：from scrapy_redis.spiders importRedisCrawlSpiden\r将start_urls和allowed domains进行注释\r添加一个新属性：redis_key ='sun’可以被共享的调度器队列的名称\r编写数据解析相关的操作\r类的父类修改成RedjsCrawISpider\r修改配置文件settings\r指定使用可以被共享的管道：\rITEM_PIPELINES = {\r'scrapy_redis.pipelines.RedisPipeline'：400\r}\r指定调度器：\r增加了一个去重容器类的配置，作用使用Redis的set集合来存储请求的指纹数据。\rDUPEFILTER_CLASS=\u0026quot;scrapy_redis.dupefilter.RFPDupeFilter\u0026quot;\r使用scrapy-redis组件自己的调度器\rSCHEDULER =\u0026quot;scrapy redis.scheduler.Scheduler\u0026quot;\r配置调度器是否要持久化，也就是当爬虫结束了，要不要清空Redis中请求队列和去\rSCHEDULER_PERSIST =True\rredis相关操作配置：\r配置redis的配置文件：\rlinux或者mac:redis.conf\rwindows:redis.windows.conf\r代开配置文件修改：\r将bind 127.0.0.1进行删除\r关闭保护模式：protected-mode yes改为no\r结合着配置文件开启redis服务\rredis-server 配置文件\r启动客户端：\rredis-cli\r执行工程：\rscrapy runspiderXxx.py\r向调度器的队列中放入一个起始的url：\r调度器的队列在redis的客户端中\rlpushxxx www.xxx.com\r爬取到的数据存储在了redis的proName：item这个数据结构中\r增量式爬虫 概念：监测网站数据更新的情况，只会爬取网站最新更新出来的数据。\r分析：\r指定一个起始url\r基于CrawlSpider获取其他页码链接\r基于Rule将其他页码链接进行请求\r从每一个页码对应的页面源码中解析出每一个电影详情页的URL\r核心：检测电影详情页的url之前有没有请求过\r将爬取过的电影详情页的url存储\r存储到redis的set数据结构\r对详情页的url发起请求，然后解析出电影的名称和简介\r进行持久化存储\r","date":"2024-03-26T13:28:01+08:00","permalink":"https://example.com/p/%E7%88%AC%E8%99%AB%E5%AD%A6%E4%B9%A0plus/","title":"爬虫学习plus"},{"content":"爬虫基础 “可见即可爬~”\n爬虫概念 如果互联网是一张大的蜘蛛网，那一台计算机上的数据便是蜘蛛网上的一个猎物，而爬虫程序就是一只小蜘蛛，沿着蜘蛛网抓取自己想要的猎物/数据\n网络爬虫也叫网络蜘蛛，特指一类自动批量下载网络资源的程序 网络爬虫是伪装成客户端与服务端进行数据交互的程序\n爬虫的应用 1.数据采集 2.搜索引擎 3.模拟操作 4.软件测试 5.网络安全\n爬虫的分类（略） 爬虫的一般开发流程： 1.最简单的单一页面数据的爬取：\nurl-\u0026gt;发送请求，获取响应-\u0026gt;提取数据-\u0026gt;保存数据\n2.多页面数据的爬取\n发送请求，获取响应——\u0026gt;提取url地址，继续请求\n爬虫开发的重难点 1.数据的获取（反爬） 2.采集的速度\nHTTP和HTTPS 大多数商业应用采用的架构： 1.c/s client server 2.b/s broser(浏览器) server 3.m/s mobile server\n以上统称为客户端与服务端\nHTTP协议（超文本传输协议） 爬取想要的数据前，一定要明确其使用的是什么协议\nHTTP是基于TCP/IP通信协议来传输数据的\nTCP/IP通信的三次握手与四次挥手 三次握手建立连接 client:嘿，服务端girl！我想和你建立连接 server：好呀，嘻嘻 client：真好，那我们开始（数据）交互吧！\n（进行数据交互ing）\n四次挥手断开连接 client：我已经和你交互（数据）完了，我们断开连接吧! server：你确定要断开连接吗？ server：那你断开连接吧 client：欧克，那我断开连接了\nHTTP请求流程： 我们日常用浏览器搜索东西，输入的是URL,浏览器会将其自动转换为HTTP协议\n一次http请求的基本流程，有客户端向服务端发起一次请求（request），而服务器在接收到以后返回给客户端一个响应（response）.所以一次完成的http请求包含请求和响应两部分\n浏览器发送http请求的过程：\n1.域名解析\r2.发起TCP的3次握手\r3.建立TCP连接后发起HTTP请求\r4.服务器响应http请求，浏览器得到html代码\r5.浏览器解析html代码，并请求html代码中的资源（js，css，图片等）\r6.浏览器对页面进行渲染呈现给用户\rtip： 在网页的右键检查network-\u0026gt;name-\u0026gt;request headers view parsed下的connection:keep-alive保持常连接，就不用频繁三次握手和四次挥手了\n浏览器获取的内容（elements的内容）包含：url地址对应的响应+js+css+picture 爬虫会获取：url地址对应的响应\nurl（浏览器搜索框里的内容） 发送http请求时，通过url对网络资源进行定位\nurl：统一资源定位符。用来标识某一处资源的地址，也叫网址\n组成：协议+域名（端口默认80）+路径+参数 http协议的端口号默认为80可以不写，http协议的端口号默认为443可以不行，（域名可以确定时哪一台电脑，而端口号是为了确定是哪台电脑的哪一个应用）\n域名通常是IP地址的映射\nhttp请求格式 客户端发送一个HTTP请求到服务器的请求消息包括一下部分：请求行,请求头，空行和请求数据 请求方法 分类：\nOPTIONS\rPUT\rDELETE\rTRACE\rCONNECT\r常用方法是GET 和 POST\nGET:负责从服务器获取数据 POST:负责向服务器提交数据\n请求头 http请求正文 请求正文通常是使用POST请求中表单数据，而对于GET请求，请求体则为空\n在爬虫中，如果构造POST，需要正确的content-type，并了解各种请求库的各个参数设置时使用的是哪种content-type，不然可能会导致post提交后无法正常响应\nHTTP响应格式 由四个部分组成，分别是： 状态行（响应行） 消息报头 空行 响应正文\nhttp协议的特点 HTTP是无连接的 HTTP是媒体独立的 HTTP是无状态的\n保持http连接状态的技术是会话和Cookies\nhttps协议，安全版的HTTP http是基于tcp/ip协议的，而https是在http协议的基础之上，再加一层SSL/TLS协议，数据在传输过程中是加密的\nhttp是明文传输的而https是密文传输，所以较安全但性能低\n会话技术 会话在服务端，就是网站的服务器，用来保存用户的会话信息；cookies在客户端，也可以理解为浏览器端\nCookie 指某些网站为了辨别用户身份，进行session跟踪而存储在用户本地终端上的数据（通常经过加密）\nCookie可以理解为一个凭证 1.实际是由服务器发给客户端的特殊信息 2.这些信息以文本文件的方式存放在客户端 3.客户端每次向服务器发送请求的时候都会带上这些特殊信息 4.服务器在接收到Cookie以后，会验证cookie的信息，以此来辨别用户的身份\n爬虫为什么要使用cookie 好处： 能够访问登陆页面\r有一定的反爬作用\r坏处： 请求太频繁有可能被识别为爬虫\r一般使用多账号解决\rSession 一个浏览器窗口从打开到关闭这个期间\n在一个客户从打开浏览器到关闭浏览器这个期间，发起的所以请求都可以被识别为同一个用户，session是基于cookie的\n以上资料来自https://blog.csdn.net/qq_44907926/article/details/118585030\n作者大大真的牛逼，写的真好\n","date":"2024-03-21T13:28:01+08:00","permalink":"https://example.com/p/%E7%88%AC%E8%99%AB/","title":"爬虫"},{"content":"git 啊能镇楼\ngit配置 $ git config --global user.name \u0026quot;runoob\u0026quot;\r$ git config --global user.email test@runoob.com\r查看配置信息 $ git config --list\rgit工作流程 克隆git资源作为工作目录 在克隆的资源上添加或修改文件 如果其他人修改，你可以更新资源 在提交前查看修改 提交修改 在修改完成后，如果发现有错误，可以撤回提交并再次修改并提交 基本概念 工作区：就是你在电脑里能看到的目录 暂存区：英文叫stage或index，一般存放在 .git 目录下的index文件，所以我们把暂存区有时也叫作索引（index） 版本库：工作区有一个隐藏目录 .git，这个不算工作区，而是Git的版本库 图中左侧为工作区，右侧为版本库。在版本库中标记为“index”的区域是暂存区（stage/index）,标记为“master”的是master分支所代表的目录树 图中我们可以看出此时“HEAD”实际是指向master分支的一个“游标”。所以图示的命令中出现HEAD的地方是可以用master来替换的 图中的object标识的区域为git的对象库，实际位于“.git/objects”目录下，里面包含了创建的各种对象及内容 当对工作区修改（或新增）的文件执行git add命令时，暂存区的目录树被更新，同时工作区修改（或新增）的文件内容被写入到对象库中的一个新的对象中，而该对象的ID被记录在暂存区的文件索引中 当执行提交（git commit）时，暂存区的目录树写到版本库（对象库）中，master分支会相应的更新。即master指向的目录树就是提交时暂存区的目录树 当执行 git reset HEAD 操作时，暂存区的目录树会被重写，被master分支指向的目录树所替换，但是工作区不受影响 当执行 git rm \u0026ndash;cached 命令时，会直接从暂存区删除文件，工作区则不做出改变。 当执行 git checkout . 或者 git checkout \u0026ndash; 命令时，会用暂存区全部或指定的文件替换工作区的文件。这个操作很危险，会清除工作区中未添加到暂存区中的改动。 当执行 git checkout HEAD . 或者 git checkout HEAD 命令时，会用 HEAD 指向的 master 分支中的全部或者部分文件替换暂存区和以及工作区中的文件。这个命令也是极具危险性的，因为不但会清除工作区中未提交的改动，也会清除暂存区中未提交的改动 git 创建仓库 git init初始化一个仓库 Git 的很多命令都需要在 Git 的仓库中运行，所以 git init 是使用 Git 的第一个命令。 在执行完成 git init 命令后，Git 仓库会生成一个 .git 目录，该目录包含了资源的所有元数据，其他的项目目录保持不变。\ngit init newrepo使用我们指定目录作为Git仓库\n初始化后，会在 newrepo 目录下会出现一个名为 .git 的目录，所有 Git 需要的数据和资源都存放在这个目录中。\n如果当前目录下有几个文件想要纳入版本控制，需要先用 git add 命令告诉 Git 开始对这些文件进行跟踪，然后提交\n1 2 3 $ git add *.c $ git add README $ git commit -m \u0026#39;初始化项目版本\u0026#39; 以上命令将目录下以 .c 结尾及 README 文件提交到仓库中。\n注： 在 Linux 系统中，commit 信息使用单引号 \u0026lsquo;，Windows 系统，commit 信息使用双引号 \u0026ldquo;。所以在 git bash 中 git commit -m \u0026lsquo;提交说明\u0026rsquo; 这样是可以的，在 Windows 命令行中就要使用双引号 git commit -m \u0026ldquo;提交说明\u0026rdquo;\ngit clone 我们使用 git clone 从现有 Git 仓库中拷贝项目\n1 git clone \u0026lt;repo\u0026gt; 如果我们需要克隆到指定的目录，可以使用以下命令格式\n1 git clone \u0026lt;repo\u0026gt; \u0026lt;directory\u0026gt; 参数说明\nrepo：git仓库 directory：本地目录 比如，要克隆 Ruby 语言的 Git 代码仓库 Grit，可以用下面的命令：\n1 $ git clone git://github.com/schacon/grit.git 执行该命令后，会在当前目录下创建一个名为grit的目录，其中包含一个 .git 的目录，用于保存下载下来的所有版本记录。\n如果要自己定义要新建的项目目录名称，可以在上面的命令末尾指定新的名字：\n1 $ git clone git://github.com/schacon/grit.git mygrit git init 初始化仓库 git add . 添加文件到暂存区 git commit 将暂存区内容添加到仓库中 创建仓库命令 git 初始化仓库 git clone 拷贝一份远程仓库，也就是下载一个项目 提交与修改 git add 添加文件到暂存区 git status 查看仓库当前的状态，显示有变更的文件 git diff 比较文件的不同，即暂存区和工作区的差异 git commit 提交暂存区到本地仓库 git reset 回退版本 git rm 将文件从暂存区和工作区删除 git mv 移动或重命名工作区文件 git checkout 分支切换 git switch 更清晰地切换分支（2.3版本引入） git restore 恢复或撤销文件的更改 提交日志 git log 查看历史提交记录 git blame 以列表形式查看指定文件的历史修改记录 远程操作 git remote 远程仓库操作 git fetch 从远程获取代码库 git pull 下载远程代码并合并 git push 上传远程代码并合并 git分支管理 创建分支命令： git branch (branchname)\n切换分支命令 git checkout (branchname)\n当你切换分支的时候，git会用该分支的最后提交的快照替换你的工作目录的内容，以多个分支不需要多个目录。\n合并分支命令 git merge\n你可以多次合并到统一分支， 也可以选择在合并之后直接删除被并入的分支。\ngit 分支管理 列出分支 git branch 没有参数时，git branch 会列出你在本地的分支\n$ git branch\r* master\r此例的意思就是，我们有一个叫做 master 的分支，并且该分支是当前分支。\n当你执行 git init 的时候，默认情况下 Git 就会为你创建 master 分支。\n如果我们要手动创建一个分支。执行 git branch (branchname) 即可\n$ git branch testing\r$ git branch\r* master\rtesting\r现在我们可以看到，有了一个新分支 testing。\n当你以此方式在上次提交更新之后创建了新分支，如果后来又有更新提交， 然后又切换到了 testing 分支，Git 将还原你的工作目录到你创建分支时候的样子。\n接下来我们将演示如何切换分支，我们用 git checkout (branch) 切换到我们要修改的分支\n$ ls\rREADME\r$ echo 'runoob.com' \u0026gt; test.txt\r$ git add .\r$ git commit -m 'add test.txt'\r[master 3e92c19] add test.txt\r1 file changed, 1 insertion(+)\rcreate mode 100644 test.txt\r$ ls\rREADME test.txt\r$ git checkout testing\rSwitched to branch 'testing'\r$ ls\rREADME\r当我们切换到 testing 分支的时候，我们添加的新文件 test.txt 被移除了。切换回 master 分支的时候，它们又重新出现了。\n$ git checkout master\rSwitched to branch 'master'\r$ ls\rREADME test.txt\r我们也可以使用 git checkout -b (branchname) 命令来创建新分支并立即切换到该分支下，从而在该分支中操作。\n$ git checkout -b newtest\rSwitched to a new branch 'newtest'\r$ git rm test.txt rm 'test.txt'\r$ ls\rREADME\r$ touch runoob.php\r$ git add .\r$ git commit -am 'removed test.txt、add runoob.php'\r[newtest c1501a2] removed test.txt、add runoob.php\r2 files changed, 1 deletion(-)\rcreate mode 100644 runoob.php\rdelete mode 100644 test.txt\r$ ls\rREADME runoob.php\r$ git checkout master\rSwitched to branch 'master'\r$ ls\rREADME test.txt\r如你所见，我们创建了一个分支，在该分支上移除了一些文件 test.txt，并添加了 runoob.php 文件，然后切换回我们的主分支，删除的 test.txt 文件又回来了，且新增加的 runoob.php 不存在主分支中。\n使用分支将工作切分开来，从而让我们能够在不同开发环境中做事，并来回切换\n删除分支 git branch -d (branchname)\n例如我们要删除 testing 分支： $ git branch * master testing $ git branch -d testing Deleted branch testing (was 85fc7e7). $ git branch * master\n分支合并 一旦某分支有了独立内容，你终究会希望将它合并回到你的主分支。 你可以使用以下命令将任何分支合并到当前分支中去\ngit merge\n$ git branch\r* master\rnewtest\r$ ls\rREADME test.txt\r$ git merge newtest\rUpdating 3e92c19..c1501a2\rFast-forward\rrunoob.php | 0\rtest.txt | 1 -\r2 files changed, 1 deletion(-)\rcreate mode 100644 runoob.php\rdelete mode 100644 test.txt\r$ ls\rREADME runoob.php\r以上实例中我们将 newtest 分支合并到主分支去，test.txt 文件被删除。\n合并完后就可以删除分支\n$ git branch -d newtest\rDeleted branch newtest (was c1501a2).\r删除后， 就只剩下 master 分支了：\n$ git branch\r* master\r合并冲突 合并并不仅仅是简单的文件添加、移除的操作，Git 也会合并修改\n$ git branch\r* master\r$ cat runoob.php\r首先，我们创建一个叫做 change_site 的分支，切换过去，我们将 runoob.php 内容改为\n\u0026lt;?php\recho 'runoob';\r?\u0026gt;\r创建 change_site 分支：\n$ git checkout -b change_site\rSwitched to a new branch 'change_site'\r$ vim runoob.php\r$ head -3 runoob.php\r\u0026lt;?php\recho 'runoob';\r?\u0026gt;\r$ git commit -am 'changed the runoob.php'\r[change_site 7774248] changed the runoob.php\r1 file changed, 3 insertions(+)\r将修改的内容提交到 change_site 分支中。 现在，假如切换回 master 分支我们可以看内容恢复到我们修改前的(空文件，没有代码)，我们再次修改 runoob.php 文件。\n$ git checkout master\rSwitched to branch 'master'\r$ cat runoob.php\r$ vim runoob.php # 修改内容如下\r$ cat runoob.php\r\u0026lt;?php\recho 1;\r?\u0026gt;\r$ git diff\rdiff --git a/runoob.php b/runoob.php\rindex e69de29..ac60739 100644\r--- a/runoob.php\r+++ b/runoob.php\r@@ -0,0 +1,3 @@\r+\u0026lt;?php\r+echo 1;\r+?\u0026gt;\r$ git commit -am '修改代码'\r[master c68142b] 修改代码\r1 file changed, 3 insertions(+)\r现在这些改变已经记录到我的 \u0026ldquo;master\u0026rdquo; 分支了。接下来我们将 \u0026ldquo;change_site\u0026rdquo; 分支合并过来\n$ git merge change_site\rAuto-merging runoob.php\rCONFLICT (content): Merge conflict in runoob.php\rAutomatic merge failed; fix conflicts and then commit the result.\r$ cat runoob.php # 打开文件，看到冲突内容\r\u0026lt;?php\r\u0026lt;\u0026lt;\u0026lt;\u0026lt;\u0026lt;\u0026lt;\u0026lt; HEAD\recho 1;\r=======\recho 'runoob';\r\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt; change_site\r?\u0026gt;\r我们将前一个分支合并到 master 分支，一个合并冲突就出现了，接下来我们需要手动去修改它\n$ vim runoob.php $ cat runoob.php\r\u0026lt;?php\recho 1;\recho 'runoob';\r?\u0026gt;\r$ git diff\rdiff --cc runoob.php\rindex ac60739,b63d7d7..0000000\r--- a/runoob.php\r+++ b/runoob.php\r@@@ -1,3 -1,3 +1,4 @@@\r\u0026lt;?php\r+echo 1;\r+ echo 'runoob';\r?\u0026gt;\r在 Git 中，我们可以用 git add 要告诉 Git 文件冲突已经解决 $ git status -s UU runoob.php $ git add runoob.php $ git status -s M runoob.php $ git commit [master 88afe0e] Merge branch \u0026lsquo;change_site\u0026rsquo;\ngit查看提交历史 我们还可以用 \u0026ndash;graph 选项，查看历史中什么时候出现了分支、合并。以下为相同的命令，开启了拓扑图选项\nd5e9fc2 (HEAD -\u0026gt; master) Merge branch \u0026lsquo;change_site\u0026rsquo; |\\\n| * 7774248 (change_site) changed the runoob.php | c68142b 修改代码 |/ c1501a2 removed test.txt、add runoob.php 3e92c19 add test.txt 3b58100 第一次版本提交 现在我们可以更清楚明了地看到何时工作分叉、又何时归并。\n你也可以用 \u0026ndash;reverse 参数来逆向显示所有日志。\n$ git log --reverse --oneline\r3b58100 第一次版本提交\r3e92c19 add test.txt\rc1501a2 removed test.txt、add runoob.php\r7774248 (change_site) changed the runoob.php\rc68142b 修改代码\rd5e9fc2 (HEAD -\u0026gt; master) Merge branch 'change_site'\r如果只想查找指定用户的提交日志可以使用命令：git log \u0026ndash;author , 例如，比方说我们要找 Git 源码中 Linus 提交的部分\n$ git log --author=Linus --oneline -5\r81b50f3 Move 'builtin-*' into a 'builtin/' subdirectory\r3bb7256 make \u0026quot;index-pack\u0026quot; a built-in\r377d027 make \u0026quot;git pack-redundant\u0026quot; a built-in\rb532581 make \u0026quot;git unpack-file\u0026quot; a built-in\r112dd51 make \u0026quot;mktag\u0026quot; a built-in\r如果你要指定日期，可以执行几个选项：\u0026ndash;since 和 \u0026ndash;before，但是你也可以用 \u0026ndash;until 和 \u0026ndash;after。\n例如，如果我要看 Git 项目中三周前且在四月十八日之后的所有提交，我可以执行这个（我还用了 \u0026ndash;no-merges 选项以隐藏合并提交）\n$ git log --oneline --before={3.weeks.ago} --after={2010-04-18} --no-merges\r5469e2d Git 1.7.1-rc2\rd43427d Documentation/remote-helpers: Fix typos and improve language\r272a36b Fixup: Second argument may be any arbitrary string\rb6c8d2d Documentation/remote-helpers: Add invocation section\r5ce4f4e Documentation/urls: Rewrite to accomodate transport::address\r00b84e9 Documentation/remote-helpers: Rewrite description\r03aa87e Documentation: Describe other situations where -z affects git diff\r77bc694 rebase-interactive: silence warning when no commits rewritten\r636db2c t3301: add tests to use --format=\u0026quot;%N\u0026quot;\r更多 git log 命令可查看 http://git-scm.com/docs/git-log 或使用 git log \u0026ndash;help 命令查看帮助信息。\ngit blame git blame 命令用于逐行显示指定文件的每一行代码是由谁在什么时候引入或修改的。\nstrong\u0026gt;git blame 可以追踪文件中每一行的变更历史，包括作者、提交哈希、提交日期和提交消息等信息。\n如果要查看指定文件的修改记录可以使用 git blame 命令，格式如下\ngit blame [选项] \u0026lt;文件路径\u0026gt;\ngit标签 如果你达到一个重要的阶段，并希望永远记住那个特别的提交快照，你可以使用 git tag 给它打上标签。\n比如说，我们想为我们的 runoob 项目发布一个\u0026quot;1.0\u0026quot;版本。 我们可以用 git tag -a v1.0 命令给最新一次提交打上（HEAD）\u0026ldquo;v1.0\u0026quot;的标签。\n-a 选项意为\u0026quot;创建一个带注解的标签\u0026rdquo;。 不用 -a 选项也可以执行的，但它不会记录这标签是啥时候打的，谁打的，也不会让你添加个标签的注解。 我推荐一直创建带注解的标签。\n$ git tag -a v1.0\n当你执行 git tag -a 命令时，Git 会打开你的编辑器，让你写一句标签注解，就像你给提交写注解一样。\n现在，注意当我们执行 git log \u0026ndash;decorate 时，我们可以看到我们的标签了\nd5e9fc2 (HEAD -\u0026gt; master) Merge branch \u0026lsquo;change_site\u0026rsquo; |\\\n| * 7774248 (change_site) changed the runoob.php | c68142b 修改代码 |/ c1501a2 removed test.txt、add runoob.php 3e92c19 add test.txt 3b58100 第一次版本提交 如果我们忘了给某个提交打标签，又将它发布了，我们可以给它追加标签。\n例如，假设我们发布了提交 85fc7e7(上面实例最后一行)，但是那时候忘了给它打标签。 我们现在也可以\n$ git tag -a v0.9 85fc7e7\r$ git log --oneline --decorate --graph\r* d5e9fc2 (HEAD -\u0026gt; master) Merge branch 'change_site'\r|\\ | * 7774248 (change_site) changed the runoob.php\r* | c68142b 修改代码\r|/ * c1501a2 removed test.txt、add runoob.php\r* 3e92c19 add test.txt\r* 3b58100 (tag: v0.9) 第一次版本提交\r如果我们要查看所有标签可以使用以下命令\n$ git tag\rv0.9\rv1.0\r指定标签信息命令： git tag -a -m \u0026ldquo;runoob.com标签\u0026rdquo;\nPGP签名标签命令 git tag -s -m \u0026ldquo;runoob.com标签\u0026rdquo;\ngit远程仓库（github） 添加远程库 要添加一个新的远程仓库，可以指定一个简单的名字，以便将来引用,命令格式如下\ngit remote add [shortname] [url]\n本例以 Github 为例作为远程仓库，如果你没有 Github 可以在官网 https://github.com/注册。\n由于你的本地 Git 仓库和 GitHub 仓库之间的传输是通过SSH加密的，所以我们需要配置验证信息：\n使用以下命令生成 SSH Key：\n后面的 your_email@youremail.com 改为你在 Github 上注册的邮箱，之后会要求确认路径和输入密码，我们这使用默认的一路回车就行。\n成功的话会在 ~/ 下生成 .ssh 文件夹，进去，打开 id_rsa.pub，复制里面的 key。\n$ ssh-keygen -t rsa -C \u0026quot;429240967@qq.com\u0026quot;\rGenerating public/private rsa key pair.\rEnter file in which to save the key (/Users/tianqixin/.ssh/id_rsa): Enter passphrase (empty for no passphrase): # 直接回车\rEnter same passphrase again: # 直接回车\rYour identification has been saved in /Users/tianqixin/.ssh/id_rsa.\rYour public key has been saved in /Users/tianqixin/.ssh/id_rsa.pub.\rThe key fingerprint is:\rSHA256:MDKVidPTDXIQoJwoqUmI4LBAsg5XByBlrOEzkxrwARI 429240967@qq.com\rThe key's randomart image is:\r+---[RSA 3072]----+\r|E*+.+=**oo |\r|%Oo+oo=o. . |\r|%**.o.o. |\r|OO. o o |\r|+o+ S |\r|. |\r| |\r| |\r| |\r+----[SHA256]-----+\r回到 github 上，进入 Account =\u0026gt; Settings（账户配置）\n左边选择 SSH and GPG keys，然后点击 New SSH key 按钮,title 设置标题，可以随便填，粘贴在你电脑上生成的 key。\n为了验证是否成功，输入以下命令：\n$ ssh -T git@github.com\rThe authenticity of host 'github.com (52.74.223.119)' can't be established.\rRSA key fingerprint is SHA256:nThbg6kXUpJWGl7E1IGOCspRomTxdCARLviKw6E5SY8.\rAre you sure you want to continue connecting (yes/no/[fingerprint])? yes # 输入 yes\rWarning: Permanently added 'github.com,52.74.223.119' (RSA) to the list of known hosts.\rHi tianqixin! You've successfully authenticated, but GitHub does not provide shell access. # 成功信息\r以下命令说明我们已成功连上 Github。\n之后登录后点击\u0026rdquo; New repository \u0026quot;\n之后在在Repository name 填入 runoob-git-test(远程仓库名) ，其他保持默认设置，点击\u0026quot;Create repository\u0026quot;按钮，就成功地创建了一个新的Git仓库\n查看当前的远程库 git remote\n$ git remote\rorigin\r$ git remote -v\rorigin git@github.com:tianqixin/runoob-git-test.git (fetch)\rorigin git@github.com:tianqixin/runoob-git-test.git (push)\r提取远程仓库 Git 有两个命令用来提取远程仓库的更新。\n1、从远程仓库下载新分支与数据\ngit fetch\n该命令执行完后需要执行 git merge 远程分支到你所在的分支。\n2、从远端仓库提取数据并尝试合并到当前分支：\ngit merge\n该命令就是在执行 git fetch 之后紧接着执行 git merge 远程分支到你所在的任意分支\n推送到远程仓库 推送你的新分支与数据到某个远端仓库命令:\ngit push [alias] [branch]\n以上命令将你的 [branch] 分支推送成为 [alias] 远程仓库上的 [branch] 分支，实例如下。\n$ touch runoob-test.txt # 添加文件 $ git add runoob-test.txt $ git commit -m \u0026ldquo;添加到远程\u0026rdquo; master 69e702d] 添加到远程 1 file changed, 0 insertions(+), 0 deletions(-) create mode 100644 runoob-test.txt\n$ git push origin master # 推送到 Github\n删除远程仓库 git remote rm [别名]\ngit服务其搭建（暂时不搞） 以上文档资料来自菜鸟教程，本人只是学习并总结借鉴\n最后,德狗镇楼 ","date":"2024-03-19T13:35:01+08:00","permalink":"https://example.com/p/git/","title":"git"},{"content":"这是我在学习蛇书时的学习笔记，写这篇博客一是为了自己以后复盘，二是顺便分享一下，本人写这篇文章时才大二，写的不是很好，但是我就是不改，嘿嘿~~ 白金镇楼 Python和markdown使用方法 markdown基础使用方法 标题前面加井号\n回车不能换行，只是将文字加个空格，想要换行需要在上一行后面加两个空格再回车\n想要在新起一段，则打两个回车\nctrl+i ：斜体 ctrl+b ：加粗\n列表:\n鸡翅 1.汉堡 2.可乐\n插入图片： ctrl+alt+v\n数学公式：以“\\”起始 行内展示数学公式：ctrl+m 另起一段展示数学公式，上面连按两下\n表格：第一行是表头以“|”分列，第二行是对齐方式，“-”表示默认即左对齐，在“—”左侧加“：”为左对齐，两边加为居中对齐,冒号一定要用英文 alt+shift+f可格式话文本编排\n链接：复制链接直接cv 直接黏贴则直接生成可点击的链接 选中文字黏贴则生成可点击的文字按钮链接，选中文字黏贴则生成可点击的文字按钮链接\n代码块:\n1 2 int a a = 100 指定语言可高亮\n1 2 int a a = 100 分割线 在所需添加分割线的文本下新起一行输入三个减号“\u0026mdash;” 阿巴阿巴阿巴阿巴\n引用 在引用的2文字前加上大于号“\u0026gt;”\n聪明的愚者\n流程图（略）\nmd文件导出为其他文件\n##Python编程：从入门到实践\n###字符串 name.title() name.upper() name.lower()\nf字符串\n1 2 3 4 first_name = \u0026#34;ada\u0026#34; last_name = \u0026#34;lovelace\u0026#34; fulll_name = f\u0026#34;{first_name} {last_name}\u0026#34; message = f\u0026#34;Hello,{full_name.title()}!\u0026#34; 删除空白 ❶ \u0026raquo;\u0026gt; favorite_language = \u0026rsquo; python \u0026rsquo; ❷ \u0026raquo;\u0026gt; favorite_language.rstrip() \u0026rsquo; python\u0026rsquo; ❸ \u0026raquo;\u0026gt; favorite_language.lstrip() \u0026lsquo;python \u0026rsquo; ❹ \u0026raquo;\u0026gt; favorite_language.strip() \u0026lsquo;python\u0026rsquo;\n删除前缀\nnostarch_url = \u0026lsquo;https://nostarch.com\u0026rsquo; nostarch_url.removeprefix(\u0026lsquo;https://\u0026rsquo;) \u0026rsquo;nostarch.com\u0026rsquo;\n常量 常量（constant）是在程序的整个⽣命周期内都保持不变的变量。Python 没 有内置的常量类型，但 Python 程序员会使⽤全⼤写字⺟来指出应将某个变 量视为常量，其值应始终不变\n列表 append追加 insert插入 del pop()弹栈，可加索引 remove()根据值删除元素 sort()对列表永久排序 car.sort(reverse=True) sorted()临时排序 reverse() len()\n使用range()创建数值列表 numbers = list(range(1,6))\n列表推导式 squares = [value**2 for value in range(1,11)]\n切片 players[0:3]\n复制列表 players[:]\n元组 列表⾮常适合⽤于存储在程序运⾏期间可能变化的数据集。列表是可以修 改的，这对于处理⽹站的⽤户列表或游戏中的⾓⾊列表⾄关重要。然⽽， 你有时候需要创建⼀系列不可修改的元素，元组可满⾜这种需求。Python 将不能修改的值称为不可变的，⽽不可变的列表称为元组（tuple）。\n1 2 3 4 5 6 7 requested_toppings = [] if requested_toppings: for requested_topping in requested_toppings: print(f\u0026#34;Adding {requested_topping}.\u0026#34;) print(\u0026#34;\\nFinished making your pizza!\u0026#34;) else: print(\u0026#34;Are you sure you want a plain pizza?\u0026#34;) 使用多个列表\n1 2 3 4 5 6 7 8 available_toppings = [\u0026#39;mushrooms\u0026#39;, \u0026#39;olives\u0026#39;, \u0026#39;green peppers\u0026#39;,\u0026#39;pepperoni\u0026#39;, \u0026#39;pineapple\u0026#39;, \u0026#39;extra cheese\u0026#39;] requested_toppings = [\u0026#39;mushrooms\u0026#39;, \u0026#39;french fries\u0026#39;, \u0026#39;extra cheese\u0026#39;] for requested_topping in requested_toppings: if requested_topping in available_toppings: print(f\u0026#34;Adding {requested_topping}.\u0026#34;) else: print(f\u0026#34;Sorry, we don\u0026#39;t have {requested_topping}.\u0026#34;) print(\u0026#34;\\nFinished making your pizza!\u0026#34;) 一个简单的字典\n1 2 3 4 5 6 7 8 alien_0 = {\u0026#39;color\u0026#39;：\u0026#39;green\u0026#39;,\u0026#39;point\u0026#39;:5} print(alien_0[\u0026#39;color\u0026#39;]) print(alien_0[\u0026#39;points\u0026#39;]) #添加键值对 alien_0[\u0026#39;x_position\u0026#39;] = 0 alien_0[\u0026#39;y_position\u0026#39;] = 25 #删除键值对 del 由类似的对象组成的字典\n1 2 3 4 5 6 favorite_languages = { \u0026#39;jen\u0026#39;: \u0026#39;python\u0026#39;, \u0026#39;sarah\u0026#39;: \u0026#39;c\u0026#39;, \u0026#39;edward\u0026#39;: \u0026#39;rust\u0026#39;, \u0026#39;phil\u0026#39;: \u0026#39;python\u0026#39;, } 可使⽤ get() ⽅法在指定的键不存在时返回⼀个默认值。get() ⽅ 法的第⼀个参数⽤于指定键，是必不可少的；第⼆个参数为当指定的键不 存在时要返回的值，是可选的：\n遍历字典的所有键值对\n1 2 3 4 5 6 7 8 9 user_0 = { \u0026#39;username\u0026#39;: \u0026#39;efermi\u0026#39;, \u0026#39;first\u0026#39;: \u0026#39;enrico\u0026#39;, \u0026#39;last\u0026#39;: \u0026#39;fermi\u0026#39;, } for key,value in user_0.items(): print(f\u0026#34;\\nKey:{key}) print(f\u0026#34;value:{value}\u0026#34;) 遍历字典中的所有键 keys()\n1 2 3 4 5 6 7 8 favorite_languages = { \u0026#39;jen\u0026#39;: \u0026#39;python\u0026#39;, \u0026#39;sarah\u0026#39;: \u0026#39;c\u0026#39;, \u0026#39;edward\u0026#39;: \u0026#39;rust\u0026#39;, \u0026#39;phil\u0026#39;: \u0026#39;python\u0026#39;, } for name in favorite_languages.keys(): print(name.title()) 遍历字典时，默认遍历所有的键\n遍历字典中的所有值，values()\n1 for language in set(favorite_languages.values()): 用set剔除重复项\n嵌套\n1 2 3 4 5 6 alien_0 = {\u0026#39;color\u0026#39;: \u0026#39;green\u0026#39;, \u0026#39;points\u0026#39;: 5} alien_1 = {\u0026#39;color\u0026#39;: \u0026#39;yellow\u0026#39;, \u0026#39;points\u0026#39;: 10} alien_2 = {\u0026#39;color\u0026#39;: \u0026#39;red\u0026#39;, \u0026#39;points\u0026#39;: 15} aliens = [alien_0, alien_1, alien_2] for alien in aliens: print(alien) 字典列表\n1 2 3 4 5 6 7 8 9 10 11 12 # 创建⼀个⽤于存储外星⼈的空列表 aliens = [] # 创建 30 个绿⾊的外星⼈ for alien_number in range(30): new_alien = {\u0026#39;color\u0026#39;: \u0026#39;green\u0026#39;, \u0026#39;points\u0026#39;: 5, \u0026#39;speed\u0026#39;: \u0026#39;slow\u0026#39;} aliens.append(new_alien) # 显⽰前 5 个外星⼈ for alien in aliens[:5]: print(alien) print(\u0026#34;...\u0026#34;) # 显⽰创建了多少个外星⼈ print(f\u0026#34;Total number of aliens: {len(aliens)}\u0026#34;) 在字典中存储列表\n1 2 3 4 5 6 7 8 9 # 存储顾客所点⽐萨的信息 pizza = { \u0026#39;crust\u0026#39;: \u0026#39;thick\u0026#39;, \u0026#39;toppings\u0026#39;: [\u0026#39;mushrooms\u0026#39;, \u0026#39;extra cheese\u0026#39;], } # 概述顾客点的⽐萨 print(f\u0026#34;You ordered a {pizza[\u0026#39;crust\u0026#39;]}-crust pizza \u0026#34; \u0026#34;with the following toppings:\u0026#34;) for topping in pizza[\u0026#39;toppings\u0026#39;]: print(f\u0026#34;\\t{topping}\u0026#34;) 在字典中存储字典\ninput()解读为字符串 int()获取数值输入\nfor 循环是⼀种遍历列表的有效⽅式，但不应该在 for 循环中修改列表， 否则将导致 Python 难以跟踪其中的元素。要在遍历列表的同时修改它，可 使⽤ while 循环。通过将 while 循环与列表和字典结合起来使⽤，可收 集、存储并组织⼤量的输⼊，供以后查看和使⽤。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 # ⾸先，创建⼀个待验证⽤户列表 # 和⼀个⽤于存储已验证⽤户的空列表 unconfirmed_users = [\u0026#39;alice\u0026#39;, \u0026#39;brian\u0026#39;, \u0026#39;candace\u0026#39;] confirmed_users = [] # 验证每个⽤户，直到没有未验证⽤户为⽌ # 将每个经过验证的⽤户都移到已验证⽤户列表中 while unconfirmed_users: current_user = unconfirmed_users.pop() print(f\u0026#34;Verifying user: {current_user.title()}\u0026#34;) confirmed_users.append(current_user) # 显⽰所有的已验证⽤户 print(\u0026#34;\\nThe following users have been confirmed:\u0026#34;) for confirmed_user in confirmed_users: print(confirmed_user.title()) 删除为特定值的所有列表元素\n1 2 3 4 5 pets = [\u0026#39;dog\u0026#39;, \u0026#39;cat\u0026#39;, \u0026#39;dog\u0026#39;, \u0026#39;goldfish\u0026#39;, \u0026#39;cat\u0026#39;, \u0026#39;rabbit\u0026#39;, \u0026#39;cat\u0026#39;] print(pets) while \u0026#39;cat\u0026#39; in pets: pets.remove(\u0026#39;cat\u0026#39;) print(pets) 使用用户输入填充字典\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 responses = {} # 设置⼀个标志，指出调查是否继续 polling_active = True while polling_active: # 提⽰输⼊被调查者的名字和回答 name = input(\u0026#34;\\nWhat is your name? \u0026#34;) response = input(\u0026#34;Which mountain would you like to climb someday?\u0026#34;) # 将回答存储在字典中 responses[name] = response # 看看是否还有⼈要参与调查 repeat = input(\u0026#34;Would you like to let another person respond?(yes/no) \u0026#34;) if repeat == \u0026#39;no\u0026#39;: polling_active = False # 调查结束，显⽰结果 print(\u0026#34;\\n--- Poll Results ---\u0026#34;) for name, response in responses.items(): print(f\u0026#34;{name} would like to climb {response}.\u0026#34;) 函数 \u0026ldquo;\u0026ldquo;\u0026ldquo;文档字符串\u0026rdquo;\u0026rdquo;\u0026rdquo; 位置实参\n关键字实参\n1 2 3 4 5 6 def describe_pet(animal_type, pet_name): \u0026#34;\u0026#34;\u0026#34;显⽰宠物的信息\u0026#34;\u0026#34;\u0026#34; print(f\u0026#34;\\nI have a {animal_type}.\u0026#34;) print(f\u0026#34;My {animal_type}\u0026#39;s name is {pet_name.title()}.\u0026#34;) describe_pet(animal_type=\u0026#39;hamster\u0026#39;, pet_name=\u0026#39;harry\u0026#39;) 默认值\n让实参变成可选的 为让中间名变成可选的，可给形参 middle_name 指 定默认值（空字符串），在⽤户不提供中间名时不使⽤这个形参。为了让 get_formatted_name() 在没有提供中间名时依然正确运⾏，可给形参 middle_name 指定默认值（空字符串），并将其移到形参列表的末尾 middle_name=\u0026rsquo;\u0026rsquo;\n返回字典\n传递列表\n1 2 3 4 5 6 7 8 def greet_users(names): \u0026#34;\u0026#34;\u0026#34;向列表中的每个⽤户发出简单的问候\u0026#34;\u0026#34;\u0026#34; for name in names: msg = f\u0026#34;Hello, {name.title()}!\u0026#34; print(msg) usernames = [\u0026#39;hannah\u0026#39;, \u0026#39;ty\u0026#39;, \u0026#39;margot\u0026#39;] greet_users(usernames) 传递任意数量的实参\n1 2 3 4 5 6 def make_pizza(*toppings): \u0026#34;\u0026#34;\u0026#34;打印顾客点的所有配料\u0026#34;\u0026#34;\u0026#34; print(toppings) make_pizza(\u0026#39;pepperoni\u0026#39;) make_pizza(\u0026#39;mushrooms\u0026#39;, \u0026#39;green peppers\u0026#39;, \u0026#39;extra cheese\u0026#39;) 形参名 *toppings 中的星号让 Python 创建⼀个名为 toppings 的元组， 该元组包含函数收到的所有值。函数体内的函数调⽤ print() ⽣成的输出 证明，Python 既能处理使⽤⼀个值调⽤函数的情形，也能处理使⽤三个值 调⽤函数的情形。它以类似的⽅式处理不同的调⽤。注意，Python 会将实 参封装到⼀个元组中，即便函数只收到⼀个值也是如此\n使⽤任意数量的关键字实参\n1 2 3 4 5 6 7 def build_profile(first, last, **user_info): \u0026#34;\u0026#34;\u0026#34;创建⼀个字典，其中包含我们知道的有关⽤户的⼀切\u0026#34;\u0026#34;\u0026#34; user_info[\u0026#39;first_name\u0026#39;] = first user_info[\u0026#39;last_name\u0026#39;] = last return user_info user_profile = build_profile(\u0026#39;albert\u0026#39;, \u0026#39;einstein\u0026#39;,location=\u0026#39;princeton\u0026#39;,field=\u0026#39;physics\u0026#39;) print(user_profile) build_profile() 函数的定义要求提供名和姓，同时允许根据需要提供 任意数量的名值对。形参 **user_info 中的两个星号让 Python 创建⼀个 名为 user_info 的字典，该字典包含函数收到的其他所有名值对。在这 个函数中，可以像访问其他字典那样访问 user_info 中的名值对。\n将函数存储在模块中 使⽤函数的优点之⼀是可将代码块与主程序分离。通过给函数指定描述性 名称，能让程序容易理解得多。你还可以更进⼀步，将函数存储在称为模 块的独⽴⽂件中，再将模块导⼊（import）主程序。import 语句可让你在 当前运⾏的程序⽂件中使⽤模块中的代码。\n导⼊特定的函数\n使⽤ as 给函数指定别名\n函数编写指南 在编写函数时，需要牢记⼏个细节。应给函数指定描述性名称，且只使⽤ ⼩写字⺟和下划线。描述性名称可帮助你和别⼈明⽩代码想要做什么。在 给模块命名时也应遵循上述约定。 在给形参指定默认值时，等号两边不要有空格\n面向对象编程：类\n创建Dog类\n1 2 3 4 5 6 7 8 9 10 11 12 class Dog: \u0026#34;\u0026#34;\u0026#34;⼀次模拟⼩狗的简单尝试\u0026#34;\u0026#34;\u0026#34; def __init__(self, name, age): \u0026#34;\u0026#34;\u0026#34;初始化属性 name 和 age\u0026#34;\u0026#34;\u0026#34; self.name = name self.age = age def sit(self): \u0026#34;\u0026#34;\u0026#34;模拟⼩狗收到命令时坐下\u0026#34;\u0026#34;\u0026#34; print(f\u0026#34;{self.name} is now sitting.\u0026#34;) def roll_over(self): \u0026#34;\u0026#34;\u0026#34;模拟⼩狗收到命令时打滚\u0026#34;\u0026#34;\u0026#34; print(f\u0026#34;{self.name} rolled over!\u0026#34;) init() ⽅法:是⼀个特殊⽅法，每当你根据 Dog 类创建新实例时，Python 都会⾃动运⾏ 它。在这个⽅法的名称中，开头和末尾各有两个下划线，这是⼀种约定， 旨在避免 Python 默认⽅法与普通⽅法发⽣名称冲突。务必确保 init() 的两边都有两个下划线，否则当你使⽤类来创建实例时，将 不会⾃动调⽤这个⽅法，进⽽引发难以发现的错误。 我们将 init() ⽅法定义成包含三个形参：self、name 和 age。在 这个⽅法的定义中，形参 self 必不可少，⽽且必须位于其他形参的前 ⾯。为何必须在⽅法定义中包含形参 self 呢？因为当 Python 调⽤这个⽅ 法来创建 Dog 实例时，将⾃动传⼊实参 self。每个与实例相关联的⽅法 调⽤都会⾃动传递实参 self，该实参是⼀个指向实例本⾝的引⽤，让实例 能够访问类中的属性和⽅法。 在 init() ⽅法内定义的两个变量都有前缀 self（⻅❸）。以self 为前缀的变量可供类中的所有⽅法使⽤，可以通过类的任意实例来访问。 self.name = name 获取与形参 name 相关联的值，并将其赋给变量 name，然后该变量被关联到当前创建的实例。self.age = age 的作⽤ 与此类似。像这样可通过实例访问的变量称为属性（attribute）。\n根据类创建实例\n1 2 3 my_dog = Dog(\u0026#39;Willie\u0026#39;, 6) print(f\u0026#34;My dog\u0026#39;s name is {my_dog.name}.\u0026#34;) print(f\u0026#34;My dog is {my_dog.age} years old.\u0026#34;) 给属性指定默认值 有些属性⽆须通过形参来定义，可以在 init() ⽅法中为其指定默认 值。 下⾯来添加⼀个名为 odometer_reading 的属性，其初始值总是为 0。我 们还添加了⼀个名为 read_odometer() 的⽅法，⽤于读取汽⻋的⾥程 表\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 class Car: def __init__(self, make, model, year): \u0026#34;\u0026#34;\u0026#34;初始化描述汽⻋的属性\u0026#34;\u0026#34;\u0026#34; self.make = make self.model = model self.year = year self.odometer_reading = 0 def get_descriptive_name(self): --snip-- ❷ def read_odometer(self): \u0026#34;\u0026#34;\u0026#34;打印⼀条指出汽⻋⾏驶⾥程的消息\u0026#34;\u0026#34;\u0026#34; print(f\u0026#34;This car has {self.odometer_reading} miles on it.\u0026#34;) my_new_car = Car(\u0026#39;audi\u0026#39;, \u0026#39;a4\u0026#39;, 2024) print(my_new_car.get_descriptive_name()) my_new_car.read_odometer() 修改属性的值\n1.直接修改属性的值 2.通过方法修改属性的值 3.通过方法让属性的值递增\n继承 当⼀个类继承另⼀个类时，将⾃动获 得后者的所有属性和⽅法。原有的类称为⽗类（parent class），⽽新类称为 ⼦类（child class）。⼦类不仅继承了⽗类的所有属性和⽅法，还可定义⾃ ⼰的属性和⽅法\n子类的_init_()方法 在既有的类的基础上编写新类，通常要调⽤⽗类的 init() ⽅法。这 将初始化在⽗类的 init() ⽅法中定义的所有属性，从⽽让⼦类也可 以使⽤这些属性。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 class Car: \u0026#34;\u0026#34;\u0026#34;⼀次模拟汽⻋的简单尝试\u0026#34;\u0026#34;\u0026#34; def __init__(self, make, model, year): \u0026#34;\u0026#34;\u0026#34;初始化描述汽⻋的属性\u0026#34;\u0026#34;\u0026#34; self.make = make self.model = model self.year = year self.odometer_reading = 0 def get_descriptive_name(self): \u0026#34;\u0026#34;\u0026#34;返回格式规范的描述性名称\u0026#34;\u0026#34;\u0026#34; long_name = f\u0026#34;{self.year} {self.make} {self.model}\u0026#34; return long_name.title() def read_odometer(self): \u0026#34;\u0026#34;\u0026#34;打印⼀个句⼦，指出汽⻋的⾏驶⾥程\u0026#34;\u0026#34;\u0026#34; print(f\u0026#34;This car has {self.odometer_reading} miles on it.\u0026#34;) def update_odometer(self, mileage): \u0026#34;\u0026#34;\u0026#34;将⾥程表读数设置为给定的值\u0026#34;\u0026#34;\u0026#34; if mileage \u0026gt;= self.odometer_reading: self.odometer_reading = mileage else: print(\u0026#34;You can\u0026#39;t roll back an odometer!\u0026#34;) def increment_odometer(self, miles): \u0026#34;\u0026#34;\u0026#34;让⾥程表读数增加给定的量\u0026#34;\u0026#34;\u0026#34; self.odometer_reading += miles class ElectricCar(Car): \u0026#34;\u0026#34;\u0026#34;电动汽⻋的独特之处\u0026#34;\u0026#34;\u0026#34; def __init__(self, make, model, year): \u0026#34;\u0026#34;\u0026#34;初始化⽗类的属性\u0026#34;\u0026#34;\u0026#34; super().__init__(make, model, year) my_leaf = ElectricCar(\u0026#39;nissan\u0026#39;, \u0026#39;leaf\u0026#39;, 2024) print(my_leaf.get_descriptive_name()) ⾸先是 Car 类的代码（⻅❶）。在创建⼦类时，⽗类必须包含在当前⽂件 中，且位于⼦类前⾯。接下来，定义⼦类 ElectricCar（⻅❷）。在定义 ⼦类时，必须在括号内指定⽗类的名称。init() ⽅法接受创建 Car 实例所需的信息（⻅❸）。 super() 是⼀个特殊的函数，让你能够调⽤⽗类的⽅法（⻅❹）。这⾏代 码让 Python 调⽤ Car 类的 init() ⽅法，从⽽让 ElectricCar 实 例包含这个⽅法定义的所有属性。⽗类也称为超类（superclass），函数名 super 由此得名。 为了测试继承能够正确地发挥作⽤，我们尝试创建⼀辆电动汽⻋，但提供 的信息与创建燃油汽⻋时相同。在❺处，创建 ElectricCar 类的⼀个实 例，并将其赋给变量 my_leaf。这⾏代码调⽤ ElectricCar 类中定义的 init() ⽅法，后者让 Python 调⽤⽗类 Car 中定义的 init() ⽅法。我们提供了实参 \u0026rsquo;nissan\u0026rsquo;、\u0026rsquo;leaf\u0026rsquo; 和 2024\n给子类定义属性和方法 让⼀个类继承另⼀个类后，就可以添加区分⼦类和⽗类所需的新属性和新 ⽅法了。 下⾯添加⼀个电动汽⻋特有的属性（电池），以及⼀个描述该属性的⽅ 法。我们将存储电池容量，并编写⼀个⽅法打印对电池的描述\n重写父类中的方法\n将实例用作属性 在使⽤代码模拟实物时，你可能会发现⾃⼰给类添加了太多细节：属性和 ⽅法越来越多，⽂件越来越⻓。在这种情况下，可能需要将类的⼀部分提 取出来，作为⼀个独⽴的类。将⼤型类拆分成多个协同⼯作的⼩类，这种 ⽅法称为组合（composition）。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 class Car: --snip-- class Battery: \u0026#34;\u0026#34;\u0026#34;⼀次模拟电动汽⻋电池的简单尝试\u0026#34;\u0026#34;\u0026#34; def __init__(self, battery_size=40): \u0026#34;\u0026#34;\u0026#34;初始化电池的属性\u0026#34;\u0026#34;\u0026#34; self.battery_size = battery_size def describe_battery(self): \u0026#34;\u0026#34;\u0026#34;打印⼀条描述电池容量的消息\u0026#34;\u0026#34;\u0026#34; print(f\u0026#34;This car has a {self.battery_size}-kWh battery.\u0026#34;) class ElectricCar(Car): \u0026#34;\u0026#34;\u0026#34;电动汽⻋的独特之处\u0026#34;\u0026#34;\u0026#34; def __init__(self, make, model, year): \u0026#34;\u0026#34;\u0026#34; 先初始化⽗类的属性，再初始化电动汽⻋特有的属性 \u0026#34;\u0026#34;\u0026#34; super().__init__(make, model, year) self.battery = Battery() my_leaf = ElectricCar(\u0026#39;nissan\u0026#39;, \u0026#39;leaf\u0026#39;, 2024) print(my_leaf.get_descriptive_name()) my_leaf.battery.describe_battery() 模拟实物 这让你进⼊了程序员的另⼀个境界：在解决上述问题时，从较⾼的逻辑层 ⾯（⽽不是语法层⾯）思考。你考虑的不是 Python，⽽是如何使⽤代码来 表⽰实际事物。达到这种境界后，你会经常发现，对现实世界的建模⽅法 没有对错之分。有些⽅法的效率更⾼，但要找出效率最⾼的表⽰法，需要 ⼀定的实践。只要代码能够像你希望的那样运⾏，就说明你已经做得很好 了！即便发现⾃⼰不得不多次尝试使⽤不同的⽅法来重写类，也不必⽓ 馁。要编写出⾼效、准确的代码，这是必经之路\n导入类 模块级⽂档字符串，对该模块的内容做了简要的描述。你应该 为⾃⼰创建的每个模块编写⽂档字符串。\n导⼊类是⼀种⾼效的编程⽅式。如果这个程序包含整个 Class 类，它该有 多⻓啊！通过将这个类移到⼀个模块中并导⼊该模块，依然可使⽤其所有 功能，但主程序⽂件变得整洁易读了。这还让你能够将⼤部分逻辑存储在 独⽴的⽂件中。在确定类能像你希望的那样⼯作后，就可以不管这些⽂ 件，专注于主程序的⾼级逻辑了\n在一个模块中存储多个类\n从一个模块中导入多个类\n导入整个模块 先导⼊整个模块，再使⽤点号访问需要的类\n导入模块中的所有类\n使用别名\n找到合适的工作流程 ⼀开始应让代码结构尽量简单。⾸先尝试在⼀个⽂件中完成所有的⼯作， 确定⼀切都能正确运⾏后，再将类移到独⽴的模块中。如果你喜欢模块和 ⽂件的交互⽅式，可在项⽬开始时就尝试将类存储到模块中。先找出让你 能够编写出可⾏代码的⽅式，再尝试让代码更加整洁\npython标准库 randint()它将两个整数作为参数， 并随机返回⼀个位于这两个整数之间（含）的整数。下⾯演⽰了如何⽣成 ⼀个位于 1 和 6 之间的随机整数\n1 2 3 from random import randint randint(1, 6) 3 choice()它将⼀个列表或 元组作为参数，并随机返回其中的⼀个元素：\n1 2 3 4 5 from random import choice players = [\u0026#39;charles\u0026#39;, \u0026#39;martina\u0026#39;, \u0026#39;michael\u0026#39;, \u0026#39;florence\u0026#39;, \u0026#39;eli\u0026#39;] first_up = choice(players) first_up \u0026#39;florence 在创建与安全相关的应⽤程序时，不要使⽤模块 random，但它能⽤来创建 众多有趣的项⽬。\n类的编程风格 类名应采⽤驼峰命名法，即将类名中的每个单词的⾸字⺟都⼤写，并且不 使⽤下划线。实例名和模块名都采⽤全⼩写格式，并在单词之间加上下划 线。\n可以使⽤空⾏来组织代码，但不宜过多。在类中，可以使⽤⼀个空⾏来分 隔⽅法；⽽在模块中，可以使⽤两个空⾏来分隔类。 当需要同时导⼊标准库中的模块和你编写的模块时，先编写导⼊标准库模 块的 import 语句，再添加⼀个空⾏，然后编写导⼊你⾃⼰编写的模块的 import 语句。在包含多条 import 语句的程序中，这种做法让⼈更容易 明⽩程序使⽤的各个模块来⾃哪⾥。\n文件和异常\n要使⽤⽂件的内容，需要将其路径告知 Python。路径（path）指的是⽂件或 ⽂件夹在系统中的准确位置。Python 提供了 pathlib 模块，让你能够更轻 松地在各种操作系统中处理⽂件和⽬录。提供特定功能的模块通常称为库 （library）。这就是这个模块被命名为 pathlib 的原因所在 这⾥⾸先从 pathlib 模块导⼊ Path 类。Path 对象指向⼀个⽂件，可⽤ 来做很多事情。例如，让你在使⽤⽂件前核实它是否存在，读取⽂件的内 容，以及将新数据写⼊⽂件。这⾥创建了⼀个表⽰⽂件 pi_digits.txt 的 Path 对象，并将其赋给了变量 path（⻅❶）。由于这个⽂件与当前编写 的 .py ⽂件位于同⼀个⽬录中，因此 Path 只需要知道其⽂件名就能访问 它。\n1 2 3 4 5 from pathlib import Path path = Path(\u0026#39;pi_digits.txt\u0026#39;) contents = path.read_text() print(contents) read_text() 将该⽂件的全部内容作为⼀个字符串返回,read_text() 在到达⽂件末尾时会返回⼀个空字符串，⽽这个空字符串会被显⽰为⼀个空⾏。\n方法链式调用 这⾏代码先让 Python 对当前处理的⽂件调⽤ read_text() ⽅法，再对 read_text() 返回的字符串调⽤ rstrip() ⽅法，然后将整理好的字符 串赋给变量 contents。\n1 contents = path.read_text().rstrip() 相对文件路径和绝对文件路径\n访问文件中的各行 使⽤ splitlines() ⽅法将冗⻓的字符串转换为⼀系列⾏，再使⽤ for 循环以每次⼀⾏的⽅式检查⽂件中的各⾏：\n1 2 3 4 5 6 7 from pathlib import Path path = Path(\u0026#39;pi_digits.txt\u0026#39;) contents = path.read_text() lines = contents.splitlines() for line in lines: print(line) splitlines() ⽅法返回⼀个列 表，其中包含⽂件中所有的⾏，⽽我们将这个列表赋给了变量 lines\n使用文件的内容 注意：在读取⽂本⽂件时，Python 将其中的所有⽂本都解释为字符 串。如果读取的是数，并且要将其作为数值使⽤，就必须使⽤ int() 函数将其转换为整数，或者使⽤ float() 函数将其转换为浮点数。\n写入文件\n写入一行 定义⼀个⽂件的路径后，就可使⽤ write_text() 将数据写⼊该⽂件了\n注意：Python 只能将字符串写⼊⽂本⽂件。如果要将数值数据存储到 ⽂本⽂件中，必须先使⽤函数 str() 将其转换为字符串格式。\n写入多行 write_text() ⽅法会在幕后完成⼏项⼯作。⾸先，如果 path 变量对应 的路径指向的⽂件不存在，就创建它。其次，将字符串写⼊⽂件后，它会 确保⽂件得以妥善地关闭。如果没有妥善地关闭⽂件，可能会导致数据丢 失或受损。\n1 2 3 4 5 6 7 from pathlib import Path contents = \u0026#34;I love programming.\\n\u0026#34; contents += \u0026#34;I love creating new games.\\n\u0026#34; contents += \u0026#34;I also love working with data.\\n\u0026#34; path = Path(\u0026#39;programming.txt\u0026#39;) path.write_text(contents) 注意：在对 path 对象调⽤ write_text() ⽅法时，务必谨慎。如果 指定的⽂件已存在， write_text() 将删除其内容，并将指定的内容 写⼊其中。\n异常 Python 使⽤称为异常（exception）的特殊对象来管理程序执⾏期间发⽣的 错误。每当发⽣让 Python 不知所措的错误时，它都会创建⼀个异常对象。 如果你编写了处理该异常的代码，程序将继续运⾏；如果你未对异常进⾏ 处理，程序将停⽌，并显⽰⼀个 traceback，其中包含有关异常的报告。\n使用try-except代码块\n1 2 3 4 try: print(5/0) except ZeroDivisionError: print(\u0026#34;You can\u0026#39;t divide by zero!\u0026#34;) else代码块 这个⽰例还包含⼀个 else 代码块，只有 try 代码块成功执⾏才需要继续执⾏的代码，都应放到 else 代码块中\n1 2 3 4 5 6 7 8 9 10 11 --snip-- while True: --snip-- if second_number == \u0026#39;q\u0026#39;: break try: answer = int(first_number) / int(second_number) except ZeroDivisionError: print(\u0026#34;You can\u0026#39;t divide by 0!\u0026#34;) else: print(answer) 依赖 try 代码块成功执⾏的代码都被放在else 代码块中\n只有可能引发异常的代码才需要放在 try 语句中。有时候，有⼀些仅在 try 代码块成功执⾏时才需要运⾏的代码，这些代码应放在 else 代码块 中。except 代码块告诉 Python，如果在尝试运⾏ try 代码块中的代码时 引发了指定的异常该怎么办\n分析文本 使⽤ split() ⽅法，它默认以空⽩为分隔符将字符串分拆成多个部分\n1 2 3 4 5 6 7 8 9 10 11 from pathlib import Path path = Path(\u0026#39;alice.txt\u0026#39;) try: contents = path.read_text(encoding=\u0026#39;utf-8\u0026#39;) except FileNotFoundError: print(f\u0026#34;Sorry, the file {path} does not exist.\u0026#34;) else: #计算⽂件⼤致包含多少个单词 words = contents.split() num_words = len(words) print(f\u0026#34;The file {path} has about {num_words} words.\u0026#34;) 使用多个文件\n1 2 3 4 5 6 7 8 from pathlib import Path def count_words(filename): --snip-- filenames = [\u0026#39;alice.txt\u0026#39;, \u0026#39;siddhartha.txt\u0026#39;, \u0026#39;moby_dick.txt\u0026#39;, \u0026#39;little_women.txt\u0026#39;] for filename in filenames: path = Path(filename) count_words(path) 静默失败 但并⾮每次捕获异常都需要告诉⽤户，你有时候希望程序在发⽣异常时保持静默，就像什么都 没有发⽣⼀样继续运⾏。\n1 2 3 4 5 6 7 8 def count_words(path): \u0026#34;\u0026#34;\u0026#34;计算⼀个⽂件⼤致包含多少个单词\u0026#34;\u0026#34;\u0026#34; try: --snip-- except FileNotFoundError: pass else: --snip-- 存储数据 json.dumps() 函数接受⼀个实参，即要转换为 JSON 格式的数据。这个函数返回⼀个字符串\n1 2 3 4 5 6 7 from pathlib import Path import json numbers = [2,3,5,7,11,13] path = Path(\u0026#39;numbers.json\u0026#39;) contents = json.dumps(numbers) path.write_text(contents) 使⽤ json.loads() 将这个列表读取到内存中\n1 2 3 4 5 6 7 8 from pathlib import Path import json path = Path(\u0026#39;numbers.json\u0026#39;) contents = path.read_text() numbers = json.loads(contents) print(numbers) Path 类提供了很多很有⽤的⽅法。如果指定的⽂件或⽂件夹存在， exists() ⽅法返回 True，否则返回 False。这⾥使⽤ path.exists() 来确定是否存储了⽤户名（⻅❶）。如果⽂件 username.json 存在，就加载其中的⽤户名，并向⽤户发出个性化问候。\n测试代码 学习如何使⽤ pytest 来测试代码。pytest 库是⼀组⼯ 具，不仅能帮助你快速⽽轻松地编写测试，⽽且能持续⽀持随项⽬增⼤⽽ 变得复杂的测试。Python 默认不包含 pytest，因此你将学习如何安装外 部库\n测试函数 所幸 pytest 提供了⼀种⾃动测试函数输出的⾼效⽅式\n单元测试和测试用例 断言\n1 2 3 4 5 6 from name_function import get_formatted_name def test_first_last_name(): \u0026#34;\u0026#34;\u0026#34;能够正确地处理像 Janis Joplin 这样的姓名吗？\u0026#34;\u0026#34;\u0026#34; formatted_name = get_formatted_name(\u0026#39;janis\u0026#39;, \u0026#39;joplin\u0026#39;) assert formatted_name == \u0026#39;Janis Joplin\u0026#39; 测试⽂件的名称很重要，必须以test_打头。当你让 pytest 运⾏测试时，它将查找以 test_打头的⽂件，并运⾏其中的所有测试\n运行测试 如果直接运⾏⽂件 test_name_function.py，将不会有任何输出，因为我们没 有调⽤这个测试函数。相反，应该让 pytest 替我们运⾏这个测试⽂件。 为此，打开⼀个终端窗⼝，并切换到这个测试⽂件所在的⽂件夹。如果你 使⽤的是 VS Code，可打开测试⽂件所在的⽂件夹，并使⽤该编辑器内嵌 的终端。在终端窗⼝中执⾏命令 pytest\n通过\n$ pytest\r========================= test session starts\r=========================\r❶ platform darwin -- Python 3.x.x, pytest-7.x.x, pluggy-1.x.x\r❷ rootdir: /.../python_work/chapter_11\r❸ collected 1 item\r❹ test_name_function.py . [100%]\r========================== 1 passed in 0.00s\r==========================\r不通过\n$ pytest\r========================= test session starts\r=========================\r--snip--\r❶ test_name_function.py F [100%]\r❷ ============================== FAILURES\r===============================\r❸ ________________________ test_first_last_name\r_________________________\rdef test_first_last_name():\r\u0026quot;\u0026quot;\u0026quot;能够正确地处理像 Janis Joplin 这样的姓名吗?\u0026quot;\u0026quot;\u0026quot;\r❹ \u0026gt; formatted_name = get_formatted_name('janis', 'joplin')\r❺ E TypeError: get_formatted_name() missing 1 required positional\rargument: 'last'\rtest_name_function.py:5: TypeError\r======================= short test summary info\r=======================\rFAILED test_name_function.py::test_first_last_name - TypeError:\rget_formatted_name() missing 1 required positional argument:\r'last'\r========================== 1 failed in 0.04s\r==========================\r测试类 断言 使用夹具 在测试中，夹具（fixture）可帮助我们搭建测试环境。这通常意味着创建供 多个测试使⽤的资源。在 pytest 中，要创建夹具，可编写⼀个使⽤装饰 器 @pytest.fixture 装饰的函数。装饰器（decorator）是放在函数定义 前⾯的指令。在运⾏函数前，Python 将该指令应⽤于函数，以修改函数代 码的⾏为。这听起来很复杂，但是不⽤担⼼：即便没有学习如何编写装饰 器，也可使⽤第三⽅包中的装饰器\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 import pytest from survey import AnonymousSurvey @pytest.fixture def language_survey(): \u0026#34;\u0026#34;\u0026#34;⼀个可供所有测试函数使⽤的 AnonymousSurvey 实例\u0026#34;\u0026#34;\u0026#34; question = \u0026#34;What language did you first learn to speak?\u0026#34; language_survey = AnonymousSurvey(question) return language_survey def test_store_single_response(language_survey): \u0026#34;\u0026#34;\u0026#34;测试单个答案会被妥善地存储\u0026#34;\u0026#34;\u0026#34; language_survey.store_response(\u0026#39;English\u0026#39;) assert \u0026#39;English\u0026#39; in language_survey.responses def test_store_three_responses(language_survey): \u0026#34;\u0026#34;\u0026#34;测试三个答案会被妥善地存储\u0026#34;\u0026#34;\u0026#34; responses = [\u0026#39;English\u0026#39;, \u0026#39;Spanish\u0026#39;, \u0026#39;Mandarin\u0026#39;] for response in responses: language_survey.store_response(response) for response in responses: assert response in language_survey.responses 现在需要导⼊ pytest，因为我们使⽤了其中定义的⼀个装饰器。我们将装 饰器 @pytest.fixture（⻅❶）应⽤于新函数language_survey() （⻅❷）。这个函数创建并返回⼀个AnonymousSurvey 对象 请注意，两个测试函数的定义都变了（⻅❸和❺）：都有⼀个名为 language_survey 的形参。当测试函数的⼀个形参与应⽤了装饰器 @pytest.fixture 的函数（夹具）同名时，将⾃动运⾏夹具，并将夹具 返回的值传递给测试函数。在这个⽰例中，language_survey() 函数向 test_store_single_response() 和test_store_three_responses() 提供了⼀个 language_survey 实例。\n##使用Git进行版本控制\n安装Git\n配置Git\n创建项目 我们来创建⼀个要进⾏版本控制的项⽬。在系统中创建⼀个⽂件夹，并将 其命名为 git_practice。\n忽略文件 扩展名为 .pyc 的⽂件是根据 .py ⽂件⾃动⽣成的，因此⽆须让 Git 跟踪它 们。这些⽂件存储在⽬录 pycache 中。为了让 Git 忽略这个⽬录，创建 ⼀个名为 .gitignore 的特殊⽂件（这个⽂件名以句点打头，且没有扩展 名），并在其中添加如下⼀⾏内容 这会让 Git 忽略⽬录 pycache 中的所有⽂件。使⽤⽂件 .gitignore 可避 免混乱，让项⽬开发起来更容易。 你可能需要修改⽂件浏览器的设置，使其显⽰隐藏的⽂件（名称以句点打 头的⽂件）：在 Windows 资源管理器中，选择菜单“查看”中的复选框“隐藏 的项⽬”；在 macOS 系统中，按组合键 Command + Shift + .（句点）；在 Linux 系统中，查找并选择设置 Show Hidden Files（显⽰隐藏的⽂件）\n初始化仓库 前⾯创建了⼀个⽬录，其中包含⼀个 Python ⽂件和⼀个 .gitignore ⽂件，现 在可以初始化⼀个 Git 仓库了。为此，打开⼀个终端窗⼝，切换到⽂件夹 git_practice，并执⾏如下命令：\ngit_practice$ git init\rInitialized empty Git repository in git_practice/.git/\rgit_practice$\r输出表明 Git 在 git_practice 中初始化了⼀个空仓库。仓库（repository）是 程序中被 Git 主动跟踪的⼀组⽂件。Git ⽤来管理仓库的⽂件都存储在隐藏 的⽬录 .git 中。虽然你根本不需要与这个⽬录打交道，但千万不要删除它， 否则将丢失项⽬的所有历史记录。\n检查状态\ngit_practice$ git status\r❶ On branch main\rNo commits yet\r❷ Untracked files:\r(use \u0026quot;git add \u0026lt;file\u0026gt;...\u0026quot; to include in what will be committed)\r.gitignore\rhello_git.py\r❸ nothing added to commit but untracked files present (use \u0026quot;git add\u0026quot; to\rtrack)\rgit_practice$\r在 Git 中，分⽀（branch）是项⽬的⼀个版本。从这⾥的输出可知，我们位 于分⽀ main 上（⻅❶）。每当查看项⽬的状态时，输出都将指出位于分⽀ main 上。接下来的输出表明，还未执⾏任何提交。提交（commit）是项⽬ 在特定时间点的快照 Git 指出了项⽬中未被跟踪的⽂件（⻅❷），因为还没有告诉它要跟踪哪些 ⽂件。接下来，Git 告诉我们没有将任何东⻄添加到当前的提交中，并且指 出了可能需要加⼊仓库的未跟踪⽂件（⻅❸）\n将文件加入仓库\n❶ git_practice$ git add .\r❷ git_practice$ git status\rOn branch main\rNo commits yet\rChanges to be committed:\r(use \u0026quot;git rm --cached \u0026lt;file\u0026gt;...\u0026quot; to unstage)\r❸ new file: .gitignore\rnew file: hello_git.py\rgit_practice$\r命令 git add . 将项⽬中未被跟踪的所有⽂件（条件是没有在 .gitignore 中列出）都加⼊仓库（⻅❶）。它不提交这些⽂件，只是让 Git 关注它们。 现在检查项⽬的状态，会发现 Git 找出了⼀些需要提交的修改（⻅❷）。 new file 意味着这些⽂件是新添加到仓库中的（⻅❸）。\n执行提交\n❶ git_practice$ git commit -m \u0026quot;Started project.\u0026quot;\r❷ [main (root-commit) cea13dd] Started project.\r❸ 2 files changed, 5 insertions(+)\rcreate mode 100644 .gitignore\rcreate mode 100644 hello_git.py\r❹ git_practice$ git status\rOn branch main\rnothing to commit, working tree clean\rgit_practice$\r我们执⾏命令 git commit -m \u0026ldquo;message\u0026rdquo;（⻅❶）创建项⽬的快照。 标志 -m 让 Git 将接下来的消息（Started project.）记录到项⽬的历 史记录中。输出表明我们位于分⽀ main 上（⻅❷）且有两个⽂件被修改了 （⻅❸）。 现在检查状态，将发现我们位于分⽀ main 上且⼯作树是⼲净的（⻅❹）。 这是在每次提交项⽬的可⾏状态时都应该看到的消息。如果显⽰的消息不 是这样的，请仔细阅读，很可能是你在提交前忘记了添加⽂件\n查看提交历史 git log\n每次提交时，Git 都会⽣成⼀个独⼀⽆⼆的引⽤ ID，⻓度为 40 个字符。它 记录提交是谁执⾏的，提交的时间，以及提交时指定的消息。并⾮在任何 情况下都需要所有这些信息，因此 Git 提供了⼀个选项，让你能够打印提交 历史条⽬的简单版本\ngit log \u0026ndash;pretty=oneline 标志 \u0026ndash;pretty=oneline 指定显⽰两项最重要的信息：提交的引⽤ ID， 以及为提交记录的消息\n放弃修改 下⾯来看看如何放弃所做的修改，恢复到上⼀个可⾏状态 Git 注意到我们修改了 hello_git.py（⻅❶）。如果愿意，可以提交所做的修 改，但这次我们不提交所做的修改，⽽是恢复到最后⼀个提交（我们知 道，那次提交时项⽬能够正常地运⾏）。为此，我们不对 hello_git.py 执⾏ 任何操作（既不删除刚添加的代码⾏，也不使⽤⽂本编辑器的撤销功 能），⽽是在终端会话中执⾏如下命令 git_practice$ git restore git_practice$ git status\n在这个简单的项⽬中，恢复到之前某个状态的能⼒看似微不⾜道，但如果 开发的是⼤型项⽬，其中数⼗个⽂件都被修改了，那么通过恢复到上⼀个 状态，将撤销最后⼀次提交后对这些⽂件所做的所有修改。这个功能很有 ⽤：在实现新功能时，可根据需要做任意数量的修改；如果这些修改不可 ⾏，可撤销它们，⽽不会影响项⽬。你⽆须记住做了哪些修改并⼿动撤销 所做的修改，Git 会替你完成所有这些⼯作\n检出以前的提交 要检出提交历史中的任何提交，可使⽤命令 checkout，并指定该提交的 引⽤ ID 的前 6 个字符。检出并检查以前的提交后，既可以返回最后⼀次提 交，也可以放弃最近所做的⼯作并选择以前的提交 检出以前的提交后，将离开分⽀ main，并进⼊ Git 所说的分离头指针 （detached HEAD）状态（⻅❶）。HEAD 表⽰当前提交的项⽬状态。之所 以说处于分离状态（detached），是因为离开了⼀个具名分⽀（这⾥是 main）。 要回到分⽀ main，可按建议（⻅❷）所说的那样撤销上⼀个操作 这样就回到分⽀ main 了。除⾮要使⽤ Git 的⾼级功能，否则在检出以前的 提交后，最好不要对项⽬做任何修改。然⽽，如果参与项⽬开发的⼈只有 你⾃⼰，⽽你⼜想放弃最近的所有提交并恢复到以前的状态，也可将项⽬ 重置到以前的提交。\n删除仓库 有时候，仓库的历史记录被弄乱了，⽽你⼜不知道如何恢复。在这种情况 下，⾸先应考虑使⽤附录 C 介绍的⽅法寻求帮助。如果⽆法恢复且参与项 ⽬开发的只有你⼀个⼈，可继续使⽤这些⽂件，但将项⽬的历史记录删除 ——删除⽬录 .git。这不会影响任何⽂件的当前状态，只会删除所有的提 交，因此将⽆法检出项⽬的其他任何状态。 为此，既可以打开⼀个⽂件浏览器并将⽬录 .git 删除，也可以通过命令⾏将 其删除。之后，需要重新创建⼀个仓库，以便重新对修改进⾏跟踪。\n##项目 外星人入侵 规划项⽬ 这个游戏由 run_game() ⽅法控制。该⽅法包含⼀个不断运⾏的 while 循环（⻅❸），⽽这个循环包含⼀个事件循环以及管理屏幕更新的代码。 事件是⽤户玩游戏时执⾏的操作，如按键或移动⿏标。为了让程序能够响 应事件，可编写⼀个事件循环，以侦听事件并根据发⽣的事件类型执⾏适 当的任务\n我们使⽤ pygame.event.get() 函数来访问 Pygame 检测到的事件。这 个函数返回⼀个列表，其中包含它在上⼀次调⽤后发⽣的所有事件。所有 键盘和⿏标事件都将导致这个 for 循环运⾏。在这个循环中，我们将编写 ⼀系列 if 语句来检测并响应特定的事件。例如，当玩家单击游戏窗⼝的关 闭按钮时，将检测到 pygame.QUIT 事件，进⽽调⽤ sys.exit() 来退出 游戏\n处调⽤了pygame.display.flip()，命令 Pygame 让最近绘制的屏幕 可⻅。这⾥，它在每次执⾏ while 循环时都绘制⼀个空屏幕，并擦去旧屏 幕，使得只有新的空屏幕可⻅。我们在移动游戏元素时， pygame.display.flip() 将不断更新屏幕，以显⽰新位置上的元素并隐 藏原来位置上的元素，从⽽营造平滑移动的效果\n在这个⽂件末尾，创建⼀个游戏实例并调⽤ run_game()。这些代码被放 在⼀个 if 代码块中，仅当直接运⾏该⽂件时，它们才会执⾏。如果此时运 ⾏ alien_invasion.py，将看到⼀个空的 Pygame 窗⼝\n理想情况下，游戏在所有的系统中都应以相同的速度（帧率）运⾏。对于 可在多种系统中运⾏的游戏，控制帧率是个复杂的问题，好在 Pygame 提供 了⼀种相对简单的⽅式来达成这个⽬标。我们将创建⼀个时钟（clock）， 并确保它在主循环每次通过后都进⾏计时（tick）。当这个循环的通过速度 超过我们定义的帧率时，Pygame 会计算需要暂停多⻓时间，以便游戏的运 ⾏速度保持⼀致\ntick() ⽅法接受⼀个参数：游戏的帧率。这⾥使⽤的值为 60， Pygame 将 尽可能确保这个循环每秒恰好运⾏ 60 次。\n需要先加载⼀幅图像，再使⽤ Pygame blit() ⽅法绘制它。 最安全、成本最低的⽅式是使⽤ OpenGameArt 等⽹站提供的免费图形，这些素材⽆须授权许可即可使⽤和修改\n在游戏中，可以使⽤⼏乎任意类型的图像⽂件，但使⽤位图（.bmp）⽂件 最为简单，因为 Pygame 默认加载位图。虽然可配置 Pygame 以使⽤其他⽂ 件类型，但有些⽂件类型要求你在计算机上安装相应的图像库。⽹上的⼤ 多数图像是 .jpg 和 .png 格式的，不过可以使⽤ Photoshop、GIMP 和 Paint等⼯具将其转换为位图。\npygame 之所以⾼效，是因为它让你能够把所有的游戏元素当作矩形（rect 对象）来处理，即便它们的形状并⾮矩形也⼀样。⽽把游戏元素当作矩形 来处理之所以⾼效，是因为矩形是简单的⼏何形状。例如，通过将游戏元 素视为矩形，Pygame 能够更快地判断出它们是否发⽣了碰撞。这种做法的 效果通常很好，游戏玩家⼏乎注意不到我们处理的不是游戏元素的实际形 状。在这个类中，我们将把⻜船和屏幕作为矩形进⾏处理\n在处理 rect 对象时，可使⽤矩形的四个⾓及中⼼的 x 坐标和 y 坐标，通过 设置这些值来指定矩形的位置。如果要将游戏元素居中，可设置相应 rect 对象的属性 center、centerx 或 centery；要让游戏元素与屏幕边缘对 ⻬，可设置属性 top、bottom、left 或 right。除此之外，还有⼀些组 合属性，如 midbottom、midtop、midleft 和 midright。要调整游戏 元素的⽔平或垂直位置，可使⽤属性 x 和 y，它们分别是相应矩形左上⾓ 的 x 坐标和 y 坐标。这些属性让你⽆须去做游戏开发⼈员原本需要⼿动完 成的计算，因此很常⽤\n在 Pygame 中，原点(0, 0)位于屏幕的左上⾓，当⼀个点向右下 ⽅移动时，它的坐标值将增⼤。在 1200×800 的屏幕上，原点位于左上 ⾓，右下⾓的坐标为(1200, 800)。这些坐标对应的是游戏窗⼝，⽽不是 物理屏幕。\n##重构：_check_events() ⽅法和_update_screen() ⽅法 在⼤型项⽬中，经常需要在添加新代码前重构既有的代码。重构旨在简化 既有代码的结构，使其更容易扩展。本节将把越来越⻓的 run_game() ⽅ 法拆分成两个辅助⽅法。辅助⽅法（helper method）⼀般只在类中调⽤，不 会在类外调⽤。在 Python 中，辅助⽅法的名称以单下划线打头\n","date":"2024-03-17T13:35:01+08:00","permalink":"https://example.com/p/python/","title":"python"},{"content":"\n我打开圣经，上面第一句话就是就是\u0026quot;Hello World\u0026quot;\n其实，好多东西你自己用心去学，去看官方文档，效果比看网上那些猫猫狗狗的博客效果更好，我能做的就是抛块砖引个玉\n","date":"2024-03-17T13:28:01+08:00","permalink":"https://example.com/p/my-first-post/","title":"My First Post"}]