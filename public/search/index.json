[{"content":"爬虫基础 “可见即可爬~”\n爬虫概念 如果互联网是一张大的蜘蛛网，那一台计算机上的数据便是蜘蛛网上的一个猎物，而爬虫程序就是一只小蜘蛛，沿着蜘蛛网抓取自己想要的猎物/数据\n网络爬虫也叫网络蜘蛛，特指一类自动批量下载网络资源的程序 网络爬虫是伪装成客户端与服务端进行数据交互的程序\n爬虫的应用 1.数据采集 2.搜索引擎 3.模拟操作 4.软件测试 5.网络安全\n爬虫的分类（略） 爬虫的一般开发流程： 1.最简单的单一页面数据的爬取：\nurl-\u0026gt;发送请求，获取响应-\u0026gt;提取数据-\u0026gt;保存数据\n2.多页面数据的爬取\n发送请求，获取响应——\u0026gt;提取url地址，继续请求\n爬虫开发的重难点 1.数据的获取（反爬） 2.采集的速度\nHTTP和HTTPS 大多数商业应用采用的架构： 1.c/s client server 2.b/s broser(浏览器) server 3.m/s mobile server\n以上统称为客户端与服务端\nHTTP协议（超文本传输协议） 爬取想要的数据前，一定要明确其使用的是什么协议\nHTTP是基于TCP/IP通信协议来传输数据的\nTCP/IP通信的三次握手与四次挥手 三次握手建立连接 client:嘿，服务端girl！我想和你建立连接 server：好呀，嘻嘻 client：真好，那我们开始（数据）交互吧！\n（进行数据交互ing）\n四次挥手断开连接 client：我已经和你交互（数据）完了，我们断开连接吧! server：你确定要断开连接吗？ server：那你断开连接吧 client：欧克，那我断开连接了\nHTTP请求流程： 我们日常用浏览器搜索东西，输入的是URL,浏览器会将其自动转换为HTTP协议\n一次http请求的基本流程，有客户端向服务端发起一次请求（request），而服务器在接收到以后返回给客户端一个响应（response）.所以一次完成的http请求包含请求和响应两部分\n浏览器发送http请求的过程：\n1.域名解析\r2.发起TCP的3次握手\r3.建立TCP连接后发起HTTP请求\r4.服务器响应http请求，浏览器得到html代码\r5.浏览器解析html代码，并请求html代码中的资源（js，css，图片等）\r6.浏览器对页面进行渲染呈现给用户\rtip： 在网页的右键检查network-\u0026gt;name-\u0026gt;request headers view parsed下的connection:keep-alive保持常连接，就不用频繁三次握手和四次挥手了\n浏览器获取的内容（elements的内容）包含：url地址对应的响应+js+css+picture 爬虫会获取：url地址对应的响应\nurl（浏览器搜索框里的内容） 发送http请求时，通过url对网络资源进行定位\nurl：统一资源定位符。用来标识某一处资源的地址，也叫网址\n组成：协议+域名（端口默认80）+路径+参数 http协议的端口号默认为80可以不写，http协议的端口号默认为443可以不行，（域名可以确定时哪一台电脑，而端口号是为了确定是哪台电脑的哪一个应用）\n域名通常是IP地址的映射\nhttp请求格式 客户端发送一个HTTP请求到服务器的请求消息包括一下部分：请求行,请求头，空行和请求数据 请求方法 分类：\nOPTIONS\rPUT\rDELETE\rTRACE\rCONNECT\r常用方法是GET 和 POST\nGET:负责从服务器获取数据 POST:负责向服务器提交数据\n请求头 http请求正文 请求正文通常是使用POST请求中表单数据，而对于GET请求，请求体则为空\n在爬虫中，如果构造POST，需要正确的content-type，并了解各种请求库的各个参数设置时使用的是哪种content-type，不然可能会导致post提交后无法正常响应\nHTTP响应格式 由四个部分组成，分别是： 状态行（响应行） 消息报头 空行 响应正文\nhttp协议的特点 HTTP是无连接的 HTTP是媒体独立的 HTTP是无状态的\n保持http连接状态的技术是会话和Cookies\nhttps协议，安全版的HTTP http是基于tcp/ip协议的，而https是在http协议的基础之上，再加一层SSL/TLS协议，数据在传输过程中是加密的\nhttp是明文传输的而https是密文传输，所以较安全但性能低\n会话技术 会话在服务端，就是网站的服务器，用来保存用户的会话信息；cookies在客户端，也可以理解为浏览器端\nCookie 指某些网站为了辨别用户身份，进行session跟踪而存储在用户本地终端上的数据（通常经过加密）\nCookie可以理解为一个凭证 1.实际是由服务器发给客户端的特殊信息 2.这些信息以文本文件的方式存放在客户端 3.客户端每次向服务器发送请求的时候都会带上这些特殊信息 4.服务器在接收到Cookie以后，会验证cookie的信息，以此来辨别用户的身份\n爬虫为什么要使用cookie 好处： 能够访问登陆页面\r有一定的反爬作用\r坏处： 请求太频繁有可能被识别为爬虫\r一般使用多账号解决\rSession 一个浏览器窗口从打开到关闭这个期间\n在一个客户从打开浏览器到关闭浏览器这个期间，发起的所以请求都可以被识别为同一个用户，session是基于cookie的\n以上资料来自https://blog.csdn.net/qq_44907926/article/details/118585030\n作者大大真的牛逼，写的真好\n","date":"2024-03-21T13:28:01+08:00","permalink":"http://localhost:1313/p/%E7%88%AC%E8%99%AB/","title":"爬虫"},{"content":"git 啊能镇楼\ngit配置 $ git config --global user.name \u0026quot;runoob\u0026quot;\r$ git config --global user.email test@runoob.com\r查看配置信息 $ git config --list\rgit工作流程 克隆git资源作为工作目录 在克隆的资源上添加或修改文件 如果其他人修改，你可以更新资源 在提交前查看修改 提交修改 在修改完成后，如果发现有错误，可以撤回提交并再次修改并提交 基本概念 工作区：就是你在电脑里能看到的目录 暂存区：英文叫stage或index，一般存放在 .git 目录下的index文件，所以我们把暂存区有时也叫作索引（index） 版本库：工作区有一个隐藏目录 .git，这个不算工作区，而是Git的版本库 图中左侧为工作区，右侧为版本库。在版本库中标记为“index”的区域是暂存区（stage/index）,标记为“master”的是master分支所代表的目录树 图中我们可以看出此时“HEAD”实际是指向master分支的一个“游标”。所以图示的命令中出现HEAD的地方是可以用master来替换的 图中的object标识的区域为git的对象库，实际位于“.git/objects”目录下，里面包含了创建的各种对象及内容 当对工作区修改（或新增）的文件执行git add命令时，暂存区的目录树被更新，同时工作区修改（或新增）的文件内容被写入到对象库中的一个新的对象中，而该对象的ID被记录在暂存区的文件索引中 当执行提交（git commit）时，暂存区的目录树写到版本库（对象库）中，master分支会相应的更新。即master指向的目录树就是提交时暂存区的目录树 当执行 git reset HEAD 操作时，暂存区的目录树会被重写，被master分支指向的目录树所替换，但是工作区不受影响 当执行 git rm \u0026ndash;cached 命令时，会直接从暂存区删除文件，工作区则不做出改变。 当执行 git checkout . 或者 git checkout \u0026ndash; 命令时，会用暂存区全部或指定的文件替换工作区的文件。这个操作很危险，会清除工作区中未添加到暂存区中的改动。 当执行 git checkout HEAD . 或者 git checkout HEAD 命令时，会用 HEAD 指向的 master 分支中的全部或者部分文件替换暂存区和以及工作区中的文件。这个命令也是极具危险性的，因为不但会清除工作区中未提交的改动，也会清除暂存区中未提交的改动 git 创建仓库 git init初始化一个仓库 Git 的很多命令都需要在 Git 的仓库中运行，所以 git init 是使用 Git 的第一个命令。 在执行完成 git init 命令后，Git 仓库会生成一个 .git 目录，该目录包含了资源的所有元数据，其他的项目目录保持不变。\ngit init newrepo使用我们指定目录作为Git仓库\n初始化后，会在 newrepo 目录下会出现一个名为 .git 的目录，所有 Git 需要的数据和资源都存放在这个目录中。\n如果当前目录下有几个文件想要纳入版本控制，需要先用 git add 命令告诉 Git 开始对这些文件进行跟踪，然后提交\n1 2 3 $ git add *.c $ git add README $ git commit -m \u0026#39;初始化项目版本\u0026#39; 以上命令将目录下以 .c 结尾及 README 文件提交到仓库中。\n注： 在 Linux 系统中，commit 信息使用单引号 \u0026lsquo;，Windows 系统，commit 信息使用双引号 \u0026ldquo;。所以在 git bash 中 git commit -m \u0026lsquo;提交说明\u0026rsquo; 这样是可以的，在 Windows 命令行中就要使用双引号 git commit -m \u0026ldquo;提交说明\u0026rdquo;\ngit clone 我们使用 git clone 从现有 Git 仓库中拷贝项目\n1 git clone \u0026lt;repo\u0026gt; 如果我们需要克隆到指定的目录，可以使用以下命令格式\n1 git clone \u0026lt;repo\u0026gt; \u0026lt;directory\u0026gt; 参数说明\nrepo：git仓库 directory：本地目录 比如，要克隆 Ruby 语言的 Git 代码仓库 Grit，可以用下面的命令：\n1 $ git clone git://github.com/schacon/grit.git 执行该命令后，会在当前目录下创建一个名为grit的目录，其中包含一个 .git 的目录，用于保存下载下来的所有版本记录。\n如果要自己定义要新建的项目目录名称，可以在上面的命令末尾指定新的名字：\n1 $ git clone git://github.com/schacon/grit.git mygrit git init 初始化仓库 git add . 添加文件到暂存区 git commit 将暂存区内容添加到仓库中 创建仓库命令 git 初始化仓库 git clone 拷贝一份远程仓库，也就是下载一个项目 提交与修改 git add 添加文件到暂存区 git status 查看仓库当前的状态，显示有变更的文件 git diff 比较文件的不同，即暂存区和工作区的差异 git commit 提交暂存区到本地仓库 git reset 回退版本 git rm 将文件从暂存区和工作区删除 git mv 移动或重命名工作区文件 git checkout 分支切换 git switch 更清晰地切换分支（2.3版本引入） git restore 恢复或撤销文件的更改 提交日志 git log 查看历史提交记录 git blame 以列表形式查看指定文件的历史修改记录 远程操作 git remote 远程仓库操作 git fetch 从远程获取代码库 git pull 下载远程代码并合并 git push 上传远程代码并合并 git分支管理 创建分支命令： git branch (branchname)\n切换分支命令 git checkout (branchname)\n当你切换分支的时候，git会用该分支的最后提交的快照替换你的工作目录的内容，以多个分支不需要多个目录。\n合并分支命令 git merge\n你可以多次合并到统一分支， 也可以选择在合并之后直接删除被并入的分支。\ngit 分支管理 列出分支 git branch 没有参数时，git branch 会列出你在本地的分支\n$ git branch\r* master\r此例的意思就是，我们有一个叫做 master 的分支，并且该分支是当前分支。\n当你执行 git init 的时候，默认情况下 Git 就会为你创建 master 分支。\n如果我们要手动创建一个分支。执行 git branch (branchname) 即可\n$ git branch testing\r$ git branch\r* master\rtesting\r现在我们可以看到，有了一个新分支 testing。\n当你以此方式在上次提交更新之后创建了新分支，如果后来又有更新提交， 然后又切换到了 testing 分支，Git 将还原你的工作目录到你创建分支时候的样子。\n接下来我们将演示如何切换分支，我们用 git checkout (branch) 切换到我们要修改的分支\n$ ls\rREADME\r$ echo 'runoob.com' \u0026gt; test.txt\r$ git add .\r$ git commit -m 'add test.txt'\r[master 3e92c19] add test.txt\r1 file changed, 1 insertion(+)\rcreate mode 100644 test.txt\r$ ls\rREADME test.txt\r$ git checkout testing\rSwitched to branch 'testing'\r$ ls\rREADME\r当我们切换到 testing 分支的时候，我们添加的新文件 test.txt 被移除了。切换回 master 分支的时候，它们又重新出现了。\n$ git checkout master\rSwitched to branch 'master'\r$ ls\rREADME test.txt\r我们也可以使用 git checkout -b (branchname) 命令来创建新分支并立即切换到该分支下，从而在该分支中操作。\n$ git checkout -b newtest\rSwitched to a new branch 'newtest'\r$ git rm test.txt rm 'test.txt'\r$ ls\rREADME\r$ touch runoob.php\r$ git add .\r$ git commit -am 'removed test.txt、add runoob.php'\r[newtest c1501a2] removed test.txt、add runoob.php\r2 files changed, 1 deletion(-)\rcreate mode 100644 runoob.php\rdelete mode 100644 test.txt\r$ ls\rREADME runoob.php\r$ git checkout master\rSwitched to branch 'master'\r$ ls\rREADME test.txt\r如你所见，我们创建了一个分支，在该分支上移除了一些文件 test.txt，并添加了 runoob.php 文件，然后切换回我们的主分支，删除的 test.txt 文件又回来了，且新增加的 runoob.php 不存在主分支中。\n使用分支将工作切分开来，从而让我们能够在不同开发环境中做事，并来回切换\n删除分支 git branch -d (branchname)\n例如我们要删除 testing 分支： $ git branch * master testing $ git branch -d testing Deleted branch testing (was 85fc7e7). $ git branch * master\n分支合并 一旦某分支有了独立内容，你终究会希望将它合并回到你的主分支。 你可以使用以下命令将任何分支合并到当前分支中去\ngit merge\n$ git branch\r* master\rnewtest\r$ ls\rREADME test.txt\r$ git merge newtest\rUpdating 3e92c19..c1501a2\rFast-forward\rrunoob.php | 0\rtest.txt | 1 -\r2 files changed, 1 deletion(-)\rcreate mode 100644 runoob.php\rdelete mode 100644 test.txt\r$ ls\rREADME runoob.php\r以上实例中我们将 newtest 分支合并到主分支去，test.txt 文件被删除。\n合并完后就可以删除分支\n$ git branch -d newtest\rDeleted branch newtest (was c1501a2).\r删除后， 就只剩下 master 分支了：\n$ git branch\r* master\r合并冲突 合并并不仅仅是简单的文件添加、移除的操作，Git 也会合并修改\n$ git branch\r* master\r$ cat runoob.php\r首先，我们创建一个叫做 change_site 的分支，切换过去，我们将 runoob.php 内容改为\n\u0026lt;?php\recho 'runoob';\r?\u0026gt;\r创建 change_site 分支：\n$ git checkout -b change_site\rSwitched to a new branch 'change_site'\r$ vim runoob.php\r$ head -3 runoob.php\r\u0026lt;?php\recho 'runoob';\r?\u0026gt;\r$ git commit -am 'changed the runoob.php'\r[change_site 7774248] changed the runoob.php\r1 file changed, 3 insertions(+)\r将修改的内容提交到 change_site 分支中。 现在，假如切换回 master 分支我们可以看内容恢复到我们修改前的(空文件，没有代码)，我们再次修改 runoob.php 文件。\n$ git checkout master\rSwitched to branch 'master'\r$ cat runoob.php\r$ vim runoob.php # 修改内容如下\r$ cat runoob.php\r\u0026lt;?php\recho 1;\r?\u0026gt;\r$ git diff\rdiff --git a/runoob.php b/runoob.php\rindex e69de29..ac60739 100644\r--- a/runoob.php\r+++ b/runoob.php\r@@ -0,0 +1,3 @@\r+\u0026lt;?php\r+echo 1;\r+?\u0026gt;\r$ git commit -am '修改代码'\r[master c68142b] 修改代码\r1 file changed, 3 insertions(+)\r现在这些改变已经记录到我的 \u0026ldquo;master\u0026rdquo; 分支了。接下来我们将 \u0026ldquo;change_site\u0026rdquo; 分支合并过来\n$ git merge change_site\rAuto-merging runoob.php\rCONFLICT (content): Merge conflict in runoob.php\rAutomatic merge failed; fix conflicts and then commit the result.\r$ cat runoob.php # 打开文件，看到冲突内容\r\u0026lt;?php\r\u0026lt;\u0026lt;\u0026lt;\u0026lt;\u0026lt;\u0026lt;\u0026lt; HEAD\recho 1;\r=======\recho 'runoob';\r\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt; change_site\r?\u0026gt;\r我们将前一个分支合并到 master 分支，一个合并冲突就出现了，接下来我们需要手动去修改它\n$ vim runoob.php $ cat runoob.php\r\u0026lt;?php\recho 1;\recho 'runoob';\r?\u0026gt;\r$ git diff\rdiff --cc runoob.php\rindex ac60739,b63d7d7..0000000\r--- a/runoob.php\r+++ b/runoob.php\r@@@ -1,3 -1,3 +1,4 @@@\r\u0026lt;?php\r+echo 1;\r+ echo 'runoob';\r?\u0026gt;\r在 Git 中，我们可以用 git add 要告诉 Git 文件冲突已经解决 $ git status -s UU runoob.php $ git add runoob.php $ git status -s M runoob.php $ git commit [master 88afe0e] Merge branch \u0026lsquo;change_site\u0026rsquo;\ngit查看提交历史 我们还可以用 \u0026ndash;graph 选项，查看历史中什么时候出现了分支、合并。以下为相同的命令，开启了拓扑图选项\nd5e9fc2 (HEAD -\u0026gt; master) Merge branch \u0026lsquo;change_site\u0026rsquo; |\\\n| * 7774248 (change_site) changed the runoob.php | c68142b 修改代码 |/ c1501a2 removed test.txt、add runoob.php 3e92c19 add test.txt 3b58100 第一次版本提交 现在我们可以更清楚明了地看到何时工作分叉、又何时归并。\n你也可以用 \u0026ndash;reverse 参数来逆向显示所有日志。\n$ git log --reverse --oneline\r3b58100 第一次版本提交\r3e92c19 add test.txt\rc1501a2 removed test.txt、add runoob.php\r7774248 (change_site) changed the runoob.php\rc68142b 修改代码\rd5e9fc2 (HEAD -\u0026gt; master) Merge branch 'change_site'\r如果只想查找指定用户的提交日志可以使用命令：git log \u0026ndash;author , 例如，比方说我们要找 Git 源码中 Linus 提交的部分\n$ git log --author=Linus --oneline -5\r81b50f3 Move 'builtin-*' into a 'builtin/' subdirectory\r3bb7256 make \u0026quot;index-pack\u0026quot; a built-in\r377d027 make \u0026quot;git pack-redundant\u0026quot; a built-in\rb532581 make \u0026quot;git unpack-file\u0026quot; a built-in\r112dd51 make \u0026quot;mktag\u0026quot; a built-in\r如果你要指定日期，可以执行几个选项：\u0026ndash;since 和 \u0026ndash;before，但是你也可以用 \u0026ndash;until 和 \u0026ndash;after。\n例如，如果我要看 Git 项目中三周前且在四月十八日之后的所有提交，我可以执行这个（我还用了 \u0026ndash;no-merges 选项以隐藏合并提交）\n$ git log --oneline --before={3.weeks.ago} --after={2010-04-18} --no-merges\r5469e2d Git 1.7.1-rc2\rd43427d Documentation/remote-helpers: Fix typos and improve language\r272a36b Fixup: Second argument may be any arbitrary string\rb6c8d2d Documentation/remote-helpers: Add invocation section\r5ce4f4e Documentation/urls: Rewrite to accomodate transport::address\r00b84e9 Documentation/remote-helpers: Rewrite description\r03aa87e Documentation: Describe other situations where -z affects git diff\r77bc694 rebase-interactive: silence warning when no commits rewritten\r636db2c t3301: add tests to use --format=\u0026quot;%N\u0026quot;\r更多 git log 命令可查看 http://git-scm.com/docs/git-log 或使用 git log \u0026ndash;help 命令查看帮助信息。\ngit blame git blame 命令用于逐行显示指定文件的每一行代码是由谁在什么时候引入或修改的。\nstrong\u0026gt;git blame 可以追踪文件中每一行的变更历史，包括作者、提交哈希、提交日期和提交消息等信息。\n如果要查看指定文件的修改记录可以使用 git blame 命令，格式如下\ngit blame [选项] \u0026lt;文件路径\u0026gt;\ngit标签 如果你达到一个重要的阶段，并希望永远记住那个特别的提交快照，你可以使用 git tag 给它打上标签。\n比如说，我们想为我们的 runoob 项目发布一个\u0026quot;1.0\u0026quot;版本。 我们可以用 git tag -a v1.0 命令给最新一次提交打上（HEAD）\u0026ldquo;v1.0\u0026quot;的标签。\n-a 选项意为\u0026quot;创建一个带注解的标签\u0026rdquo;。 不用 -a 选项也可以执行的，但它不会记录这标签是啥时候打的，谁打的，也不会让你添加个标签的注解。 我推荐一直创建带注解的标签。\n$ git tag -a v1.0\n当你执行 git tag -a 命令时，Git 会打开你的编辑器，让你写一句标签注解，就像你给提交写注解一样。\n现在，注意当我们执行 git log \u0026ndash;decorate 时，我们可以看到我们的标签了\nd5e9fc2 (HEAD -\u0026gt; master) Merge branch \u0026lsquo;change_site\u0026rsquo; |\\\n| * 7774248 (change_site) changed the runoob.php | c68142b 修改代码 |/ c1501a2 removed test.txt、add runoob.php 3e92c19 add test.txt 3b58100 第一次版本提交 如果我们忘了给某个提交打标签，又将它发布了，我们可以给它追加标签。\n例如，假设我们发布了提交 85fc7e7(上面实例最后一行)，但是那时候忘了给它打标签。 我们现在也可以\n$ git tag -a v0.9 85fc7e7\r$ git log --oneline --decorate --graph\r* d5e9fc2 (HEAD -\u0026gt; master) Merge branch 'change_site'\r|\\ | * 7774248 (change_site) changed the runoob.php\r* | c68142b 修改代码\r|/ * c1501a2 removed test.txt、add runoob.php\r* 3e92c19 add test.txt\r* 3b58100 (tag: v0.9) 第一次版本提交\r如果我们要查看所有标签可以使用以下命令\n$ git tag\rv0.9\rv1.0\r指定标签信息命令： git tag -a -m \u0026ldquo;runoob.com标签\u0026rdquo;\nPGP签名标签命令 git tag -s -m \u0026ldquo;runoob.com标签\u0026rdquo;\ngit远程仓库（github） 添加远程库 要添加一个新的远程仓库，可以指定一个简单的名字，以便将来引用,命令格式如下\ngit remote add [shortname] [url]\n本例以 Github 为例作为远程仓库，如果你没有 Github 可以在官网 https://github.com/注册。\n由于你的本地 Git 仓库和 GitHub 仓库之间的传输是通过SSH加密的，所以我们需要配置验证信息：\n使用以下命令生成 SSH Key：\n后面的 your_email@youremail.com 改为你在 Github 上注册的邮箱，之后会要求确认路径和输入密码，我们这使用默认的一路回车就行。\n成功的话会在 ~/ 下生成 .ssh 文件夹，进去，打开 id_rsa.pub，复制里面的 key。\n$ ssh-keygen -t rsa -C \u0026quot;429240967@qq.com\u0026quot;\rGenerating public/private rsa key pair.\rEnter file in which to save the key (/Users/tianqixin/.ssh/id_rsa): Enter passphrase (empty for no passphrase): # 直接回车\rEnter same passphrase again: # 直接回车\rYour identification has been saved in /Users/tianqixin/.ssh/id_rsa.\rYour public key has been saved in /Users/tianqixin/.ssh/id_rsa.pub.\rThe key fingerprint is:\rSHA256:MDKVidPTDXIQoJwoqUmI4LBAsg5XByBlrOEzkxrwARI 429240967@qq.com\rThe key's randomart image is:\r+---[RSA 3072]----+\r|E*+.+=**oo |\r|%Oo+oo=o. . |\r|%**.o.o. |\r|OO. o o |\r|+o+ S |\r|. |\r| |\r| |\r| |\r+----[SHA256]-----+\r回到 github 上，进入 Account =\u0026gt; Settings（账户配置）\n左边选择 SSH and GPG keys，然后点击 New SSH key 按钮,title 设置标题，可以随便填，粘贴在你电脑上生成的 key。\n为了验证是否成功，输入以下命令：\n$ ssh -T git@github.com\rThe authenticity of host 'github.com (52.74.223.119)' can't be established.\rRSA key fingerprint is SHA256:nThbg6kXUpJWGl7E1IGOCspRomTxdCARLviKw6E5SY8.\rAre you sure you want to continue connecting (yes/no/[fingerprint])? yes # 输入 yes\rWarning: Permanently added 'github.com,52.74.223.119' (RSA) to the list of known hosts.\rHi tianqixin! You've successfully authenticated, but GitHub does not provide shell access. # 成功信息\r以下命令说明我们已成功连上 Github。\n之后登录后点击\u0026rdquo; New repository \u0026quot;\n之后在在Repository name 填入 runoob-git-test(远程仓库名) ，其他保持默认设置，点击\u0026quot;Create repository\u0026quot;按钮，就成功地创建了一个新的Git仓库\n查看当前的远程库 git remote\n$ git remote\rorigin\r$ git remote -v\rorigin git@github.com:tianqixin/runoob-git-test.git (fetch)\rorigin git@github.com:tianqixin/runoob-git-test.git (push)\r提取远程仓库 Git 有两个命令用来提取远程仓库的更新。\n1、从远程仓库下载新分支与数据\ngit fetch\n该命令执行完后需要执行 git merge 远程分支到你所在的分支。\n2、从远端仓库提取数据并尝试合并到当前分支：\ngit merge\n该命令就是在执行 git fetch 之后紧接着执行 git merge 远程分支到你所在的任意分支\n推送到远程仓库 推送你的新分支与数据到某个远端仓库命令:\ngit push [alias] [branch]\n以上命令将你的 [branch] 分支推送成为 [alias] 远程仓库上的 [branch] 分支，实例如下。\n$ touch runoob-test.txt # 添加文件 $ git add runoob-test.txt $ git commit -m \u0026ldquo;添加到远程\u0026rdquo; master 69e702d] 添加到远程 1 file changed, 0 insertions(+), 0 deletions(-) create mode 100644 runoob-test.txt\n$ git push origin master # 推送到 Github\n删除远程仓库 git remote rm [别名]\ngit服务其搭建（暂时不搞） 以上文档资料来自菜鸟教程，本人只是学习并总结借鉴\n最后,德狗镇楼 ","date":"2024-03-19T13:35:01+08:00","permalink":"http://localhost:1313/p/git/","title":"git"},{"content":"Windo和Linux双系统方法 磁盘分区 1.打开计算机管理 2.找到磁盘管理 3.选择你要压缩的盘，你压缩掉的空间将作为新系统的空间 4.右键打开你要压缩的盘符，点击压缩卷 5.压缩后的效果 下载Linux镜像 1.下载 Ubuntu 镜像，这里可以去官方下载，但是官方在国外，默认外网链接可能网速有点小慢。（科技玩家例外） 更好的选择是国内的资源镜像网站，比如说清华大学开源软件镜像站\n清华大学开源软件镜像站 https://mirrors.tuna.tsinghua.edu.cn/ 准备u盘刻盘工具 我用的是UltralSO\nhttps://cn.ultraiso.net/xiazai.html\n下载后打开，找到你下载的镜像文件，找到后，点击右上角的启动-\u0026gt;写入硬盘映像 写入时记得插入u盘，这个u盘将作为启动盘 写入时，这个u盘的数据全会被格式化，谨慎操作\n然后点击写入就可以了\n开机引导界面 将写好的映像文件的U盘插入你需要的电脑，在开始时按f12，本人用的是联想，不同电脑可能不同，正常都是f12\n在引导界面可以看到几个选项，选择你的u盘作为启动项，反正不是window和network就是了\n接下来你会进入这个界面 点击这个install软件进入配置 选语言-\u0026gt;安装类型我选最小安装-\u0026gt;进行磁盘分区，我分了四个盘，具体操作，选择你事先被压缩的空间，点击右下角的加号\n很抱歉当时没有拍下分盘的具体过程，如有需要可以自己去搜索，我给个链接 https://blog.csdn.net/u012514113/article/details/131269056\n安装后-\u0026gt;选择地区-\u0026gt;设置账户密码-\u0026gt;重启-\u0026gt;输入密码，ok\n以后你每次开机时都可以选择windo和Linux之一的系统进行启动\n","date":"2024-03-17T13:38:01+08:00","permalink":"http://localhost:1313/p/linux/","title":"Linux"},{"content":"这是我在学习蛇书时的学习笔记，写这篇博客一是为了自己以后复盘，二是顺便分享一下，本人写这篇文章时才大二，写的不是很好，但是我就是不改，嘿嘿~~ 白金镇楼 Python和markdown使用方法 markdown基础使用方法 标题前面加井号\n回车不能换行，只是将文字加个空格，想要换行需要在上一行后面加两个空格再回车\n想要在新起一段，则打两个回车\nctrl+i ：斜体 ctrl+b ：加粗\n列表:\n鸡翅 1.汉堡 2.可乐\n插入图片： ctrl+alt+v\n数学公式：以“\\”起始 行内展示数学公式：ctrl+m 另起一段展示数学公式，上面连按两下\n表格：第一行是表头以“|”分列，第二行是对齐方式，“-”表示默认即左对齐，在“—”左侧加“：”为左对齐，两边加为居中对齐,冒号一定要用英文 alt+shift+f可格式话文本编排\n链接：复制链接直接cv 直接黏贴则直接生成可点击的链接 选中文字黏贴则生成可点击的文字按钮链接，选中文字黏贴则生成可点击的文字按钮链接\n代码块:\n1 2 int a a = 100 指定语言可高亮\n1 2 int a a = 100 分割线 在所需添加分割线的文本下新起一行输入三个减号“\u0026mdash;” 阿巴阿巴阿巴阿巴\n引用 在引用的2文字前加上大于号“\u0026gt;”\n聪明的愚者\n流程图（略）\nmd文件导出为其他文件\n##Python编程：从入门到实践\n###字符串 name.title() name.upper() name.lower()\nf字符串\n1 2 3 4 first_name = \u0026#34;ada\u0026#34; last_name = \u0026#34;lovelace\u0026#34; fulll_name = f\u0026#34;{first_name} {last_name}\u0026#34; message = f\u0026#34;Hello,{full_name.title()}!\u0026#34; 删除空白 ❶ \u0026raquo;\u0026gt; favorite_language = \u0026rsquo; python \u0026rsquo; ❷ \u0026raquo;\u0026gt; favorite_language.rstrip() \u0026rsquo; python\u0026rsquo; ❸ \u0026raquo;\u0026gt; favorite_language.lstrip() \u0026lsquo;python \u0026rsquo; ❹ \u0026raquo;\u0026gt; favorite_language.strip() \u0026lsquo;python\u0026rsquo;\n删除前缀\nnostarch_url = \u0026lsquo;https://nostarch.com\u0026rsquo; nostarch_url.removeprefix(\u0026lsquo;https://\u0026rsquo;) \u0026rsquo;nostarch.com\u0026rsquo;\n常量 常量（constant）是在程序的整个⽣命周期内都保持不变的变量。Python 没 有内置的常量类型，但 Python 程序员会使⽤全⼤写字⺟来指出应将某个变 量视为常量，其值应始终不变\n列表 append追加 insert插入 del pop()弹栈，可加索引 remove()根据值删除元素 sort()对列表永久排序 car.sort(reverse=True) sorted()临时排序 reverse() len()\n使用range()创建数值列表 numbers = list(range(1,6))\n列表推导式 squares = [value**2 for value in range(1,11)]\n切片 players[0:3]\n复制列表 players[:]\n元组 列表⾮常适合⽤于存储在程序运⾏期间可能变化的数据集。列表是可以修 改的，这对于处理⽹站的⽤户列表或游戏中的⾓⾊列表⾄关重要。然⽽， 你有时候需要创建⼀系列不可修改的元素，元组可满⾜这种需求。Python 将不能修改的值称为不可变的，⽽不可变的列表称为元组（tuple）。\n1 2 3 4 5 6 7 requested_toppings = [] if requested_toppings: for requested_topping in requested_toppings: print(f\u0026#34;Adding {requested_topping}.\u0026#34;) print(\u0026#34;\\nFinished making your pizza!\u0026#34;) else: print(\u0026#34;Are you sure you want a plain pizza?\u0026#34;) 使用多个列表\n1 2 3 4 5 6 7 8 available_toppings = [\u0026#39;mushrooms\u0026#39;, \u0026#39;olives\u0026#39;, \u0026#39;green peppers\u0026#39;,\u0026#39;pepperoni\u0026#39;, \u0026#39;pineapple\u0026#39;, \u0026#39;extra cheese\u0026#39;] requested_toppings = [\u0026#39;mushrooms\u0026#39;, \u0026#39;french fries\u0026#39;, \u0026#39;extra cheese\u0026#39;] for requested_topping in requested_toppings: if requested_topping in available_toppings: print(f\u0026#34;Adding {requested_topping}.\u0026#34;) else: print(f\u0026#34;Sorry, we don\u0026#39;t have {requested_topping}.\u0026#34;) print(\u0026#34;\\nFinished making your pizza!\u0026#34;) 一个简单的字典\n1 2 3 4 5 6 7 8 alien_0 = {\u0026#39;color\u0026#39;：\u0026#39;green\u0026#39;,\u0026#39;point\u0026#39;:5} print(alien_0[\u0026#39;color\u0026#39;]) print(alien_0[\u0026#39;points\u0026#39;]) #添加键值对 alien_0[\u0026#39;x_position\u0026#39;] = 0 alien_0[\u0026#39;y_position\u0026#39;] = 25 #删除键值对 del 由类似的对象组成的字典\n1 2 3 4 5 6 favorite_languages = { \u0026#39;jen\u0026#39;: \u0026#39;python\u0026#39;, \u0026#39;sarah\u0026#39;: \u0026#39;c\u0026#39;, \u0026#39;edward\u0026#39;: \u0026#39;rust\u0026#39;, \u0026#39;phil\u0026#39;: \u0026#39;python\u0026#39;, } 可使⽤ get() ⽅法在指定的键不存在时返回⼀个默认值。get() ⽅ 法的第⼀个参数⽤于指定键，是必不可少的；第⼆个参数为当指定的键不 存在时要返回的值，是可选的：\n遍历字典的所有键值对\n1 2 3 4 5 6 7 8 9 user_0 = { \u0026#39;username\u0026#39;: \u0026#39;efermi\u0026#39;, \u0026#39;first\u0026#39;: \u0026#39;enrico\u0026#39;, \u0026#39;last\u0026#39;: \u0026#39;fermi\u0026#39;, } for key,value in user_0.items(): print(f\u0026#34;\\nKey:{key}) print(f\u0026#34;value:{value}\u0026#34;) 遍历字典中的所有键 keys()\n1 2 3 4 5 6 7 8 favorite_languages = { \u0026#39;jen\u0026#39;: \u0026#39;python\u0026#39;, \u0026#39;sarah\u0026#39;: \u0026#39;c\u0026#39;, \u0026#39;edward\u0026#39;: \u0026#39;rust\u0026#39;, \u0026#39;phil\u0026#39;: \u0026#39;python\u0026#39;, } for name in favorite_languages.keys(): print(name.title()) 遍历字典时，默认遍历所有的键\n遍历字典中的所有值，values()\n1 for language in set(favorite_languages.values()): 用set剔除重复项\n嵌套\n1 2 3 4 5 6 alien_0 = {\u0026#39;color\u0026#39;: \u0026#39;green\u0026#39;, \u0026#39;points\u0026#39;: 5} alien_1 = {\u0026#39;color\u0026#39;: \u0026#39;yellow\u0026#39;, \u0026#39;points\u0026#39;: 10} alien_2 = {\u0026#39;color\u0026#39;: \u0026#39;red\u0026#39;, \u0026#39;points\u0026#39;: 15} aliens = [alien_0, alien_1, alien_2] for alien in aliens: print(alien) 字典列表\n1 2 3 4 5 6 7 8 9 10 11 12 # 创建⼀个⽤于存储外星⼈的空列表 aliens = [] # 创建 30 个绿⾊的外星⼈ for alien_number in range(30): new_alien = {\u0026#39;color\u0026#39;: \u0026#39;green\u0026#39;, \u0026#39;points\u0026#39;: 5, \u0026#39;speed\u0026#39;: \u0026#39;slow\u0026#39;} aliens.append(new_alien) # 显⽰前 5 个外星⼈ for alien in aliens[:5]: print(alien) print(\u0026#34;...\u0026#34;) # 显⽰创建了多少个外星⼈ print(f\u0026#34;Total number of aliens: {len(aliens)}\u0026#34;) 在字典中存储列表\n1 2 3 4 5 6 7 8 9 # 存储顾客所点⽐萨的信息 pizza = { \u0026#39;crust\u0026#39;: \u0026#39;thick\u0026#39;, \u0026#39;toppings\u0026#39;: [\u0026#39;mushrooms\u0026#39;, \u0026#39;extra cheese\u0026#39;], } # 概述顾客点的⽐萨 print(f\u0026#34;You ordered a {pizza[\u0026#39;crust\u0026#39;]}-crust pizza \u0026#34; \u0026#34;with the following toppings:\u0026#34;) for topping in pizza[\u0026#39;toppings\u0026#39;]: print(f\u0026#34;\\t{topping}\u0026#34;) 在字典中存储字典\ninput()解读为字符串 int()获取数值输入\nfor 循环是⼀种遍历列表的有效⽅式，但不应该在 for 循环中修改列表， 否则将导致 Python 难以跟踪其中的元素。要在遍历列表的同时修改它，可 使⽤ while 循环。通过将 while 循环与列表和字典结合起来使⽤，可收 集、存储并组织⼤量的输⼊，供以后查看和使⽤。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 # ⾸先，创建⼀个待验证⽤户列表 # 和⼀个⽤于存储已验证⽤户的空列表 unconfirmed_users = [\u0026#39;alice\u0026#39;, \u0026#39;brian\u0026#39;, \u0026#39;candace\u0026#39;] confirmed_users = [] # 验证每个⽤户，直到没有未验证⽤户为⽌ # 将每个经过验证的⽤户都移到已验证⽤户列表中 while unconfirmed_users: current_user = unconfirmed_users.pop() print(f\u0026#34;Verifying user: {current_user.title()}\u0026#34;) confirmed_users.append(current_user) # 显⽰所有的已验证⽤户 print(\u0026#34;\\nThe following users have been confirmed:\u0026#34;) for confirmed_user in confirmed_users: print(confirmed_user.title()) 删除为特定值的所有列表元素\n1 2 3 4 5 pets = [\u0026#39;dog\u0026#39;, \u0026#39;cat\u0026#39;, \u0026#39;dog\u0026#39;, \u0026#39;goldfish\u0026#39;, \u0026#39;cat\u0026#39;, \u0026#39;rabbit\u0026#39;, \u0026#39;cat\u0026#39;] print(pets) while \u0026#39;cat\u0026#39; in pets: pets.remove(\u0026#39;cat\u0026#39;) print(pets) 使用用户输入填充字典\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 responses = {} # 设置⼀个标志，指出调查是否继续 polling_active = True while polling_active: # 提⽰输⼊被调查者的名字和回答 name = input(\u0026#34;\\nWhat is your name? \u0026#34;) response = input(\u0026#34;Which mountain would you like to climb someday?\u0026#34;) # 将回答存储在字典中 responses[name] = response # 看看是否还有⼈要参与调查 repeat = input(\u0026#34;Would you like to let another person respond?(yes/no) \u0026#34;) if repeat == \u0026#39;no\u0026#39;: polling_active = False # 调查结束，显⽰结果 print(\u0026#34;\\n--- Poll Results ---\u0026#34;) for name, response in responses.items(): print(f\u0026#34;{name} would like to climb {response}.\u0026#34;) 函数 \u0026ldquo;\u0026ldquo;\u0026ldquo;文档字符串\u0026rdquo;\u0026rdquo;\u0026rdquo; 位置实参\n关键字实参\n1 2 3 4 5 6 def describe_pet(animal_type, pet_name): \u0026#34;\u0026#34;\u0026#34;显⽰宠物的信息\u0026#34;\u0026#34;\u0026#34; print(f\u0026#34;\\nI have a {animal_type}.\u0026#34;) print(f\u0026#34;My {animal_type}\u0026#39;s name is {pet_name.title()}.\u0026#34;) describe_pet(animal_type=\u0026#39;hamster\u0026#39;, pet_name=\u0026#39;harry\u0026#39;) 默认值\n让实参变成可选的 为让中间名变成可选的，可给形参 middle_name 指 定默认值（空字符串），在⽤户不提供中间名时不使⽤这个形参。为了让 get_formatted_name() 在没有提供中间名时依然正确运⾏，可给形参 middle_name 指定默认值（空字符串），并将其移到形参列表的末尾 middle_name=\u0026rsquo;\u0026rsquo;\n返回字典\n传递列表\n1 2 3 4 5 6 7 8 def greet_users(names): \u0026#34;\u0026#34;\u0026#34;向列表中的每个⽤户发出简单的问候\u0026#34;\u0026#34;\u0026#34; for name in names: msg = f\u0026#34;Hello, {name.title()}!\u0026#34; print(msg) usernames = [\u0026#39;hannah\u0026#39;, \u0026#39;ty\u0026#39;, \u0026#39;margot\u0026#39;] greet_users(usernames) 传递任意数量的实参\n1 2 3 4 5 6 def make_pizza(*toppings): \u0026#34;\u0026#34;\u0026#34;打印顾客点的所有配料\u0026#34;\u0026#34;\u0026#34; print(toppings) make_pizza(\u0026#39;pepperoni\u0026#39;) make_pizza(\u0026#39;mushrooms\u0026#39;, \u0026#39;green peppers\u0026#39;, \u0026#39;extra cheese\u0026#39;) 形参名 *toppings 中的星号让 Python 创建⼀个名为 toppings 的元组， 该元组包含函数收到的所有值。函数体内的函数调⽤ print() ⽣成的输出 证明，Python 既能处理使⽤⼀个值调⽤函数的情形，也能处理使⽤三个值 调⽤函数的情形。它以类似的⽅式处理不同的调⽤。注意，Python 会将实 参封装到⼀个元组中，即便函数只收到⼀个值也是如此\n使⽤任意数量的关键字实参\n1 2 3 4 5 6 7 def build_profile(first, last, **user_info): \u0026#34;\u0026#34;\u0026#34;创建⼀个字典，其中包含我们知道的有关⽤户的⼀切\u0026#34;\u0026#34;\u0026#34; user_info[\u0026#39;first_name\u0026#39;] = first user_info[\u0026#39;last_name\u0026#39;] = last return user_info user_profile = build_profile(\u0026#39;albert\u0026#39;, \u0026#39;einstein\u0026#39;,location=\u0026#39;princeton\u0026#39;,field=\u0026#39;physics\u0026#39;) print(user_profile) build_profile() 函数的定义要求提供名和姓，同时允许根据需要提供 任意数量的名值对。形参 **user_info 中的两个星号让 Python 创建⼀个 名为 user_info 的字典，该字典包含函数收到的其他所有名值对。在这 个函数中，可以像访问其他字典那样访问 user_info 中的名值对。\n将函数存储在模块中 使⽤函数的优点之⼀是可将代码块与主程序分离。通过给函数指定描述性 名称，能让程序容易理解得多。你还可以更进⼀步，将函数存储在称为模 块的独⽴⽂件中，再将模块导⼊（import）主程序。import 语句可让你在 当前运⾏的程序⽂件中使⽤模块中的代码。\n导⼊特定的函数\n使⽤ as 给函数指定别名\n函数编写指南 在编写函数时，需要牢记⼏个细节。应给函数指定描述性名称，且只使⽤ ⼩写字⺟和下划线。描述性名称可帮助你和别⼈明⽩代码想要做什么。在 给模块命名时也应遵循上述约定。 在给形参指定默认值时，等号两边不要有空格\n面向对象编程：类\n创建Dog类\n1 2 3 4 5 6 7 8 9 10 11 12 class Dog: \u0026#34;\u0026#34;\u0026#34;⼀次模拟⼩狗的简单尝试\u0026#34;\u0026#34;\u0026#34; def __init__(self, name, age): \u0026#34;\u0026#34;\u0026#34;初始化属性 name 和 age\u0026#34;\u0026#34;\u0026#34; self.name = name self.age = age def sit(self): \u0026#34;\u0026#34;\u0026#34;模拟⼩狗收到命令时坐下\u0026#34;\u0026#34;\u0026#34; print(f\u0026#34;{self.name} is now sitting.\u0026#34;) def roll_over(self): \u0026#34;\u0026#34;\u0026#34;模拟⼩狗收到命令时打滚\u0026#34;\u0026#34;\u0026#34; print(f\u0026#34;{self.name} rolled over!\u0026#34;) init() ⽅法:是⼀个特殊⽅法，每当你根据 Dog 类创建新实例时，Python 都会⾃动运⾏ 它。在这个⽅法的名称中，开头和末尾各有两个下划线，这是⼀种约定， 旨在避免 Python 默认⽅法与普通⽅法发⽣名称冲突。务必确保 init() 的两边都有两个下划线，否则当你使⽤类来创建实例时，将 不会⾃动调⽤这个⽅法，进⽽引发难以发现的错误。 我们将 init() ⽅法定义成包含三个形参：self、name 和 age。在 这个⽅法的定义中，形参 self 必不可少，⽽且必须位于其他形参的前 ⾯。为何必须在⽅法定义中包含形参 self 呢？因为当 Python 调⽤这个⽅ 法来创建 Dog 实例时，将⾃动传⼊实参 self。每个与实例相关联的⽅法 调⽤都会⾃动传递实参 self，该实参是⼀个指向实例本⾝的引⽤，让实例 能够访问类中的属性和⽅法。 在 init() ⽅法内定义的两个变量都有前缀 self（⻅❸）。以self 为前缀的变量可供类中的所有⽅法使⽤，可以通过类的任意实例来访问。 self.name = name 获取与形参 name 相关联的值，并将其赋给变量 name，然后该变量被关联到当前创建的实例。self.age = age 的作⽤ 与此类似。像这样可通过实例访问的变量称为属性（attribute）。\n根据类创建实例\n1 2 3 my_dog = Dog(\u0026#39;Willie\u0026#39;, 6) print(f\u0026#34;My dog\u0026#39;s name is {my_dog.name}.\u0026#34;) print(f\u0026#34;My dog is {my_dog.age} years old.\u0026#34;) 给属性指定默认值 有些属性⽆须通过形参来定义，可以在 init() ⽅法中为其指定默认 值。 下⾯来添加⼀个名为 odometer_reading 的属性，其初始值总是为 0。我 们还添加了⼀个名为 read_odometer() 的⽅法，⽤于读取汽⻋的⾥程 表\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 class Car: def __init__(self, make, model, year): \u0026#34;\u0026#34;\u0026#34;初始化描述汽⻋的属性\u0026#34;\u0026#34;\u0026#34; self.make = make self.model = model self.year = year self.odometer_reading = 0 def get_descriptive_name(self): --snip-- ❷ def read_odometer(self): \u0026#34;\u0026#34;\u0026#34;打印⼀条指出汽⻋⾏驶⾥程的消息\u0026#34;\u0026#34;\u0026#34; print(f\u0026#34;This car has {self.odometer_reading} miles on it.\u0026#34;) my_new_car = Car(\u0026#39;audi\u0026#39;, \u0026#39;a4\u0026#39;, 2024) print(my_new_car.get_descriptive_name()) my_new_car.read_odometer() 修改属性的值\n1.直接修改属性的值 2.通过方法修改属性的值 3.通过方法让属性的值递增\n继承 当⼀个类继承另⼀个类时，将⾃动获 得后者的所有属性和⽅法。原有的类称为⽗类（parent class），⽽新类称为 ⼦类（child class）。⼦类不仅继承了⽗类的所有属性和⽅法，还可定义⾃ ⼰的属性和⽅法\n子类的_init_()方法 在既有的类的基础上编写新类，通常要调⽤⽗类的 init() ⽅法。这 将初始化在⽗类的 init() ⽅法中定义的所有属性，从⽽让⼦类也可 以使⽤这些属性。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 class Car: \u0026#34;\u0026#34;\u0026#34;⼀次模拟汽⻋的简单尝试\u0026#34;\u0026#34;\u0026#34; def __init__(self, make, model, year): \u0026#34;\u0026#34;\u0026#34;初始化描述汽⻋的属性\u0026#34;\u0026#34;\u0026#34; self.make = make self.model = model self.year = year self.odometer_reading = 0 def get_descriptive_name(self): \u0026#34;\u0026#34;\u0026#34;返回格式规范的描述性名称\u0026#34;\u0026#34;\u0026#34; long_name = f\u0026#34;{self.year} {self.make} {self.model}\u0026#34; return long_name.title() def read_odometer(self): \u0026#34;\u0026#34;\u0026#34;打印⼀个句⼦，指出汽⻋的⾏驶⾥程\u0026#34;\u0026#34;\u0026#34; print(f\u0026#34;This car has {self.odometer_reading} miles on it.\u0026#34;) def update_odometer(self, mileage): \u0026#34;\u0026#34;\u0026#34;将⾥程表读数设置为给定的值\u0026#34;\u0026#34;\u0026#34; if mileage \u0026gt;= self.odometer_reading: self.odometer_reading = mileage else: print(\u0026#34;You can\u0026#39;t roll back an odometer!\u0026#34;) def increment_odometer(self, miles): \u0026#34;\u0026#34;\u0026#34;让⾥程表读数增加给定的量\u0026#34;\u0026#34;\u0026#34; self.odometer_reading += miles class ElectricCar(Car): \u0026#34;\u0026#34;\u0026#34;电动汽⻋的独特之处\u0026#34;\u0026#34;\u0026#34; def __init__(self, make, model, year): \u0026#34;\u0026#34;\u0026#34;初始化⽗类的属性\u0026#34;\u0026#34;\u0026#34; super().__init__(make, model, year) my_leaf = ElectricCar(\u0026#39;nissan\u0026#39;, \u0026#39;leaf\u0026#39;, 2024) print(my_leaf.get_descriptive_name()) ⾸先是 Car 类的代码（⻅❶）。在创建⼦类时，⽗类必须包含在当前⽂件 中，且位于⼦类前⾯。接下来，定义⼦类 ElectricCar（⻅❷）。在定义 ⼦类时，必须在括号内指定⽗类的名称。init() ⽅法接受创建 Car 实例所需的信息（⻅❸）。 super() 是⼀个特殊的函数，让你能够调⽤⽗类的⽅法（⻅❹）。这⾏代 码让 Python 调⽤ Car 类的 init() ⽅法，从⽽让 ElectricCar 实 例包含这个⽅法定义的所有属性。⽗类也称为超类（superclass），函数名 super 由此得名。 为了测试继承能够正确地发挥作⽤，我们尝试创建⼀辆电动汽⻋，但提供 的信息与创建燃油汽⻋时相同。在❺处，创建 ElectricCar 类的⼀个实 例，并将其赋给变量 my_leaf。这⾏代码调⽤ ElectricCar 类中定义的 init() ⽅法，后者让 Python 调⽤⽗类 Car 中定义的 init() ⽅法。我们提供了实参 \u0026rsquo;nissan\u0026rsquo;、\u0026rsquo;leaf\u0026rsquo; 和 2024\n给子类定义属性和方法 让⼀个类继承另⼀个类后，就可以添加区分⼦类和⽗类所需的新属性和新 ⽅法了。 下⾯添加⼀个电动汽⻋特有的属性（电池），以及⼀个描述该属性的⽅ 法。我们将存储电池容量，并编写⼀个⽅法打印对电池的描述\n重写父类中的方法\n将实例用作属性 在使⽤代码模拟实物时，你可能会发现⾃⼰给类添加了太多细节：属性和 ⽅法越来越多，⽂件越来越⻓。在这种情况下，可能需要将类的⼀部分提 取出来，作为⼀个独⽴的类。将⼤型类拆分成多个协同⼯作的⼩类，这种 ⽅法称为组合（composition）。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 class Car: --snip-- class Battery: \u0026#34;\u0026#34;\u0026#34;⼀次模拟电动汽⻋电池的简单尝试\u0026#34;\u0026#34;\u0026#34; def __init__(self, battery_size=40): \u0026#34;\u0026#34;\u0026#34;初始化电池的属性\u0026#34;\u0026#34;\u0026#34; self.battery_size = battery_size def describe_battery(self): \u0026#34;\u0026#34;\u0026#34;打印⼀条描述电池容量的消息\u0026#34;\u0026#34;\u0026#34; print(f\u0026#34;This car has a {self.battery_size}-kWh battery.\u0026#34;) class ElectricCar(Car): \u0026#34;\u0026#34;\u0026#34;电动汽⻋的独特之处\u0026#34;\u0026#34;\u0026#34; def __init__(self, make, model, year): \u0026#34;\u0026#34;\u0026#34; 先初始化⽗类的属性，再初始化电动汽⻋特有的属性 \u0026#34;\u0026#34;\u0026#34; super().__init__(make, model, year) self.battery = Battery() my_leaf = ElectricCar(\u0026#39;nissan\u0026#39;, \u0026#39;leaf\u0026#39;, 2024) print(my_leaf.get_descriptive_name()) my_leaf.battery.describe_battery() 模拟实物 这让你进⼊了程序员的另⼀个境界：在解决上述问题时，从较⾼的逻辑层 ⾯（⽽不是语法层⾯）思考。你考虑的不是 Python，⽽是如何使⽤代码来 表⽰实际事物。达到这种境界后，你会经常发现，对现实世界的建模⽅法 没有对错之分。有些⽅法的效率更⾼，但要找出效率最⾼的表⽰法，需要 ⼀定的实践。只要代码能够像你希望的那样运⾏，就说明你已经做得很好 了！即便发现⾃⼰不得不多次尝试使⽤不同的⽅法来重写类，也不必⽓ 馁。要编写出⾼效、准确的代码，这是必经之路\n导入类 模块级⽂档字符串，对该模块的内容做了简要的描述。你应该 为⾃⼰创建的每个模块编写⽂档字符串。\n导⼊类是⼀种⾼效的编程⽅式。如果这个程序包含整个 Class 类，它该有 多⻓啊！通过将这个类移到⼀个模块中并导⼊该模块，依然可使⽤其所有 功能，但主程序⽂件变得整洁易读了。这还让你能够将⼤部分逻辑存储在 独⽴的⽂件中。在确定类能像你希望的那样⼯作后，就可以不管这些⽂ 件，专注于主程序的⾼级逻辑了\n在一个模块中存储多个类\n从一个模块中导入多个类\n导入整个模块 先导⼊整个模块，再使⽤点号访问需要的类\n导入模块中的所有类\n使用别名\n找到合适的工作流程 ⼀开始应让代码结构尽量简单。⾸先尝试在⼀个⽂件中完成所有的⼯作， 确定⼀切都能正确运⾏后，再将类移到独⽴的模块中。如果你喜欢模块和 ⽂件的交互⽅式，可在项⽬开始时就尝试将类存储到模块中。先找出让你 能够编写出可⾏代码的⽅式，再尝试让代码更加整洁\npython标准库 randint()它将两个整数作为参数， 并随机返回⼀个位于这两个整数之间（含）的整数。下⾯演⽰了如何⽣成 ⼀个位于 1 和 6 之间的随机整数\n1 2 3 from random import randint randint(1, 6) 3 choice()它将⼀个列表或 元组作为参数，并随机返回其中的⼀个元素：\n1 2 3 4 5 from random import choice players = [\u0026#39;charles\u0026#39;, \u0026#39;martina\u0026#39;, \u0026#39;michael\u0026#39;, \u0026#39;florence\u0026#39;, \u0026#39;eli\u0026#39;] first_up = choice(players) first_up \u0026#39;florence 在创建与安全相关的应⽤程序时，不要使⽤模块 random，但它能⽤来创建 众多有趣的项⽬。\n类的编程风格 类名应采⽤驼峰命名法，即将类名中的每个单词的⾸字⺟都⼤写，并且不 使⽤下划线。实例名和模块名都采⽤全⼩写格式，并在单词之间加上下划 线。\n可以使⽤空⾏来组织代码，但不宜过多。在类中，可以使⽤⼀个空⾏来分 隔⽅法；⽽在模块中，可以使⽤两个空⾏来分隔类。 当需要同时导⼊标准库中的模块和你编写的模块时，先编写导⼊标准库模 块的 import 语句，再添加⼀个空⾏，然后编写导⼊你⾃⼰编写的模块的 import 语句。在包含多条 import 语句的程序中，这种做法让⼈更容易 明⽩程序使⽤的各个模块来⾃哪⾥。\n文件和异常\n要使⽤⽂件的内容，需要将其路径告知 Python。路径（path）指的是⽂件或 ⽂件夹在系统中的准确位置。Python 提供了 pathlib 模块，让你能够更轻 松地在各种操作系统中处理⽂件和⽬录。提供特定功能的模块通常称为库 （library）。这就是这个模块被命名为 pathlib 的原因所在 这⾥⾸先从 pathlib 模块导⼊ Path 类。Path 对象指向⼀个⽂件，可⽤ 来做很多事情。例如，让你在使⽤⽂件前核实它是否存在，读取⽂件的内 容，以及将新数据写⼊⽂件。这⾥创建了⼀个表⽰⽂件 pi_digits.txt 的 Path 对象，并将其赋给了变量 path（⻅❶）。由于这个⽂件与当前编写 的 .py ⽂件位于同⼀个⽬录中，因此 Path 只需要知道其⽂件名就能访问 它。\n1 2 3 4 5 from pathlib import Path path = Path(\u0026#39;pi_digits.txt\u0026#39;) contents = path.read_text() print(contents) read_text() 将该⽂件的全部内容作为⼀个字符串返回,read_text() 在到达⽂件末尾时会返回⼀个空字符串，⽽这个空字符串会被显⽰为⼀个空⾏。\n方法链式调用 这⾏代码先让 Python 对当前处理的⽂件调⽤ read_text() ⽅法，再对 read_text() 返回的字符串调⽤ rstrip() ⽅法，然后将整理好的字符 串赋给变量 contents。\n1 contents = path.read_text().rstrip() 相对文件路径和绝对文件路径\n访问文件中的各行 使⽤ splitlines() ⽅法将冗⻓的字符串转换为⼀系列⾏，再使⽤ for 循环以每次⼀⾏的⽅式检查⽂件中的各⾏：\n1 2 3 4 5 6 7 from pathlib import Path path = Path(\u0026#39;pi_digits.txt\u0026#39;) contents = path.read_text() lines = contents.splitlines() for line in lines: print(line) splitlines() ⽅法返回⼀个列 表，其中包含⽂件中所有的⾏，⽽我们将这个列表赋给了变量 lines\n使用文件的内容 注意：在读取⽂本⽂件时，Python 将其中的所有⽂本都解释为字符 串。如果读取的是数，并且要将其作为数值使⽤，就必须使⽤ int() 函数将其转换为整数，或者使⽤ float() 函数将其转换为浮点数。\n写入文件\n写入一行 定义⼀个⽂件的路径后，就可使⽤ write_text() 将数据写⼊该⽂件了\n注意：Python 只能将字符串写⼊⽂本⽂件。如果要将数值数据存储到 ⽂本⽂件中，必须先使⽤函数 str() 将其转换为字符串格式。\n写入多行 write_text() ⽅法会在幕后完成⼏项⼯作。⾸先，如果 path 变量对应 的路径指向的⽂件不存在，就创建它。其次，将字符串写⼊⽂件后，它会 确保⽂件得以妥善地关闭。如果没有妥善地关闭⽂件，可能会导致数据丢 失或受损。\n1 2 3 4 5 6 7 from pathlib import Path contents = \u0026#34;I love programming.\\n\u0026#34; contents += \u0026#34;I love creating new games.\\n\u0026#34; contents += \u0026#34;I also love working with data.\\n\u0026#34; path = Path(\u0026#39;programming.txt\u0026#39;) path.write_text(contents) 注意：在对 path 对象调⽤ write_text() ⽅法时，务必谨慎。如果 指定的⽂件已存在， write_text() 将删除其内容，并将指定的内容 写⼊其中。\n异常 Python 使⽤称为异常（exception）的特殊对象来管理程序执⾏期间发⽣的 错误。每当发⽣让 Python 不知所措的错误时，它都会创建⼀个异常对象。 如果你编写了处理该异常的代码，程序将继续运⾏；如果你未对异常进⾏ 处理，程序将停⽌，并显⽰⼀个 traceback，其中包含有关异常的报告。\n使用try-except代码块\n1 2 3 4 try: print(5/0) except ZeroDivisionError: print(\u0026#34;You can\u0026#39;t divide by zero!\u0026#34;) else代码块 这个⽰例还包含⼀个 else 代码块，只有 try 代码块成功执⾏才需要继续执⾏的代码，都应放到 else 代码块中\n1 2 3 4 5 6 7 8 9 10 11 --snip-- while True: --snip-- if second_number == \u0026#39;q\u0026#39;: break try: answer = int(first_number) / int(second_number) except ZeroDivisionError: print(\u0026#34;You can\u0026#39;t divide by 0!\u0026#34;) else: print(answer) 依赖 try 代码块成功执⾏的代码都被放在else 代码块中\n只有可能引发异常的代码才需要放在 try 语句中。有时候，有⼀些仅在 try 代码块成功执⾏时才需要运⾏的代码，这些代码应放在 else 代码块 中。except 代码块告诉 Python，如果在尝试运⾏ try 代码块中的代码时 引发了指定的异常该怎么办\n分析文本 使⽤ split() ⽅法，它默认以空⽩为分隔符将字符串分拆成多个部分\n1 2 3 4 5 6 7 8 9 10 11 from pathlib import Path path = Path(\u0026#39;alice.txt\u0026#39;) try: contents = path.read_text(encoding=\u0026#39;utf-8\u0026#39;) except FileNotFoundError: print(f\u0026#34;Sorry, the file {path} does not exist.\u0026#34;) else: #计算⽂件⼤致包含多少个单词 words = contents.split() num_words = len(words) print(f\u0026#34;The file {path} has about {num_words} words.\u0026#34;) 使用多个文件\n1 2 3 4 5 6 7 8 from pathlib import Path def count_words(filename): --snip-- filenames = [\u0026#39;alice.txt\u0026#39;, \u0026#39;siddhartha.txt\u0026#39;, \u0026#39;moby_dick.txt\u0026#39;, \u0026#39;little_women.txt\u0026#39;] for filename in filenames: path = Path(filename) count_words(path) 静默失败 但并⾮每次捕获异常都需要告诉⽤户，你有时候希望程序在发⽣异常时保持静默，就像什么都 没有发⽣⼀样继续运⾏。\n1 2 3 4 5 6 7 8 def count_words(path): \u0026#34;\u0026#34;\u0026#34;计算⼀个⽂件⼤致包含多少个单词\u0026#34;\u0026#34;\u0026#34; try: --snip-- except FileNotFoundError: pass else: --snip-- 存储数据 json.dumps() 函数接受⼀个实参，即要转换为 JSON 格式的数据。这个函数返回⼀个字符串\n1 2 3 4 5 6 7 from pathlib import Path import json numbers = [2,3,5,7,11,13] path = Path(\u0026#39;numbers.json\u0026#39;) contents = json.dumps(numbers) path.write_text(contents) 使⽤ json.loads() 将这个列表读取到内存中\n1 2 3 4 5 6 7 8 from pathlib import Path import json path = Path(\u0026#39;numbers.json\u0026#39;) contents = path.read_text() numbers = json.loads(contents) print(numbers) Path 类提供了很多很有⽤的⽅法。如果指定的⽂件或⽂件夹存在， exists() ⽅法返回 True，否则返回 False。这⾥使⽤ path.exists() 来确定是否存储了⽤户名（⻅❶）。如果⽂件 username.json 存在，就加载其中的⽤户名，并向⽤户发出个性化问候。\n测试代码 学习如何使⽤ pytest 来测试代码。pytest 库是⼀组⼯ 具，不仅能帮助你快速⽽轻松地编写测试，⽽且能持续⽀持随项⽬增⼤⽽ 变得复杂的测试。Python 默认不包含 pytest，因此你将学习如何安装外 部库\n测试函数 所幸 pytest 提供了⼀种⾃动测试函数输出的⾼效⽅式\n单元测试和测试用例 断言\n1 2 3 4 5 6 from name_function import get_formatted_name def test_first_last_name(): \u0026#34;\u0026#34;\u0026#34;能够正确地处理像 Janis Joplin 这样的姓名吗？\u0026#34;\u0026#34;\u0026#34; formatted_name = get_formatted_name(\u0026#39;janis\u0026#39;, \u0026#39;joplin\u0026#39;) assert formatted_name == \u0026#39;Janis Joplin\u0026#39; 测试⽂件的名称很重要，必须以test_打头。当你让 pytest 运⾏测试时，它将查找以 test_打头的⽂件，并运⾏其中的所有测试\n运行测试 如果直接运⾏⽂件 test_name_function.py，将不会有任何输出，因为我们没 有调⽤这个测试函数。相反，应该让 pytest 替我们运⾏这个测试⽂件。 为此，打开⼀个终端窗⼝，并切换到这个测试⽂件所在的⽂件夹。如果你 使⽤的是 VS Code，可打开测试⽂件所在的⽂件夹，并使⽤该编辑器内嵌 的终端。在终端窗⼝中执⾏命令 pytest\n通过\n$ pytest\r========================= test session starts\r=========================\r❶ platform darwin -- Python 3.x.x, pytest-7.x.x, pluggy-1.x.x\r❷ rootdir: /.../python_work/chapter_11\r❸ collected 1 item\r❹ test_name_function.py . [100%]\r========================== 1 passed in 0.00s\r==========================\r不通过\n$ pytest\r========================= test session starts\r=========================\r--snip--\r❶ test_name_function.py F [100%]\r❷ ============================== FAILURES\r===============================\r❸ ________________________ test_first_last_name\r_________________________\rdef test_first_last_name():\r\u0026quot;\u0026quot;\u0026quot;能够正确地处理像 Janis Joplin 这样的姓名吗?\u0026quot;\u0026quot;\u0026quot;\r❹ \u0026gt; formatted_name = get_formatted_name('janis', 'joplin')\r❺ E TypeError: get_formatted_name() missing 1 required positional\rargument: 'last'\rtest_name_function.py:5: TypeError\r======================= short test summary info\r=======================\rFAILED test_name_function.py::test_first_last_name - TypeError:\rget_formatted_name() missing 1 required positional argument:\r'last'\r========================== 1 failed in 0.04s\r==========================\r测试类 断言 使用夹具 在测试中，夹具（fixture）可帮助我们搭建测试环境。这通常意味着创建供 多个测试使⽤的资源。在 pytest 中，要创建夹具，可编写⼀个使⽤装饰 器 @pytest.fixture 装饰的函数。装饰器（decorator）是放在函数定义 前⾯的指令。在运⾏函数前，Python 将该指令应⽤于函数，以修改函数代 码的⾏为。这听起来很复杂，但是不⽤担⼼：即便没有学习如何编写装饰 器，也可使⽤第三⽅包中的装饰器\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 import pytest from survey import AnonymousSurvey @pytest.fixture def language_survey(): \u0026#34;\u0026#34;\u0026#34;⼀个可供所有测试函数使⽤的 AnonymousSurvey 实例\u0026#34;\u0026#34;\u0026#34; question = \u0026#34;What language did you first learn to speak?\u0026#34; language_survey = AnonymousSurvey(question) return language_survey def test_store_single_response(language_survey): \u0026#34;\u0026#34;\u0026#34;测试单个答案会被妥善地存储\u0026#34;\u0026#34;\u0026#34; language_survey.store_response(\u0026#39;English\u0026#39;) assert \u0026#39;English\u0026#39; in language_survey.responses def test_store_three_responses(language_survey): \u0026#34;\u0026#34;\u0026#34;测试三个答案会被妥善地存储\u0026#34;\u0026#34;\u0026#34; responses = [\u0026#39;English\u0026#39;, \u0026#39;Spanish\u0026#39;, \u0026#39;Mandarin\u0026#39;] for response in responses: language_survey.store_response(response) for response in responses: assert response in language_survey.responses 现在需要导⼊ pytest，因为我们使⽤了其中定义的⼀个装饰器。我们将装 饰器 @pytest.fixture（⻅❶）应⽤于新函数language_survey() （⻅❷）。这个函数创建并返回⼀个AnonymousSurvey 对象 请注意，两个测试函数的定义都变了（⻅❸和❺）：都有⼀个名为 language_survey 的形参。当测试函数的⼀个形参与应⽤了装饰器 @pytest.fixture 的函数（夹具）同名时，将⾃动运⾏夹具，并将夹具 返回的值传递给测试函数。在这个⽰例中，language_survey() 函数向 test_store_single_response() 和test_store_three_responses() 提供了⼀个 language_survey 实例。\n##使用Git进行版本控制\n安装Git\n配置Git\n创建项目 我们来创建⼀个要进⾏版本控制的项⽬。在系统中创建⼀个⽂件夹，并将 其命名为 git_practice。\n忽略文件 扩展名为 .pyc 的⽂件是根据 .py ⽂件⾃动⽣成的，因此⽆须让 Git 跟踪它 们。这些⽂件存储在⽬录 pycache 中。为了让 Git 忽略这个⽬录，创建 ⼀个名为 .gitignore 的特殊⽂件（这个⽂件名以句点打头，且没有扩展 名），并在其中添加如下⼀⾏内容 这会让 Git 忽略⽬录 pycache 中的所有⽂件。使⽤⽂件 .gitignore 可避 免混乱，让项⽬开发起来更容易。 你可能需要修改⽂件浏览器的设置，使其显⽰隐藏的⽂件（名称以句点打 头的⽂件）：在 Windows 资源管理器中，选择菜单“查看”中的复选框“隐藏 的项⽬”；在 macOS 系统中，按组合键 Command + Shift + .（句点）；在 Linux 系统中，查找并选择设置 Show Hidden Files（显⽰隐藏的⽂件）\n初始化仓库 前⾯创建了⼀个⽬录，其中包含⼀个 Python ⽂件和⼀个 .gitignore ⽂件，现 在可以初始化⼀个 Git 仓库了。为此，打开⼀个终端窗⼝，切换到⽂件夹 git_practice，并执⾏如下命令：\ngit_practice$ git init\rInitialized empty Git repository in git_practice/.git/\rgit_practice$\r输出表明 Git 在 git_practice 中初始化了⼀个空仓库。仓库（repository）是 程序中被 Git 主动跟踪的⼀组⽂件。Git ⽤来管理仓库的⽂件都存储在隐藏 的⽬录 .git 中。虽然你根本不需要与这个⽬录打交道，但千万不要删除它， 否则将丢失项⽬的所有历史记录。\n检查状态\ngit_practice$ git status\r❶ On branch main\rNo commits yet\r❷ Untracked files:\r(use \u0026quot;git add \u0026lt;file\u0026gt;...\u0026quot; to include in what will be committed)\r.gitignore\rhello_git.py\r❸ nothing added to commit but untracked files present (use \u0026quot;git add\u0026quot; to\rtrack)\rgit_practice$\r在 Git 中，分⽀（branch）是项⽬的⼀个版本。从这⾥的输出可知，我们位 于分⽀ main 上（⻅❶）。每当查看项⽬的状态时，输出都将指出位于分⽀ main 上。接下来的输出表明，还未执⾏任何提交。提交（commit）是项⽬ 在特定时间点的快照 Git 指出了项⽬中未被跟踪的⽂件（⻅❷），因为还没有告诉它要跟踪哪些 ⽂件。接下来，Git 告诉我们没有将任何东⻄添加到当前的提交中，并且指 出了可能需要加⼊仓库的未跟踪⽂件（⻅❸）\n将文件加入仓库\n❶ git_practice$ git add .\r❷ git_practice$ git status\rOn branch main\rNo commits yet\rChanges to be committed:\r(use \u0026quot;git rm --cached \u0026lt;file\u0026gt;...\u0026quot; to unstage)\r❸ new file: .gitignore\rnew file: hello_git.py\rgit_practice$\r命令 git add . 将项⽬中未被跟踪的所有⽂件（条件是没有在 .gitignore 中列出）都加⼊仓库（⻅❶）。它不提交这些⽂件，只是让 Git 关注它们。 现在检查项⽬的状态，会发现 Git 找出了⼀些需要提交的修改（⻅❷）。 new file 意味着这些⽂件是新添加到仓库中的（⻅❸）。\n执行提交\n❶ git_practice$ git commit -m \u0026quot;Started project.\u0026quot;\r❷ [main (root-commit) cea13dd] Started project.\r❸ 2 files changed, 5 insertions(+)\rcreate mode 100644 .gitignore\rcreate mode 100644 hello_git.py\r❹ git_practice$ git status\rOn branch main\rnothing to commit, working tree clean\rgit_practice$\r我们执⾏命令 git commit -m \u0026ldquo;message\u0026rdquo;（⻅❶）创建项⽬的快照。 标志 -m 让 Git 将接下来的消息（Started project.）记录到项⽬的历 史记录中。输出表明我们位于分⽀ main 上（⻅❷）且有两个⽂件被修改了 （⻅❸）。 现在检查状态，将发现我们位于分⽀ main 上且⼯作树是⼲净的（⻅❹）。 这是在每次提交项⽬的可⾏状态时都应该看到的消息。如果显⽰的消息不 是这样的，请仔细阅读，很可能是你在提交前忘记了添加⽂件\n查看提交历史 git log\n每次提交时，Git 都会⽣成⼀个独⼀⽆⼆的引⽤ ID，⻓度为 40 个字符。它 记录提交是谁执⾏的，提交的时间，以及提交时指定的消息。并⾮在任何 情况下都需要所有这些信息，因此 Git 提供了⼀个选项，让你能够打印提交 历史条⽬的简单版本\ngit log \u0026ndash;pretty=oneline 标志 \u0026ndash;pretty=oneline 指定显⽰两项最重要的信息：提交的引⽤ ID， 以及为提交记录的消息\n放弃修改 下⾯来看看如何放弃所做的修改，恢复到上⼀个可⾏状态 Git 注意到我们修改了 hello_git.py（⻅❶）。如果愿意，可以提交所做的修 改，但这次我们不提交所做的修改，⽽是恢复到最后⼀个提交（我们知 道，那次提交时项⽬能够正常地运⾏）。为此，我们不对 hello_git.py 执⾏ 任何操作（既不删除刚添加的代码⾏，也不使⽤⽂本编辑器的撤销功 能），⽽是在终端会话中执⾏如下命令 git_practice$ git restore git_practice$ git status\n在这个简单的项⽬中，恢复到之前某个状态的能⼒看似微不⾜道，但如果 开发的是⼤型项⽬，其中数⼗个⽂件都被修改了，那么通过恢复到上⼀个 状态，将撤销最后⼀次提交后对这些⽂件所做的所有修改。这个功能很有 ⽤：在实现新功能时，可根据需要做任意数量的修改；如果这些修改不可 ⾏，可撤销它们，⽽不会影响项⽬。你⽆须记住做了哪些修改并⼿动撤销 所做的修改，Git 会替你完成所有这些⼯作\n检出以前的提交 要检出提交历史中的任何提交，可使⽤命令 checkout，并指定该提交的 引⽤ ID 的前 6 个字符。检出并检查以前的提交后，既可以返回最后⼀次提 交，也可以放弃最近所做的⼯作并选择以前的提交 检出以前的提交后，将离开分⽀ main，并进⼊ Git 所说的分离头指针 （detached HEAD）状态（⻅❶）。HEAD 表⽰当前提交的项⽬状态。之所 以说处于分离状态（detached），是因为离开了⼀个具名分⽀（这⾥是 main）。 要回到分⽀ main，可按建议（⻅❷）所说的那样撤销上⼀个操作 这样就回到分⽀ main 了。除⾮要使⽤ Git 的⾼级功能，否则在检出以前的 提交后，最好不要对项⽬做任何修改。然⽽，如果参与项⽬开发的⼈只有 你⾃⼰，⽽你⼜想放弃最近的所有提交并恢复到以前的状态，也可将项⽬ 重置到以前的提交。\n删除仓库 有时候，仓库的历史记录被弄乱了，⽽你⼜不知道如何恢复。在这种情况 下，⾸先应考虑使⽤附录 C 介绍的⽅法寻求帮助。如果⽆法恢复且参与项 ⽬开发的只有你⼀个⼈，可继续使⽤这些⽂件，但将项⽬的历史记录删除 ——删除⽬录 .git。这不会影响任何⽂件的当前状态，只会删除所有的提 交，因此将⽆法检出项⽬的其他任何状态。 为此，既可以打开⼀个⽂件浏览器并将⽬录 .git 删除，也可以通过命令⾏将 其删除。之后，需要重新创建⼀个仓库，以便重新对修改进⾏跟踪。\n##项目 外星人入侵 规划项⽬ 这个游戏由 run_game() ⽅法控制。该⽅法包含⼀个不断运⾏的 while 循环（⻅❸），⽽这个循环包含⼀个事件循环以及管理屏幕更新的代码。 事件是⽤户玩游戏时执⾏的操作，如按键或移动⿏标。为了让程序能够响 应事件，可编写⼀个事件循环，以侦听事件并根据发⽣的事件类型执⾏适 当的任务\n我们使⽤ pygame.event.get() 函数来访问 Pygame 检测到的事件。这 个函数返回⼀个列表，其中包含它在上⼀次调⽤后发⽣的所有事件。所有 键盘和⿏标事件都将导致这个 for 循环运⾏。在这个循环中，我们将编写 ⼀系列 if 语句来检测并响应特定的事件。例如，当玩家单击游戏窗⼝的关 闭按钮时，将检测到 pygame.QUIT 事件，进⽽调⽤ sys.exit() 来退出 游戏\n处调⽤了pygame.display.flip()，命令 Pygame 让最近绘制的屏幕 可⻅。这⾥，它在每次执⾏ while 循环时都绘制⼀个空屏幕，并擦去旧屏 幕，使得只有新的空屏幕可⻅。我们在移动游戏元素时， pygame.display.flip() 将不断更新屏幕，以显⽰新位置上的元素并隐 藏原来位置上的元素，从⽽营造平滑移动的效果\n在这个⽂件末尾，创建⼀个游戏实例并调⽤ run_game()。这些代码被放 在⼀个 if 代码块中，仅当直接运⾏该⽂件时，它们才会执⾏。如果此时运 ⾏ alien_invasion.py，将看到⼀个空的 Pygame 窗⼝\n理想情况下，游戏在所有的系统中都应以相同的速度（帧率）运⾏。对于 可在多种系统中运⾏的游戏，控制帧率是个复杂的问题，好在 Pygame 提供 了⼀种相对简单的⽅式来达成这个⽬标。我们将创建⼀个时钟（clock）， 并确保它在主循环每次通过后都进⾏计时（tick）。当这个循环的通过速度 超过我们定义的帧率时，Pygame 会计算需要暂停多⻓时间，以便游戏的运 ⾏速度保持⼀致\ntick() ⽅法接受⼀个参数：游戏的帧率。这⾥使⽤的值为 60， Pygame 将 尽可能确保这个循环每秒恰好运⾏ 60 次。\n需要先加载⼀幅图像，再使⽤ Pygame blit() ⽅法绘制它。 最安全、成本最低的⽅式是使⽤ OpenGameArt 等⽹站提供的免费图形，这些素材⽆须授权许可即可使⽤和修改\n在游戏中，可以使⽤⼏乎任意类型的图像⽂件，但使⽤位图（.bmp）⽂件 最为简单，因为 Pygame 默认加载位图。虽然可配置 Pygame 以使⽤其他⽂ 件类型，但有些⽂件类型要求你在计算机上安装相应的图像库。⽹上的⼤ 多数图像是 .jpg 和 .png 格式的，不过可以使⽤ Photoshop、GIMP 和 Paint等⼯具将其转换为位图。\npygame 之所以⾼效，是因为它让你能够把所有的游戏元素当作矩形（rect 对象）来处理，即便它们的形状并⾮矩形也⼀样。⽽把游戏元素当作矩形 来处理之所以⾼效，是因为矩形是简单的⼏何形状。例如，通过将游戏元 素视为矩形，Pygame 能够更快地判断出它们是否发⽣了碰撞。这种做法的 效果通常很好，游戏玩家⼏乎注意不到我们处理的不是游戏元素的实际形 状。在这个类中，我们将把⻜船和屏幕作为矩形进⾏处理\n在处理 rect 对象时，可使⽤矩形的四个⾓及中⼼的 x 坐标和 y 坐标，通过 设置这些值来指定矩形的位置。如果要将游戏元素居中，可设置相应 rect 对象的属性 center、centerx 或 centery；要让游戏元素与屏幕边缘对 ⻬，可设置属性 top、bottom、left 或 right。除此之外，还有⼀些组 合属性，如 midbottom、midtop、midleft 和 midright。要调整游戏 元素的⽔平或垂直位置，可使⽤属性 x 和 y，它们分别是相应矩形左上⾓ 的 x 坐标和 y 坐标。这些属性让你⽆须去做游戏开发⼈员原本需要⼿动完 成的计算，因此很常⽤\n在 Pygame 中，原点(0, 0)位于屏幕的左上⾓，当⼀个点向右下 ⽅移动时，它的坐标值将增⼤。在 1200×800 的屏幕上，原点位于左上 ⾓，右下⾓的坐标为(1200, 800)。这些坐标对应的是游戏窗⼝，⽽不是 物理屏幕。\n##重构：_check_events() ⽅法和_update_screen() ⽅法 在⼤型项⽬中，经常需要在添加新代码前重构既有的代码。重构旨在简化 既有代码的结构，使其更容易扩展。本节将把越来越⻓的 run_game() ⽅ 法拆分成两个辅助⽅法。辅助⽅法（helper method）⼀般只在类中调⽤，不 会在类外调⽤。在 Python 中，辅助⽅法的名称以单下划线打头\n","date":"2024-03-17T13:35:01+08:00","permalink":"http://localhost:1313/p/python/","title":"python"},{"content":"\n我打开圣经，上面第一句话就是就是\u0026quot;Hello World\u0026quot;\n","date":"2024-03-17T13:28:01+08:00","permalink":"http://localhost:1313/p/my-first-post/","title":"My First Post"}]