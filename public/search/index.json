[{"content":"\r# Tmux 是一个终端复用器（terminal multiplexer），非常有用，属于常用的开发工具\r是什么 会话于进程 命令行的典型使用方式是，打开一个终端窗口（terminal window，以下简称\u0026quot;窗口\u0026quot;），在里面输入命令。用户与计算机的这种临时的交互，称为一次\u0026quot;会话\u0026quot;（session） 。\n会话的一个重要特点是，窗口与其中启动的进程是连在一起的。打开窗口，会话开始；关闭窗口，会话结束，会话内部的进程也会随之终止，不管有没有运行完。\n一个典型的例子就是，SSH 登录远程计算机，打开一个远程窗口执行命令。这时，网络突然断线，再次登录的时候，是找不回上一次执行的命令的。因为上一次 SSH 会话已经终止了，里面的进程也随之消失了。\n为了解决这个问题，会话与窗口可以\u0026quot;解绑\u0026quot;：窗口关闭时，会话并不终止，而是继续运行，等到以后需要的时候，再让会话\u0026quot;绑定\u0026quot;其他窗口\nTmux的作用 Tmux 就是会话与窗口的\u0026quot;解绑\u0026quot;工具，将它们彻底分离。\n它允许在单个窗口中，同时访问多个会话。这对于同时运行多个命令行程序很用。\n它可以让新窗口\u0026quot;接入\u0026quot;已经存在的会话。\n它允许每个会话有多个连接窗口，因此可以多人实时共享会话。\n它还支持窗口任意的垂直和水平拆分。\n类似的终端复用器还有 GNU Screen。Tmux 与它功能相似，但是更易用，也更强大。\n基本用法 安装 # Ubuntu 或 Debian\r$ sudo apt-get install tmux\r# CentOS 或 Fedora\r$ sudo yum install tmux\r# Mac\r$ brew install tmux\r启动与退出 安装完成后，键入tmux命令，就进入了 Tmux 窗口\n上面命令会启动 Tmux 窗口，底部有一个状态栏。状态栏的左侧是窗口信息（编号和名称），右侧是系统信息\n按下Ctrl+d或者显式输入exit命令，就可以退出 Tmux 窗口。\n前缀键 Tmux 窗口有大量的快捷键。所有快捷键都要通过前缀键唤起。默认的前缀键是Ctrl+b，即先按下Ctrl+b，快捷键才会生效。\n举例来说，帮助命令的快捷键是Ctrl+b ?它的用法是，在 Tmux 窗口中，先按下Ctrl+b，再按下?，就会显示帮助信息。\n然后，按下 ESC 键或q键，就可以退出帮助。\n会话管理 新建会话 第一个启动的 Tmux 窗口，编号是0，第二个窗口的编号是1，以此类推。这些窗口对应的会话，就是 0 号会话、1 号会话。\n使用编号区分会话，不太直观，更好的方法是为会话起名\n$ tmux new -s 上面命令新建一个指定名称的会话\n分离会话 在 Tmux 窗口中，按下Ctrl+b d或者输入tmux detach命令，就会将当前会话与窗口分离。\n上面命令执行后，就会退出当前 Tmux 窗口，但是会话和里面的进程仍然在后台运行。\ntmux ls命令可以查看当前所有的 Tmux 会话。\n接入会话 tmux attach命令用于重新接入某个已存在的会话。\n# 使用会话编号\r$ tmux attach -t 0\r# 使用会话名称\r$ tmux attach -t \u0026lt;session-name\u0026gt;\r杀死会话 tmux kill-session命令用于杀死某个会话。\n# 使用会话编号\r$ tmux kill-session -t 0\r# 使用会话名称\r$ tmux kill-session -t \u0026lt;session-name\u0026gt;\r切换会话 tmux switch命令用于切换会话。\n重命名会话 tmux rename-session命令用于重命名会话。\n$ tmux rename-session -t 0 上面命令将0号会话重命名\n会话快捷键 Ctrl+b d：分离当前会话。\rCtrl+b s：列出所有会话。\rCtrl+b $：重命名当前会话。\r最简操作流程 新建会话tmux new -s my_session。 在 Tmux 窗口运行所需的程序。 按下快捷键Ctrl+b d将会话分离。 下次使用时，重新连接到会话tmux attach-session -t my_session。 窗格操作 Tmux 可以将窗口分成多个窗格（pane），每个窗格运行不同的命令。以下命令都是在 Tmux 窗口中执行。\n划分窗格 tmux split-window命令用来划分窗格。\n# 划分上下两个窗格\r$ tmux split-window\r# 划分左右两个窗格\r$ tmux split-window -h\r移动光标 tmux select-pane命令用来移动光标位置\n# 光标切换到上方窗格\r$ tmux select-pane -U\r# 光标切换到下方窗格\r$ tmux select-pane -D\r# 光标切换到左边窗格\r$ tmux select-pane -L\r# 光标切换到右边窗格\r$ tmux select-pane -R\r交换窗格位置 tmux swap-pane命令用来交换窗格位置。\n# 当前窗格上移\r$ tmux swap-pane -U\r# 当前窗格下移\r$ tmux swap-pane -D\r窗格快捷键 下面是一些窗格操作的快捷键\nCtrl+b %：划分左右两个窗格。\rCtrl+b \u0026quot;：划分上下两个窗格。\rCtrl+b \u0026lt;arrow key\u0026gt;：光标切换到其他窗格。\u0026lt;arrow key\u0026gt;是指向要切换到的窗格的方向键，比如切换到下方窗格，就按方向键↓。\rCtrl+b ;：光标切换到上一个窗格。\rCtrl+b o：光标切换到下一个窗格。\rCtrl+b {：当前窗格与上一个窗格交换位置。\rCtrl+b }：当前窗格与下一个窗格交换位置。\rCtrl+b Ctrl+o：所有窗格向前移动一个位置，第一个窗格变成最后一个窗格。\rCtrl+b Alt+o：所有窗格向后移动一个位置，最后一个窗格变成第一个窗格。\rCtrl+b x：关闭当前窗格。\rCtrl+b !：将当前窗格拆分为一个独立窗口。\rCtrl+b z：当前窗格全屏显示，再使用一次会变回原来大小。\rCtrl+b Ctrl+\u0026lt;arrow key\u0026gt;：按箭头方向调整窗格大小。\rCtrl+b q：显示窗格编号。\r窗口管理 除了将一个窗口划分成多个窗格，Tmux 也允许新建多个窗口。\n新建窗口 tmux new-window命令用来创建新窗口。\n$ tmux new-window\r# 新建一个指定名称的窗口\r$ tmux new-window -n \u0026lt;window-name\u0026gt;\r切换窗口 tmux select-window命令用来切换窗口。\n# 切换到指定编号的窗口\r$ tmux select-window -t \u0026lt;window-number\u0026gt;\r# 切换到指定名称的窗口\r$ tmux select-window -t \u0026lt;window-name\u0026gt;\r重命名窗口 tmux rename-window命令用于为当前窗口起名（或重命名）。\n$ tmux rename-window \u0026lt;new-name\u0026gt;\r窗口快捷键 Ctrl+b c：创建一个新窗口，状态栏会显示多个窗口的信息。\rCtrl+b p：切换到上一个窗口（按照状态栏上的顺序）。\rCtrl+b n：切换到下一个窗口。\rCtrl+b \u0026lt;number\u0026gt;：切换到指定编号的窗口，其中的\u0026lt;number\u0026gt;是状态栏上的窗口编号。\rCtrl+b w：从列表中选择窗口。\rCtrl+b ,：窗口重命名。\r其他命令 # 列出所有快捷键，及其对应的 Tmux 命令\r$ tmux list-keys\r# 列出所有 Tmux 命令及其参数\r$ tmux list-commands\r# 列出当前所有 Tmux 会话的信息\r$ tmux info\r# 重新加载当前的 Tmux 配置\r$ tmux source-file ~/.tmux.conf ","date":"2024-05-11T13:28:01+08:00","permalink":"https://example.com/p/tmux/","title":"Tmux"},{"content":"是什么 XML(Extensible Markup Language) 扩展性标识语言。文件后缀名为：.xml。就像HTML的作用是显示数据，XML的作用是传输和存储数据。 据说，java是一门专业操作XML的语言\n是干啥用的 为了便于不同应用，不同平台之间的数据共享和通信\n具体点的作用为： 1.可作为一种简单的数据库，存储并检索数据 2.传输约定格式的文件 3.做软件的配置文件 配置文件：保存软件设置的文件\nXML的出生是为了完善HTML的缺陷和局限性\nXML的闺蜜\u0026ndash;JSON JSON javascript Object Notation ,js对象表示法。作用也是存储和交换文本信息\nJSON更小，跟快，更易解析 JSON适用于简单的传值，XML适用于更广阔的范围\n.xml文件中的代码\n\u0026lt;?xml version=\u0026quot;1.0\u0026quot; encoding=\u0026quot;UTF-8\u0026quot;?\u0026gt;\r\u0026lt;email xmlns:xsi=\u0026quot;http://www.w3.org/2001/XMLSchema-instance\u0026quot; xsi:noNamespaceSchemaLocation=\u0026quot;email.xsd\u0026quot;\u0026gt;\r\u0026lt;to\u0026gt;liuwei8809@163.com\u0026lt;/to\u0026gt;\r\u0026lt;form\u0026gt;hellokitty@163.com\u0026lt;/form\u0026gt;\r\u0026lt;title\u0026gt;about loving\u0026lt;/title\u0026gt;\r\u0026lt;body\u0026gt;I love you forever!\u0026lt;/body\u0026gt;\r\u0026lt;date\u0026gt;2008-11-12\u0026lt;/date\u0026gt;\r\u0026lt;/email\u0026gt; ","date":"2024-05-10T13:28:01+08:00","permalink":"https://example.com/p/xml/","title":"xml"},{"content":"\n图解网络 基础篇 TCP/IP模型 应用层 传输层 在传输层会有两个传输协议，分别是 TCP 和 UDP TCP 的全称叫传输层控制协议（Transmission Control Protocol），⼤部分应⽤使⽤的正是 TCP 传输层协议，⽐如 HTTP 应⽤层协议。TCP 相⽐ UDP 多了很多特性，⽐如流量控制、超时重传、拥塞控制等，这些都是为了保证数据包能可靠地传输给对⽅\nUDP 就相对很简单，简单到只负责发送数据包，不保证数据包是否能抵达对⽅，但它实时性相对更好，传输效率也⾼。当然，UDP 也可以实现可靠传输，把 TCP 的特性在应⽤层上实现就可以，不过要实现⼀个商⽤的可靠 UDP传输协议，也不是⼀件简单的事情\n应⽤需要传输的数据可能会⾮常⼤，如果直接传输就不好控制，因此当传输层的数据包⼤⼩超过 MSS（TCP 最⼤报⽂段⻓度） ，就要将数据包分块，这样即使中途有⼀个分块丢失或损坏了，只需要᯿新这⼀个分块，⽽不⽤᯿新发送整个数据包。在 TCP 协议中，我们把每个分块称为⼀个 TCP 段（TCP Segment）。\n当设备作为接收⽅时，传输层则要负责把数据包传给应⽤，但是⼀台设备上可能会有很多应⽤在接收或者传输数据，因此需要⽤⼀个编号将应⽤区分开来，这个编号就是端⼝\n⽐如 80 端⼝通常是 Web 服务器⽤的，22 端⼝通常是远程登录服务器⽤的。⽽对于浏览器（客户端）中的每个标签栏都是⼀个独⽴的进程，操作系统会为这些进程分配临时的端⼝号\n由于传输层的报⽂中会携带端⼝号，因此接收⽅可以识别出该报⽂是发送给哪个应⽤\n网络层 我们不希望传输层协议处理太多的事情，只需要服务好应⽤即可，让其作为应⽤间数据传输的媒介，帮 助实现应⽤到应⽤的通信，⽽实际的传输功能就交给下⼀层，也就是⽹络层（Internet Layer）\n⽹络层最常使⽤的是 IP 协议（Internet Protocol），IP 协议会将传输层的报⽂作为数据部分，再加上 IP 包头组装成 IP 报⽂，如果 IP 报⽂⼤⼩超过 MTU（以太⽹中⼀般为 1500 字节）就会再次进⾏分⽚，得到⼀个即将发送到⽹络的 IP 报⽂。\n因此，需要将 IP 地址分成两种意义\n⼀个是⽹络号，负责标识该 IP 地址是属于哪个⼦⽹的 ⼀个是主机号，负责标识同⼀⼦⽹下的不同主机\n这需要配合⼦⽹掩码才能算出 IP 地址 的⽹络号和主机号\nIP 协议的寻址作⽤是告诉我们去往下⼀个⽬的地该朝哪个⽅向⾛，路由则是根据「下⼀个⽬的地」选择路径。寻址更像在导航，路由更像在操作⽅向盘\n数据链路层 它主要为⽹络层提供链路级别传输的服务 每⼀台设备的⽹卡都会有⼀个 MAC 地址，它就是⽤来唯⼀标识设备的。路由器计算出了下⼀个⽬的地 IP 地址，再通过 ARP 协议找到该⽬的地的 MAC 地址，这样就知道这个 IP 地址是哪个设备的了\n物理层 当数据准备要从设备发送到⽹络时，需要把数据包转换成电信号，让其可以在物理介质中传输，这⼀层就是物理层（Physical Layer），它主要是为数据链路层提供⼆进制传输的服务\nHTTP篇 HTTP基本概念 先说明下安全和幂等的概念： 在 HTTP 协议⾥，所谓的「安全」是指请求⽅法不会「破坏」服务器上的资源。 所谓的「幂等」，意思是多次执⾏相同的操作，结果都是「相同」的。\n那么很明显 GET ⽅法就是安全且幂等的，因为它是「只读」操作，⽆论操作多少次，服务器上的数据都是安全的，且每次的结果都是相同的\nPOST 因为是「新增或提交数据」的操作，会修改服务器上的资源，所以是不安全的，且多次提交数据就会创建多个资源，所以不是幂等的。\nHTTP特性 简单\n灵活和易于扩展\n应用广泛和跨平台\n无状态\n明文传输\n长连接\n管道网络传输\n队头阻塞\nSSL/TLS 协议建⽴的详细流程\nClientHello：⾸先，由客户端向服务器发起加密通信请求，也就是 ClientHello 请求\nSeverHello：服务器收到客户端请求后，向客户端发出响应，也就是 SeverHello\n客户端回应:客户端收到服务器的回应之后，⾸先通过浏览器或者操作系统中的 CA 公钥，确认服务器的数字证书的真实性。如果证书没有问题，客户端会从数字证书中取出服务器的公钥，然后使⽤它加密报⽂\n服务器的最后回应:服务器收到客户端的第三个随机数（ pre-master key ）之后，通过协商的加密算法，计算出本次通信的「会话秘钥」。然后，向客户端发⽣最后的信息\n那 HTTP/2 相⽐ HTTP/1.1 性能上的改进\n头部压缩:消除重复的部分。这就是所谓的 HPACK 算法：在客户端和服务器同时维护⼀张头信息表，所有字段都会存⼊这个表，⽣成⼀个索引号，以后就不发送同样字段了，只发送索引号，这样就提⾼速度了\n⼆进制格式:头信息和数据体都是⼆进制，并且统称为帧（frame）：头信息帧和数据帧,增加了数据传输的效率。\n数据流:HTTP/2 的数据包不是按顺序发送的，同⼀个连接⾥⾯连续的数据包，可能属于不同的回应。因此，必须要对数据包做标记，指出它属于哪个回应。每个请求或回应的所有数据包，称为⼀个数据流（ Stream ）。每个数据流都标记着⼀个独⼀⽆⼆的编号，其中规定客户端发出的数据流编号为奇数， 服务器发出的数据流编号为偶数.客户端还可以指定数据流的优先级。优先级⾼的请求，服务器就先响应该请求。\n多路复⽤ 可以在⼀个连接中并发多个请求或回应，⽽不⽤按照顺序⼀⼀对应,移除了 HTTP/1.1 中的串⾏请求，不需要排队等待，也就不会再出现「队头阻塞」问题，降低了延迟，⼤幅度提⾼了连接的利⽤率 在⼀个 TCP 连接⾥，服务器收到了客户端 A 和 B 的两个请求，如果发现 A 处理过程⾮常耗时，于是就 回应 A 请求已经处理好的部分，接着回应 B 请求，完成后，再回应 A 请求剩下的部分\n服务器推送:减少延时的等待\nHTTP/2 主要的问题在于，多个 HTTP 请求在复⽤⼀个 TCP 连接，下层的 TCP 协议是不知道有多少个 HTTP 请求的。所以⼀旦发⽣了丢包现象，就会触发 TCP 的᯿传机制，这样在⼀个 TCP 连接中的所有的 HTTP 请求都必须等待这个丢了的包被重传回来\nHTTP/1.1 中的管道（ pipeline）传输中如果有⼀个请求阻塞了，那么队列后请求也统统被阻塞住了 HTTP/2 多个请求复⽤⼀个TCP连接，⼀旦发⽣丢包，就会阻塞住所有的 HTTP 请求。 这都是基于 TCP 传输层的问题，所以 HTTP/3 把 HTTP 下层的 TCP 协议改成了 UDP！\nUDP 发⽣是不管顺序，也不管丢包的，所以不会出现 HTTP/1.1 的队头阻塞 和 HTTP/2 的⼀个丢包全部重传传问题\n⼤家都知道 UDP 是不可靠传输的，但基于 UDP 的 QUIC 协议 可以实现类似 TCP 的可靠性传输\nQUIC 有⾃⼰的⼀套机制可以保证传输的可靠性的。当某个流发⽣丢包时，只会阻塞这个流，其他流不会受到影响。\nTLS3 升级成了最新的 1.3 版本，头部压缩算法也升级成了 QPack 。\nHTTPS 要建⽴⼀个连接，要花费 6 次交互，先是建⽴三次握⼿，然后是 TLS/1.3 的三次握⼿。QUIC 直接把以往的 TCP 和 TLS/1.3 的 6 次交互合并成了 3 次，减少了交互次数。\n所以， QUIC 是⼀个在 UDP 之上的伪 TCP + TLS + HTTP/2 的多路复⽤的协议。\nHTTP/1.1如何优化 有如下 3 种优化思路：\n尽量避免发送 HTTP 请求 在需要发送 HTTP 请求时，考虑如何减少请求次数 减少服务器的 HTTP 响应的数据⼤⼩ 避免发送 HTTP 请求的⽅法就是通过缓存技术 客户端会把第⼀次请求以及响应的数据保存在本地磁盘上，其中将请求的 URL 作为 key，⽽响应作为 value，两者形成映射关系。\n这样当后续发起相同的请求时，就可以先在本地磁盘上通过 key 查到对应的 value，也就是响应，如果找到了，就直接从本地读取该响应。毋庸置疑，读取本次磁盘的速度肯定⽐⽹络请求快得多\n如何减少 HTTP 请求次数 减少重定向请求次数：如果重定向的⼯作交由代理服务器完成，就能减少 HTTP 请求次数了 合并请求：如果把多个访问⼩⽂件的请求合并成⼀个⼤的请求，虽然传输的总资源还是⼀样，但是减少请求，也就意味着减少了重复发送的 HTTP 头部。减少 TCP 连接的数量，因⽽省去了 TCP 握⼿和慢启动过程耗费的时间 延迟发送请求：请求⽹⻚的时候，没必要把全部资源都获取到，⽽是只获取当前⽤户所看到的⻚⾯资源，当⽤户向下滑动⻚⾯的时候，再向服务器获取接下来的资源，这样就达到了延迟发送请求的效果 如何减少 HTTP 响应的数据⼤⼩？ 我们可以考虑对响应的资源进⾏压缩，这样就可以减少响应的数据⼤⼩，从⽽提⾼⽹络传输的效率。\n无损压缩 有损压缩 HTTPS RSA握手解析 TLS握手过程 所以安全上存在以下三个⻛险\n窃听⻛险 篡改⻛险 冒充⻛险 HTTPS 在 HTTP 与 TCP 层之间加⼊了 TLS 协议 TLS 协议是如何解决 HTTP 的⻛险的呢？\n信息加密 校验机制 身份证书 不同的密钥交换算法，TLS 的握⼿过程可能会有⼀些区别\nRSA握手过程 传统的 TLS 握⼿基本都是使⽤ RSA 算法来实现密钥交换的，在将 TLS 证书部署服务端时，证书⽂件中包含⼀对公私钥，其中公钥会在 TLS 握⼿阶段传递给客户端，私钥则⼀直留在服务端，⼀定要确保私钥不能被窃取\nTLS 第⼀次握⼿：客户端⾸先会发⼀个「Client Hello」消息，字⾯意思我们也能理解到，这是跟服务器「打招呼」\nTLS 第⼆次握⼿：当服务端收到客户端的「Client Hello」消息后，会确认 TLS 版本号是否⽀持，和从密码套件列表中选择⼀个密码套件，以及⽣成随机数（Server Random）接着，返回「Server Hello」消息，消息⾥⾯有服务器确认的 TLS 版本号，也给出了随机数（Server Random），然后从客户端的密码套件列表选择了⼀个合适的密码套件。\nTLS 第三次握⼿：客户端验证完证书后，认为可信则继续往下⾛。接着，客户端就会⽣成⼀个新的随机数 (pre-master)，⽤服务器的 RSA 公钥加密该随机数，通过「Change Cipher Key Exchange」消息传给服务端。\nTLS 第四次握⼿：服务器也是同样的操作，发「Change Cipher Spec」和「Encrypted Handshake Message」消息，如果双⽅都验证加密和解密没问题，那么握⼿正式完成\nRSA算法的缺陷 使⽤ RSA 密钥协商算法的最⼤问题是不⽀持前向保密\nHTTPS ECDHE 握⼿解析 HTTPS 常⽤的密钥交换算法有两种，分别是 RSA 和 ECDHE 算法 其中，RSA 是⽐较传统的密钥交换算法，它不具备前向安全的性质，因此现在很少服务器使⽤的。⽽ ECDHE 算法具有前向安全，所以被⼴泛使⽤\n离散对数 特别是当模数 p 是⼀个很⼤的质数，即使知道底数 a 和真数 b ，在现有的计算机的计算⽔平是⼏乎⽆法算出离散对数的，这就是 DH 算法的数学基础\nDH算法 DHE算法 ECDHE算法 RSA 和 ECDHE 握⼿过程的区别：\nRSA 密钥协商算法「不⽀持」前向保密，ECDHE 密钥协商算法「⽀持」前向保密；\n使⽤了 RSA 密钥协商算法，TLS 完成四次握⼿后，才能进⾏应⽤数据传输，⽽对于 ECDHE 算法，客户端可以不⽤等服务端的最后⼀次 TLS 握⼿，就可以提前发出加密的 HTTP 数据，节省了⼀个消息的往返时间；\n使⽤ ECDHE， 在 TLS 第 2 次握⼿中，会出现服务器端发出的「Server Key Exchange」消息，⽽ RSA 握⼿过程没有该消息\nHTTPS如何优化 分析性能损耗 第⼀个环节， TLS 协议握⼿过程；\n第⼆个环节，握⼿后的对称加密报⽂传输。\n硬件优化\n软件优化：软件的优化⽅向可以分层两种，⼀个是软件升级，⼀个是协议优化：密钥交换算法优化\n证书优化：⼀个是证书传输，⼀个是证书验证。服务器应该选⽤ ECDSA 证书，⽽⾮ RSA 证书，因为在相同安全级别下，ECC 的密钥⻓度⽐ RSA 短很多，这样可以提⾼证书传输的效率\nCRL CRL 称为证书吊销列表（Certificate Revocation List），这个列表是由 CA 定期更新，列表内容都是被撤销信任的证书序号，如果服务器的证书在此列表，就认为证书已经失效，不在的话，则认为证书是有效的、\n第⼀个问题，由于 CRL 列表是由 CA 维护的，定期更新，如果⼀个证书刚被吊销后，客户端在更新 CRL 之前还是会信任这个证书，实时性较差；\n第⼆个问题，随着吊销证书的增多，列表会越来越⼤，下载的速度就会越慢，下载完客户端还得遍历这么⼤的列表，那么就会导致客户端在校验证书这⼀环节的延时很⼤，进⽽拖慢了 HTTPS 连接\nOCSP 因此，现在基本都是使⽤ OCSP ，名为在线证书状态协议（Online Certificate Status Protocol）来查询证书的有效性，它的⼯作⽅式是向 CA 发送查询请求，让 CA 返回证书的有效状态。\nOCSP 需要向 CA 查询，因此也是要发⽣⽹络请求，⽽且还得看 CA 服务器的“脸⾊”，如果⽹络状态不好，或者CA 服务器繁忙，也会导致客户端在校验证书这⼀环节的延时变⼤。\nOCSP Stapling 于是为了解决这⼀个⽹络开销，就出现了 OCSP Stapling，其原理是：服务器向 CA 周期性地查询证书状态，获得⼀个带有时间戳和签名的响应结果并缓存它\n会话复用 TLS 握⼿的⽬的就是为了协商出会话密钥，也就是对称加密密钥，那我们如果我们把⾸次 TLS 握⼿协商的对称加密密钥缓存起来，待下次需要建⽴ HTTPS 连接时，直接「复⽤」这个密钥，不就减少 TLS 握⼿的性能损耗了吗\n这种⽅式就是会话复⽤（TLS session resumption），会话复⽤分两种\n第⼀种叫 Session ID； 第⼆种叫 Session Ticket； Session ID Session ID 的⼯作原理是，客户端和服务器⾸次 TLS 握⼿连接后，双⽅会在内存缓存会话密钥，并⽤唯⼀的Session ID 来标识，Session ID 和会话密钥相当于 key-value 的关系 但是它有两个缺点：\n服务器必须保持每⼀个客户端的会话密钥，随着客户端的增多，服务器的内存压⼒也会越⼤。 现在⽹站服务⼀般是由多台服务器通过负载均衡提供服务的，客户端再次连接不⼀定会命中上次访问过的服务器，于是还要⾛完整的 TLS 握⼿过程； Session Ticket 为了解决 Session ID 的问题，就出现了 Session Ticket，服务器不再缓存每个客户端的会话密钥，⽽是把缓存的⼯作交给了客户端，类似于 HTTP 的 Cookie\nSession ID 和 Session Ticket 都不具备前向安全性\n避免重放攻击的⽅式就是需要对会话密钥设定⼀个合理的过期时间\nPre-shared Key ⽽ TLS1.3 更为⽜逼，对于᯿连 TLS1.3 只需要 0 RTT，原理和 Ticket 类似，只不过在᯿连时，客户端会把 Ticket和 HTTP 请求⼀同发送给服务端，这种⽅式叫 Pre-shared Key\nHTTP/2牛逼在哪 兼容 HTTP/1.1 头部压缩 二进制帧 并发传输 服务器主动推送资源 HTTP/2 是基于 TCP 协议来传输数据的，TCP 是字节流协议，TCP 层必须保证收到的字节数据是完整且连续的，这样内核才会将缓冲区⾥的数据返回给 HTTP 应⽤，那么当「前 1 个字节数据」没有到达时，后收到的字节数据只能存放在内核缓冲区⾥，只有等到这 1 个字节数据到达时，HTTP/2 应⽤层才能从内核中拿到数据，这就是HTTP/2 队头阻塞问题。\nHTTP/3强势来袭 美中不足的HTTP/2 队头阻塞\nTCP与TLS的握手时延迟\n网络迁移需要重新连接：⼀个 TCP 连接是由四元组（源 IP 地址，源端⼝，⽬标 IP 地址，⽬标⼝）确定的，这意味着如果 IP 地址或者端⼝变动了，就会导致需要 TCP 与 TLS ᯿新握⼿，这不利于移动设备切换⽹络的场景，⽐如 4G ⽹络环境切换成WIFI。\nQUIC协议的特点 ⽆队头阻塞：由于 QUIC 使⽤的传输协议是 UDP，UDP 不关⼼数据包的顺序，如果数据包丢失，UDP 也不关⼼，当然，HTTP/3 不仅仅只是简单将传输协议替换成了 UDP，还基于 UDP 协议在「应⽤层」实现了 QUIC 协议，它具有类似 TCP 的连接管理、拥塞窗⼝、流ᰁ控制的⽹络特性，相当于将不可靠传输的 UDP 协议变成“可靠”的了，所以不⽤担⼼数据包丢失的问题\n更快的连接建⽴：是QUIC 内部包含了 TLS，它在⾃⼰的帧会携带 TLS ⾥的“记录”，再加上 QUIC 使⽤的是 TLS1.3，因此仅需 1 个 RTT 就可以「同时」完成建⽴连接与密钥协商，甚⾄在第⼆次连接的时候，应⽤数据包可以和 QUIC 握⼿信息（连接信息 + TLS 信息）⼀起发送，达到 0-RTT 的效果\n连接迁移：在前⾯我们提到，基于 TCP 传输协议的 HTTP 协议，由于是通过四元组（源 IP、源端⼝、⽬的 IP、⽬的端⼝）确定⼀条 TCP 连接，那么当移动设备的⽹络从 4G 切换到 WIFI 时，意味着 IP 地址变化了，那么就必须要断开连接，然后᯿新建⽴连接，⽽建⽴连接的过程包含 TCP 三次握⼿和 TLS 四次握⼿的时延，以及 TCP 慢启动的减速过程，给⽤户的感觉就是⽹络突然卡顿了⼀下，因此连接的迁移成本是很⾼的。⽽ QUIC 协议没有⽤四元组的⽅式来“绑定”连接，⽽是通过连接 ID来标记通信的两个端点，客户端和服务器可以各⾃选择⼀组 ID 来标记⾃⼰，因此即使移动设备的⽹络变化后，导致 IP 地址变化了，只要仍保有上下⽂信息（⽐如连接 ID、TLS 密钥等），就可以“⽆缝”地复⽤原连接，消除᯿连的成本，没有丝毫卡顿感，达到了连接迁移的功能\nHTTP/3协议 HTTP/3 同 HTTP/2 ⼀样采⽤⼆进制帧的结构，不同的地⽅在于 HTTP/2 的⼆进制帧⾥需要定义 Stream，⽽ HTTP/3 ⾃身不需要再定义 Stream，直接使⽤ QUIC ⾥的 Stream，于是 HTTP/3 的帧的结构也变简单了。\nHTTP/3 在头部压缩算法这⼀⽅便也做了升级，升级成了 QPACK。与 HTTP/2 中的 HPACK 编码⽅式相似，HTTP/3 中的 QPACK 也采⽤了静态表、动态表及 Huffman 编码\n动态表是具有时序性的，如果⾸次出现的请求发⽣了丢包，后续的收到请求，对⽅就⽆法解码出HPACK 头部，因为对⽅还没建⽴好动态表，因此后续的请求解码会阻塞到⾸次请求中丢失的数据包重传过来\nHTTP/3 的 QPACK 解决了这⼀问题，那它是如何解决的呢？ QUIC 会有两个特殊的单向流，所谓的单项流只有⼀端可以发送消息，双向则指两端都可以发送消息，传输 HTTP消息时⽤的是双向流，这两个单向流的⽤法\n⼀个叫 QPACK Encoder Stream， ⽤于将⼀个字典（key-value）传递给对⽅，⽐如⾯对不属于静态表的HTTP 请求头部，客户端可以通过这个 Stream 发送字典\n⼀个叫 QPACK Decoder Stream，⽤于响应对⽅，告诉它刚发的字典已经更新到⾃⼰的本地动态表了，后续就可以使⽤这个字典来编码了。\n这两个特殊的单向流是⽤来同步双⽅的动态表，编码⽅收到解码⽅更新确认的通知后，才使⽤动态表编码 HTTP 头部\nTCP篇 TCP 三次握⼿与四次挥⼿ TCP基本认识 序列号：在建⽴连接时由计算机⽣成的随机数作为其初始值，通过 SYN 包传给接收端主机，每发送⼀次数据，就「累加」⼀次该「数据字节数」的⼤⼩。⽤来解决⽹络包乱序问题\n确认应答号：指下⼀次「期望」收到的数据的序列号，发送端收到这个确认应答以后可以认为在这个序号以前的数据都已经被正常接收。⽤来解决不丢包的问题\n控制位：ACK：\n该位为 1 时，「确认应答」的字段变为有效，TCP 规定除了最初建⽴连接时的 SYN 包之外该位必须设置为 1 。\nRST：该位为 1 时，表示 TCP 连接中出现异常必须强制断开连接。\nSYN：该位为 1 时，表示希望建⽴连接，并在其「序列号」的字段进⾏序列号初始值的设定。\nFIN：该位为 1 时，表示今后不会再有数据发送，希望断开连接。当通信结束希望断开连接时，通信双⽅的主机之间就可以相互交换 FIN 位为 1 的 TCP 段。\n为什么需要 TCP 协议？ TCP ⼯作在哪⼀层？ IP 层是「不可靠」的，它不保证⽹络包的交付、不保证⽹络包的按序交付、也不保证⽹络包中的数据的完整性\n如果需要保障⽹络数据包的可靠性，那么就需要由上层（传输层）的 TCP 协议来负责\n什么是 TCP TCP 是⾯向连接的、可靠的、基于字节流的传输层通信协议。\n⾯向连接：⼀定是「⼀对⼀」才能连接，不能像 UDP 协议可以⼀个主机同时向多个主机发送消息，也就是⼀对多是⽆法做到的；\n可靠的：⽆论的⽹络链路中出现了怎样的链路变化，TCP 都可以保证⼀个报⽂⼀定能够到达接收端\n字节流：消息是「没有边界」的，所以⽆论我们消息有多⼤都可以进⾏传输。并且消息是「有序的」，当「前⼀个」消息没有收到的时候，即使它先收到了后⾯的字节，那么也不能扔给应⽤层去处理，同时对「重复」的报⽂会⾃动丢弃\n什么是 TCP 连接？ Socket：由 IP 地址和端⼝号组成 序列号：⽤来解决乱序问题等 窗⼝⼤⼩：⽤来做流ᰁ控制 如何唯⼀确定⼀个 TCP 连接呢？ TCP 四元组可以唯⼀的确定⼀个连接\n源地址和⽬的地址的字段（32位）是在 IP 头部中，作⽤是通过 IP 协议发送报⽂给对⽅主机\n源端⼝和⽬的端⼝的字段（16位）是在 TCP 头部中，作⽤是告诉 TCP 协议应该把报⽂发给哪个进程。\n有⼀个 IP 的服务器监听了⼀个端⼝，它的 TCP 的最⼤连接数是多少？ 服务器通常固定在某个本地端⼝上监听，等待客户端的连接请求 因此，客户端 IP 和 端⼝是可变的，其理论值计算公式如下:\nip数 * 端口数\r当然，服务端最⼤并发 TCP 连接数远不能达到理论上限。\n⾸先主要是⽂件描述符限制，Socket 都是⽂件，所以⾸先要通过 ulimit 配置⽂件描述符的数⽬； 另⼀个是内存限制，每个 TCP 连接都要占⽤⼀定内存，操作系统的内存是有限的 UDP 和 TCP 有什么区别呢？分别的应⽤场景是？ UDP 不提供复杂的控制机制，利⽤ IP 提供⾯向「⽆连接」的通信服务。 UDP 协议真的⾮常简单，头部只有 8 个字节（ 64 位），UDP 的头部格式如下 ⽬标和源端⼝：主要是告诉 UDP 协议应该把报⽂发给哪个进程。 包⻓度：该字段保存了 UDP ⾸部的⻓度跟数据的⻓度之和 校验和：校验和是为了提供可靠的 UDP ⾸部和数据⽽设计 TCP和UDP 连接 TCP 是⾯向连接的传输层协议，传输数据前先要建⽴连接。 UDP 是不需要连接，即刻传输数据 服务对象 TCP 是⼀对⼀的两点服务，即⼀条连接只有两个端点。 UDP ⽀持⼀对⼀、⼀对多、多对多的交互通信 可靠性 TCP 是可靠交付数据的，数据可以⽆差错、不丢失、不᯿复、按需到达。 UDP 是尽最⼤努⼒交付，不保证可靠交付数据 拥塞控制、流量控制 TCP 有拥塞控制和流量控制机制，保证数据传输的安全性 UDP 则没有，即使⽹络⾮常拥堵了，也不会影响 UDP 的发送速率。 ⾸部开销 TCP ⾸部⻓度较⻓，会有⼀定的开销，⾸部在没有使⽤「选项」字段时是 20 个字节，如果使⽤了「选项」字段则会变⻓的 UDP ⾸部只有 8 个字节，并且是固定不变的，开销较⼩。 传输⽅式 TCP 是流式传输，没有边界，但保证顺序和可靠。 UDP 是⼀个包⼀个包的发送，是有边界的，但可能会丢包和乱序 分⽚不同 TCP 的数据⼤⼩如果⼤于 MSS ⼤⼩，则会在传输层进⾏分⽚，⽬标主机收到后，也同样在传输层组装 TCP数据包，如果中途丢失了⼀个分⽚，只需要传输丢失的这个分⽚。 UDP 的数据⼤⼩如果⼤于 MTU ⼤⼩，则会在 IP 层进⾏分⽚，⽬标主机收到后，在 IP 层组装完数据，接着再传给传输层，但是如果中途丢了⼀个分⽚，在实现可靠传输的 UDP 时则就需要᯿传所有的数据包，这样传输效率⾮常差，所以通常 UDP 的报⽂应该⼩于 MTU TCP 和 UDP 应⽤场景 由于 TCP 是⾯向连接，能保证数据的可靠性交付，因此经常⽤于： FTP ⽂件传输 HTTP / HTTPS\n由于 UDP ⾯向⽆连接，它可以随时发送数据，再加上UDP本身的处理既简单⼜⾼效，因此经常⽤于： 包总量较少的通信，如 DNS 、 SNMP 等 视频、⾳频等多媒体通信 ⼴播通信\n为什么 UDP 头部没有「⾸部⻓度」字段，⽽ TCP 头部有「⾸部⻓度」字段呢 原因是 TCP 有可变⻓的「选项」字段，⽽ UDP 头部⻓度则是不会变化的，⽆需多⼀个字段去记录 UDP的⾸部⻓度\n为什么 UDP 头部有「包⻓度」字段，⽽ TCP 头部则没有「包⻓度」字段呢？ TCP 是如何计算负载数据⻓度 其中 IP 总⻓度 和 IP ⾸部⻓度，在 IP ⾸部格式是已知的。TCP ⾸部⻓度，则是在 TCP ⾸部格式已知的，所以就可以求得 TCP 数据的⻓度\n⼤家这时就奇怪了问：“ UDP 也是基于 IP 层的呀，那 UDP 的数据⻓度也可以通过这个公式计算呀？ 为何还要有「包⻓度」呢？”\n因为为了⽹络设备硬件设计和处理⽅便，⾸部⻓度需要是 4 字节的整数倍\n如果去掉 UDP 「包⻓度」字段，那 UDP ⾸部⻓度就不是 4 字节的整数倍了，所以⼩林觉得这可能是为了补全UDP ⾸部⻓度是 4 字节的整数倍，才补充了「包⻓度」字段\nTCP连接建立 TCP 是⾯向连接的协议，所以使⽤ TCP 前必须先建⽴连接，⽽建⽴连接是通过三次握⼿来进⾏的\n⼀开始，客户端和服务端都处于 CLOSED 状态。先是服务端主动监听某个端⼝，处于 LISTEN 状态\n客户端会随机初始化序号（ client_isn ），将此序号置于 TCP ⾸部的「序号」字段中，同时把 SYN 标志位置为 1 ，表示 SYN 报⽂。接着把第⼀个 SYN 报⽂发送给服务端，表示向服务端发起连接，该报⽂不包含应⽤层数据，之后客户端处于 SYN-SENT 状态。\n服务端收到客户端的 SYN 报⽂后，⾸先服务端也随机初始化⾃⼰的序号（ server_isn ），将此序号填⼊TCP ⾸部的「序号」字段中，其次把 TCP ⾸部的「确认应答号」字段填⼊ client_isn + 1 , 接着把 SYN和 ACK 标志位置为 1 。最后把该报⽂发给客户端，该报⽂也不包含应⽤层数据，之后服务端处于 SYN-RCVD 状态。\n客户端收到服务端报⽂后，还要向服务端回应最后⼀个应答报⽂，⾸先该应答报⽂ TCP ⾸部 ACK 标志位 置为 1 ，其次「确认应答号」字段填⼊ server_isn + 1 ，最后把报⽂发送给服务端，这次报⽂可以携带客户到服务器的数据，之后客户端处于 ESTABLISHED 状态。\n服务器收到客户端的应答报⽂后，也进⼊ ESTABLISHED 状态\n从上⾯的过程可以发现第三次握⼿是可以携带数据的，前两次握⼿是不可以携带数据的，这也是⾯试常问的题\n⼀旦完成三次握⼿，双⽅都处于 ESTABLISHED 状态，此时连接就已建⽴完成，客户端和服务端就可以相互发送数据了。\n如何在 Linux 系统中查看 TCP 状态？ TCP 的连接状态查看，在 Linux 可以通过 netstat -napt 命令查看\n为什么是三次握⼿？不是两次、四次 因为三次握⼿才能保证双⽅具有接收和发送的能⼒ 三次握⼿才可以阻⽌重复历史连接的初始化（主要原因）：三次握⼿的⾸要原因是为了防⽌旧的重复连接初始化造成混乱 三次握⼿才可以同步双⽅的初始序列号 三次握⼿才可以避免资源浪费 如果是两次握⼿连接，就不能判断当前连接是否是历史连接，三次握⼿则可以在客户端（发送⽅）准备发送第三次报⽂时，客户端因有⾜够的上下⽂来判断当前连接是否是历史连接： 如果是历史连接（序列号过期或超时），则第三次握⼿发送的报⽂是 RST 报⽂，以此中⽌历史连接 如果不是历史连接，则第三次发送的报⽂是 ACK 报⽂，通信双⽅就会成功建⽴连接；\nTCP 协议的通信双⽅， 都必须维护⼀个「序列号」， 序列号是可靠传输的⼀个关键因素\n接收⽅可以去除重复的数据； 接收⽅可以根据数据包的序列号按序接收； 可以标识发送出去的数据包中， 哪些是已经被对⽅收到的； 如果客户端的 SYN 阻塞了，重复发送多次 SYN 报⽂，那么服务器在收到请求后就会建⽴多个冗余的⽆效链接，造成不必要的资源浪费\nTCP 建⽴连接时，通过三次握⼿能防⽌历史连接的建⽴，能减少双⽅不必要的资源开销，能帮助双⽅同步初始化序列号。序列号能够保证数据包不᯿复、不丢弃和按序传输。 当 IP 层有⼀个超过 MTU ⼤⼩的数据（TCP 头部 + TCP 数据）要发送，那么 IP 层就要进⾏分⽚，把数据分⽚成若⼲⽚，保证每⼀个分⽚都⼩于 MTU。把⼀份 IP 数据报进⾏分⽚以后，由⽬标主机的 IP 层来进⾏重新组装后，再交给上⼀层 TCP 传输层。\n这看起来井然有序，但这存在隐患的，那么当如果⼀个 IP 分⽚丢失，整个 IP 报⽂的所有分⽚都得重传。\n所以，为了达到最佳的传输效能 TCP 协议在建⽴连接的时候通常要协商双⽅的 MSS 值，当 TCP 层发现数据超过MSS 时，则就先会进⾏分⽚，当然由它形成的 IP 包的⻓度也就不会⼤于 MTU ，⾃然也就不⽤ IP 分⽚了。\n经过 TCP 层分⽚后，如果⼀个 TCP 分⽚丢失后，进⾏重发时也是以 MSS 为单位，⽽不⽤᯿传所有的分⽚，⼤⼤增加了重传的效率。\nSYN攻击 我们都知道 TCP 连接建⽴是需要三次握⼿，假设攻击者短时间伪造不同 IP 地址的 SYN 报⽂，服务端每接收到⼀个 SYN 报⽂，就进⼊ SYN_RCVD 状态，但服务端发送出去的 ACK + SYN 报⽂，⽆法得到未知 IP 主机的ACK 应答，久⽽久之就会占满服务端的 SYN 接收队列（未连接队列），使得服务器不能为正常⽤户服务。\n其中⼀种解决⽅式是通过修改 Linux 内核参数，控制队列⼤⼩和当队列满时应做什么处理\n我们先来看下 Linux 内核的 SYN （未完成连接建⽴）队列与 Accpet （已完成连接建⽴）队列是如何⼯作的？\n正常流程：\n当服务端接收到客户端的 SYN 报⽂时，会将其加⼊到内核的「 SYN 队列」； 接着发送 SYN + ACK 给客户端，等待客户端回应 ACK 报⽂； 服务端接收到 ACK 报⽂后，从「 SYN 队列」移除放⼊到「 Accept 队列」； 应⽤通过调⽤ accpet() socket 接⼝，从「 Accept 队列」取出连接 另一种解决思路： 计算出⼀个 cookie 值，再以 SYN + ACK 中的「序列号」返回客户端， 服务端接收到客户端的应答报⽂时，服务器会检查这个 ACK 包的合法性。如果合法，直接放⼊到「 Accept队列」。 最后应⽤通过调⽤ accpet() socket 接⼝，从「 Accept 队列」取出的连接。\nTCP连接断开 客户端打算关闭连接，此时会发送⼀个 TCP ⾸部 FIN 标志位被置为 1 的报⽂，也即 FIN 报⽂，之后客户端进⼊ FIN_WAIT_1 状态。 服务端收到该报⽂后，就向客户端发送 ACK 应答报⽂，接着服务端进⼊ CLOSED_WAIT 状态。 客户端收到服务端的 ACK 应答报⽂后，之后进⼊ FIN_WAIT_2 状态。 等待服务端处理完数据后，也向客户端发送 FIN 报⽂，之后服务端进⼊ LAST_ACK 状态。 客户端收到服务端的 FIN 报⽂后，回⼀个 ACK 应答报⽂，之后进⼊ TIME_WAIT 状态 服务器收到了 ACK 应答报⽂后，就进⼊了 CLOSED 状态，⾄此服务端已经完成连接的关闭。 客户端在经过 2MSL ⼀段时间后，⾃动进⼊ CLOSED 状态，⾄此客户端也完成连接的关闭。 你可以看到，每个⽅向都需要⼀个 FIN 和⼀个 ACK，因此通常被称为四次挥⼿。\n主动关闭连接的，才有 TIME_WAIT 状态\n关闭连接时，客户端向服务端发送 FIN 时，仅仅表示客户端不再发送数据了但是还能接收数据。 服务器收到客户端的 FIN 报⽂时，先回⼀个 ACK 应答报⽂，⽽服务端可能还有数据需要处理和发送，等 服务端不再发送数据时，才发送 FIN 报⽂给客户端来表示同意现在关闭连接\n为什么需要 TIME_WAIT 状态？ 主动发起关闭连接的⼀⽅，才会有 TIME-WAIT 状态\n需要 TIME-WAIT 状态，主要是两个原因：\n防⽌具有相同「四元组」的「旧」数据包被收到； 保证「被动关闭连接」的⼀⽅能被正确的关闭，即保证最后的 ACK 能让被动关闭⽅接收，从⽽帮助其正常关闭 过多的 TIME-WAIT 状态主要的危害有两种 第⼀是内存资源占⽤； 第⼆是对端⼝资源的占⽤，⼀个 TCP 连接⾄少消耗⼀个本地端⼝；\n如何优化 TIME_WAIT？ ⽅式⼀：net.ipv4.tcp_tw_reuse 和 tcp_timestamps ⽅式⼆：net.ipv4.tcp_max_tw_buckets ⽅式三：程序中使⽤ SO_LINGER\n如果已经建⽴了连接，但是客户端突然出现故障了怎么办？ TCP 有⼀个机制是保活机制。这个机制的原理是这样的： 定义⼀个时间段，在这个时间段内，如果没有任何连接相关的活动，TCP 保活机制会开始作⽤，每隔⼀个时间间隔，发送⼀个探测报⽂，该探测报⽂包含的数据⾮常少，如果连续⼏个探测报⽂都没有得到响应，则认为当前的TCP 连接已经死亡，系统内核将错误信息通知给上层应⽤程序。\nSocket编程 针对 TCP 应该如何 Socket 编程？\n服务端和客户端初始化 socket ，得到⽂件描述符； 服务端调⽤ bind ，将绑定在 IP 地址和端⼝; 服务端调⽤ listen ，进⾏监听； 服务端调⽤ accept ，等待客户端连接； 客户端调⽤ connect ，向服务器端的地址和端⼝发起连接请求； 服务端 accept 返回⽤于传输的 socket 的⽂件描述符； 客户端调⽤ write 写⼊数据；服务端调⽤ read 读取数据； 客户端断开连接时，会调⽤ close ，那么服务端 read 读取数据的时候，就会读取到了 EOF ，待处理完数据后，服务端调⽤ close ，表示连接关闭 这⾥需要注意的是，服务端调⽤ accept 时，连接成功了会返回⼀个已完成连接的 socket，后续⽤来传输数据。所以，监听的 socket 和真正⽤来传送数据的 socket，是「两个」 socket，⼀个叫作监听 socket，⼀个叫作已完成连接 socket\nLinux内核中会维护两个队列： 未完成连接队列（SYN 队列）：接收到⼀个 SYN 建⽴连接请求，处于 SYN_RCVD 状态； 已完成连接队列（Accpet 队列）：已完成 TCP 三次握⼿过程，处于 ESTABLISHED 状态\n我们先看看客户端连接服务端时，发送了什么\n客户端的协议栈向服务器端发送了 SYN 包，并告诉服务器端当前发送序列号 client_isn，客户端进⼊SYN_SENT 状态 服务器端的协议栈收到这个包之后，和客户端进⾏ ACK 应答，应答的值为 client_isn+1，表示对 SYN 包client_isn 的确认，同时服务器也发送⼀个 SYN 包，告诉客户端当前我的发送序列号为 server_isn，服务器端进⼊ SYN_RCVD 状态； 客户端协议栈收到 ACK 之后，使得应⽤程序从 connect 调⽤返回，表示客户端到服务器端的单向连接建⽴成功，客户端的状态为 ESTABLISHED，同时客户端协议栈也会对服务器端的 SYN 包进⾏应答，应答数据为server_isn+1 应答包到达服务器端后，服务器端协议栈使得 accept 阻塞调⽤返回，这个时候服务器端到客户端的单向连接也建⽴成功，服务器端也进⼊ ESTABLISHED 状态 从上⾯的描述过程，我们可以得知客户端 connect 成功返回是在第⼆次握⼿，服务端 accept 成功返回是在三次握⼿成功之后。\n客户端调⽤ close ，表明客户端没有数据需要发送了，则此时会向服务端发送 FIN 报⽂，进⼊ FIN_WAIT_1状态 服务端接收到了 FIN 报⽂，TCP 协议栈会为 FIN 包插⼊⼀个⽂件结束符 EOF 到接收缓冲区中，应⽤程序可以通过 read 调⽤来感知这个 FIN 包。这个 EOF 会被放在已排队等候的其他已接收的数据之后，这就意味着服务端需要处理这种异常情况，因为 EOF 表示在该连接上再⽆额外数据到达。此时，服务端进⼊CLOSE_WAIT 状态 接着，当处理完数据后，⾃然就会读到 EOF ，于是也调⽤ close 关闭它的套接字，这会使得客户端会发出⼀个 FIN 包，之后处于 LAST_ACK 状态 客户端接收到服务端的 FIN 包，并发送 ACK 确认包给服务端，此时客户端将进⼊ TIME_WAIT 状态 服务端收到 ACK 确认包后，就进⼊了最后的 CLOSE 状态 客户端经过 2MSL 时间之后，也进⼊ CLOSE 状态； TCP重传，滑动窗口，流量控制，拥塞控制 重传机制 TCP 实现可靠传输的⽅式之⼀，是通过序列号与确认应答\n所以 TCP 针对数据包丢失的情况，会⽤重传机制解决。 接下来说说常⻅的重传机制：\n超时重传： RTT 就是数据从⽹络⼀端传送到另⼀端所需的时间，也就是包的往返时间。 超时重传时间是以 RTO （Retransmission Timeout 超时重传时间）表示 精确的测量超时时间 RTO 的值是⾮常᯿要的，这可让我们的重传机制更⾼效\n快速重传： TCP 还有另外⼀种快速重传（Fast Retransmit）机制，它不以时间为驱动，⽽是以数据驱动重传\n第⼀份 Seq1 先送到了，于是就 Ack 回 2； 结果 Seq2 因为某些原因没收到，Seq3 到达了，于是还是 Ack 回 2； 后⾯的 Seq4 和 Seq5 都到了，但还是 Ack 回 2，因为 Seq2 还是没有收到； 发送端收到了三个 Ack = 2 的确认，知道了 Seq2 还没有收到，就会在定时器过期之前，重传丢失的 Seq2。 最后，收到了 Seq2，此时因为 Seq3，Seq4，Seq5 都收到了，于是 Ack 回 6 快速重传机制只解决了⼀个问题，就是超时时间的问题，但是它依然⾯临着另外⼀个问题。就是重传的时候，是重传之前的⼀个，还是重传所有的问题\nSACK： 还有⼀种实现重传机制的⽅式叫： SACK （ Selective Acknowledgment 选择性确认）。 这种⽅式需要在 TCP 头部「选项」字段⾥加⼀个 SACK 的东⻄，它可以将缓存的地图发送给发送⽅，这样发送⽅就可以知道哪些数据收到了，哪些数据没收到，知道了这些信息，就可以只重传丢失的数据。 D-SACK： Duplicate SACK ⼜称 D-SACK ，其主要使⽤了 SACK 来告诉「发送⽅」有哪些数据被重复接收了 ACK 丢包：\n「接收⽅」发给「发送⽅」的两个 ACK 确认应答都丢失了，所以发送⽅超时后，重传第⼀个数据包（3000 ~3499）\n于是「接收⽅」发现数据是重复收到的，于是回了⼀个 SACK = 3000~3500，告诉「发送⽅」 3000~3500的数据早已被接收了，因为 ACK 都到了 4000 了，已经意味着 4000 之前的所有数据都已收到，所以这个SACK 就代表着 D-SACK 。\n这样「发送⽅」就知道了，数据没有丢，是「接收⽅」的 ACK 确认报⽂丢了\n⽹络延时： 数据包（1000~1499） 被⽹络延迟了，导致「发送⽅」没有收到 Ack 1500 的确认报⽂\n⽽后⾯报⽂到达的三个相同的 ACK 确认报⽂，就触发了快速重传机制，但是在重传后，被延迟的数据包（1000~1499）⼜到了「接收⽅」；\r所以「接收⽅」回了⼀个 SACK=1000~1500，因为 ACK 已经到了 3000，所以这个 SACK 是 D-SACK，表示收到了重复的包\r这样发送⽅就知道快速重传触发的原因不是发出去的包丢了，也不是因为回应的 ACK 包丢了，⽽是因为⽹络延迟了\r可⻅， D-SACK 有这么⼏个好处：\n可以让「发送⽅」知道，是发出去的包丢了，还是接收⽅回应的 ACK 包丢了; 可以知道是不是「发送⽅」的数据包被⽹络延迟了; 可以知道⽹络中是不是把「发送⽅」的数据包给复制了 滑动窗口 如果你说完⼀句话，我在处理其他事情，没有及时回复你，那你不是要⼲等着我做完其他事情后，我回复你，你才能说下⼀句话，很显然这不现实。\n那么有了窗⼝，就可以指定窗⼝⼤⼩，窗⼝⼤⼩就是指⽆需等待确认应答，⽽可以继续发送数据的最⼤值\n窗⼝的实现实际上是操作系统开辟的⼀个缓存空间，发送⽅主机在等到确认应答返回之前，必须在缓冲区中保留已发送的数据。如果按期收到确认应答，此时数据就可以从缓存区清除。\n图中的 ACK 600 确认应答报⽂丢失，也没关系，因为可以通过下⼀个确认应答进⾏确认，只要发送⽅收到了 ACK 700 确认应答，就意味着 700 之前的所有数据「接收⽅」都收到了。这个模式就叫累计确认或者累计应答\nTCP 头⾥有⼀个字段叫 Window ，也就是窗⼝⼤⼩。 这个字段是接收端告诉发送端⾃⼰还有多少缓冲区可以接收数据。于是发送端就可以根据这个接收端的处理能⼒来发送数据，⽽不会导致接收端处理不过来。\n发送⽅的滑动窗⼝ #1 是已发送并收到 ACK确认的数据：1~31 字节 #2 是已发送但未收到 ACK确认的数据：32~45 字节 #3 是未发送但总⼤⼩在接收⽅处理范围内（接收⽅还有空间）：46~51字节 #4 是未发送但总⼤⼩超过接收⽅处理范围（接收⽅没有空间）：52字节以后\n当发送⽅把数据「全部」都⼀下发送出去后，可⽤窗⼝的⼤⼩就为 0 了，表明可⽤窗⼝耗尽，在没收到 ACK 确认之前是⽆法继续发送数据了。\n在下图，当收到之前发送的数据 32~36 字节的 ACK 确认应答后，如果发送窗⼝的⼤⼩没有变化，则滑动窗⼝往右边移动 5 个字节，因为有 5 个字节的数据被应答确认，接下来 52~56 字节⼜变成了可⽤窗⼝，那么后续也就可以发送 52~56 这 5 个字节的数据了\n流量控制 发送⽅不能⽆脑的发数据给接收⽅，要考虑接收⽅处理能⼒\n为了防⽌这种情况发⽣，TCP 规定是不允许同时减少缓存⼜收缩窗⼝的，⽽是采⽤先收缩窗⼝，过段时间再减少缓存，这样就可以避免了丢包情况\nTCP 是如何解决窗⼝关闭时，潜在的死锁现象呢 为了解决这个问题，TCP 为每个连接设有⼀个持续定时器，只要 TCP 连接⼀⽅收到对⽅的零窗⼝通知，就启动持续计时器。\n只要 TCP 连接⼀⽅收到对⽅的零窗⼝通知，就启动持续计时器。 如果持续计时器超时，就会发送窗⼝探测 ( Window probe ) 报⽂，⽽对⽅在确认这个探测报⽂时，给出⾃⼰现在的接收窗⼝⼤⼩\n糊涂窗⼝综合症 如果接收⽅太忙了，来不及取⾛接收窗⼝⾥的数据，那么就会导致发送⽅的发送窗⼝越来越⼩。 到最后，如果接收⽅腾出⼏个字节并告诉发送⽅现在有⼏个字节的窗⼝，⽽发送⽅会义⽆反顾地发送这⼏个字节，这就是糊涂窗⼝综合症\n就好像⼀个可以承载 50 ⼈的⼤巴⻋，每次来了⼀两个⼈，就直接发⻋。除⾮家⾥有矿的⼤巴司机，才敢这样玩，不然迟早破产。要解决这个问题也不难，⼤巴司机等乘客数ᰁ超过了 25 个，才认定可以发⻋\n所以，糊涂窗⼝综合症的现象是可以发⽣在发送⽅和接收⽅： 接收⽅可以通告⼀个⼩的窗⼝ ⽽发送⽅可以发送⼩数据\n于是，要解决糊涂窗⼝综合症，就解决上⾯两个问题就可以了 让接收⽅不通告⼩窗⼝给发送⽅ 让发送⽅避免发送⼩数据\n拥塞控制 在⽹络出现拥堵时，如果继续发送⼤量数据包，可能会导致数据包时延、丢失等，这时 TCP 就会重传数据，但是⼀重传就会导致⽹络的负担更重，于是会导致更⼤的延迟以及更多的丢包，这个情况就会进⼊恶性循环被不断地放⼤\u0026hellip;\n于是，就有了拥塞控制，控制的⽬的就是避免「发送⽅」的数据填满整个⽹络\n拥塞窗⼝ cwnd是发送⽅维护的⼀个的状态变ᰁ，它会根据⽹络的拥塞程度动态变化的\n拥塞控制有哪些控制算法\n慢启动：TCP 在刚建⽴连接完成后，⾸先是有个慢启动的过程，这个慢启动的意思就是⼀点⼀点的提⾼发送数据包的数据，如果⼀上来就发⼤ᰁ的数据，这不是给⽹络添堵吗 慢启动的算法记住⼀个规则就⾏：当发送⽅每收到⼀个 ACK，拥塞窗⼝ cwnd 的⼤⼩就会加 1\n拥塞避免：那么进⼊拥塞避免算法后，它的规则是：每当收到⼀个 ACK 时，cwnd 增加 1/cwnd\n拥塞发⽣：cwnd = cwnd/2 ，也就是设置为原来的⼀半，或设cwnd为1\n快速恢复：拥塞窗⼝ cwnd = ssthresh + 3 （ 3 的意思是确认有 3 个数据包被收到了）； TCP实战抓包分析 tcpdump 和 Wireshark tcpdump 仅⽀持命令⾏格式使⽤，常⽤在 Linux 服务器中抓取和分析⽹络包。 Wireshark 除了可以抓包外，还提供了可视化分析⽹络包的图形⻚⾯\n所以，这两者实际上是搭配使⽤的，先⽤ tcpdump 命令在 Linux 服务器上抓包，接着把抓包的⽂件拖出到Windows 电脑后，⽤ Wireshark 可视化分析\nTCP快速建立连接 TCP重复确认和快速重传 当接收⽅收到乱序数据包时，会发送重复的 ACK，以便告知发送⽅要重发该数据包，当发送⽅收到 3 个重复 ACK时，就会触发快速重传，⽴刻重发丢失数据包。\nTCP流量控制 接收窗⼝是由接收⽅指定的值，存储在 TCP 头部中，它可以告诉发送⽅⾃⼰的 TCP 缓冲空间区⼤⼩，这个缓冲区是给应⽤程序读取数据的空间：\nTCP延迟确认与Nagle算法 快递员开着⼤货⻋送⼀个⼩包裹⼀样浪费\nNagle 算法是如何避免⼤量 TCP ⼩数据报⽂的传输？ 没有已发送未确认报⽂时，⽴刻发送数据。 存在未确认报⽂时，直到「没有已发送未确认报⽂」或「数据⻓度达到 MSS ⼤⼩」时，再发送数据 只要没满⾜上⾯条件中的⼀条，发送⽅⼀直在囤积数据，直到满⾜上⾯的发送条件\n那延迟确认⼜是什么？ 事实上当没有携带数据的 ACK，它的⽹络效率也是很低的，因为它也有 40 个字节的 IP 头 和 TCP 头，但却没有携带数据报⽂。 为了解决 ACK 传输效率低问题，所以就衍⽣出了 TCP 延迟确认。\nTCP 延迟确认的策略：\n当有响应数据要发送时，ACK 会随着响应数据⼀起⽴刻发送给对⽅ 当没有响应数据要发送时，ACK 将会延迟⼀段时间，以等待是否有响应数据可以⼀起发送 如果在延迟等待发送 ACK 期间，对⽅的第⼆个数据报⽂⼜到达了，这时就会⽴刻发送 ACK 当 TCP 延迟确认 和 Nagle 算法混合使⽤时，会导致时耗增⻓\nTCP半连接队列和全连接队列 在 TCP 三次握⼿的时候，Linux 内核会维护两个队列，分别是： 半连接队列，也称 SYN 队列； 全连接队列，也称 accepet 队列；\n服务端收到客户端发起的 SYN 请求后，内核会把该连接存储到半连接队列，并向客户端响应 SYN+ACK，接着客户端会返回 ACK，服务端收到第三次握⼿的 ACK 后，内核会把连接从半连接队列移除，然后创建新的完全的连接，并将其添加到 accept 队列，等待进程调⽤ accept 函数时把连接取出来\nTCP内核参数 TCP 协议是由操作系统实现，所以操作系统提供了不少调节 TCP 的参数\nTCP 三次握⼿的性能提升 客户端优化 三次握⼿建⽴连接的⾸要⽬的是「同步序列号」。 只有同步了序列号才有可靠传输，TCP 许多特性都依赖于序列号实现，⽐如流ᰁ控制、丢包᯿传等，这也是三次握⼿中的报⽂称为 SYN 的原因，SYN 的全称就叫 Synchronize Sequence Numbers（同步序列号）\n以适当调低重试次数，尽快把错误暴露给应⽤程序\n服务端优化 开启 syncookies 功能就可以在不使⽤ SYN 半连接队列的情况下成功建⽴连接。\n绕过三次握⼿ 在 Linux 3.7 内核版本之后，提供了 TCP Fast Open 功能，这个功能可以减少 TCP 连接建⽴的时延\n在客户端⾸次建⽴连接时的过程：\n客户端发送 SYN 报⽂，该报⽂包含 Fast Open 选项，且该选项的 Cookie 为空，这表明客户端请求 Fast Open Cookie； ⽀持 TCP Fast Open 的服务器⽣成 Cookie，并将其置于 SYN-ACK 数据包中的 Fast Open 选项以发回客户端； 客户端收到 SYN-ACK 后，本地缓存 Fast Open 选项中的 Cookie。所以，第⼀次发起 HTTP GET 请求的时候，还是需要正常的三次握⼿流程 之后，如果客户端再次向服务器建⽴连接时的过程：\n客户端发送 SYN 报⽂，该报⽂包含「数据」（对于⾮ TFO 的普通 TCP 握⼿过程，SYN 报⽂中不包含「数据」）以及此前记录的 Cookie； ⽀持 TCP Fast Open 的服务器会对收到 Cookie 进⾏校验：如果 Cookie 有效，服务器将在 SYN-ACK 报⽂中，对 SYN 和「数据」进⾏确认，服务器随后将「数据」递送⾄相应的应⽤程序；如果 Cookie ⽆效，服务器将丢弃 SYN 报⽂中包含的「数据」，且其随后发出的 SYN-ACK 报⽂将只确认 SYN 的对应序列号； 如果服务器接受了 SYN 报⽂中的「数据」，服务器可在握⼿完成之前发送「数据」，这就减少了握⼿带来的1 个 RTT 的时间消耗； 客户端将发送 ACK 确认服务器发回的 SYN 以及「数据」，但如果客户端在初始的 SYN 报⽂中发送的「数据」没有被确认，则客户端将重新发送「数据」； 此后的 TCP 连接的数据传输过程和⾮ TFO 的正常情况⼀致。所以，之后发起 HTTP GET 请求的时候，可以绕过三次握⼿，这就减少了握⼿带来的 1 个 RTT 的时间消耗。开启了 TFO 功能，cookie 的值是存放到 TCP option 字段⾥的 TCP 四次挥⼿的性能提升 客户端和服务端双⽅都可以主动断开连接，通常先关闭连接的⼀⽅称为主动⽅，后关闭连接的⼀⽅称为被动\n可以看到，四次挥⼿过程只涉及了两种报⽂，分别是 FIN 和 ACK FIN 就是结束连接的意思，谁发出 FIN 报⽂，就表示它将不会再发送任何数据，关闭这⼀⽅向上的传输通道； ACK 就是确认的意思，⽤来通知对⽅：你⽅的发送通道已经关闭\nFIN_WAIT1 状态的优化 FIN_WAIT2 状态的优化 TIME_WAIT 状态的优化 被动⽅的优化\n主动⽅的优化 被动⽅的优化 TCP传输数据的性能提升 TCP 连接是由内核维护的，内核会为每个连接建⽴内存缓冲区\n如果连接的内存配置过⼩，就⽆法充分使⽤⽹络带宽，TCP 传输效率就会降低； 如果连接的内存配置过⼤，很容易把服务器资源耗尽，这样就会导致新连接⽆法建⽴； 如何确定最⼤传输速度？ 在前⾯我们知道了 TCP 的传输速度，受制于发送窗⼝与接收窗⼝，以及⽹络设备传输能⼒。其中，窗⼝⼤⼩由内核缓冲区⼤⼩决定。如果缓冲区与⽹络传输能⼒匹配，那么缓冲区的利⽤率就达到了最⼤化。\n相信⼤家都知道⽹络是有「带宽」限制的，带宽描述的是⽹络传输能⼒，它与内核缓冲区的计量单位不同:\n带宽是单位时间内的流ᰁ，表达是「速度」，⽐如常⻅的带宽 100 MB/s； 缓冲区单位是字节，当⽹络速度乘以时间才能得到字节数； IP IP基础知识全家桶 前菜 —— IP 基本认识 IP 在 TCP/IP 参考模型中处于第三层，也就是⽹络层\n⽹络层的主要作⽤是：实现主机与主机之间的通信，也叫点对点（end to end）通信\n其实很容易区分，在上⾯我们知道 IP 的作⽤是主机之间通信⽤的，⽽ MAC 的作⽤则是实现「直连」的两个设备之间通信，⽽ IP 则负责在「没有直连」的两个⽹络之间进⾏通信传输。\n计算机⽹络中也需要「数据链路层」和「⽹络层」这个分层才能实现向最终⽬标地址的通信。\n源IP地址和⽬标IP地址在传输过程中是不会变化的，只有源 MAC 地址和⽬标MAC ⼀直在变化、\n主菜 —— IP 地址的基础知识 IP 地址（IPv4 地址）由 32 位正整数来表示，IP 地址在计算机是以⼆进制的⽅式处理的\n⽽⼈类为了⽅便记忆采⽤了点分⼗进制的标记⽅式，也就是将 32 位 IP 地址以每 8 位为组，共分为 4 组，每组以「 . 」隔开，再将每组转换成⼗进制。\n实际上，IP 地址并不是根据主机台数来配置的，⽽是以⽹卡。像服务器、路由器等设备都是有 2 个以上的⽹卡，也就是它们会有 2 个以上的 IP 地址。\n⽹络号和主机号\n因为在 IP 地址中，有两个 IP 是特殊的，分别是主机号全为 1 和 全为 0 地址。\n主机号全为 1 指定某个⽹络下的所有主机，⽤于⼴播\n主机号全为 0 指定某个⽹络\n⼴播地址⽤于在同⼀个链路中相互连接的主机之间发送数据包\n⼴播地址可以分为本地⼴播和直接⼴播两种\n在本⽹络内⼴播的叫做本地⼴播。例如⽹络地址为 192.168.0.0/24 的情况下，⼴播地址是 192.168.0.255 。因为这个⼴播地址的 IP 包会被路由器屏蔽，所以不会到达 192.168.0.0/24 以外的其他链路上。\n在不同⽹络之间的⼴播叫做直接⼴播。例如⽹络地址为 192.168.0.0/24 的主机向 192.168.1.255/24 的⽬标地址发送 IP 包。收到这个包的路由器，将数据转发给 192.168.1.0/24，从⽽使得所有 192.168.1.1~192.168.1.254 的主机都能收到这个包（由于直接⼴播有⼀定的安全问题，多数情况下会在路由器上设置为不转发。） 。\n⽽ D 类和 E 类地址是没有主机号的，所以不可⽤于主机 IP，D 类常被⽤于多播，E 类是预留的分类，暂时未使⽤\n多播⽤于将包发送给特定组内的所有主机。\nIP 分类的缺点 同⼀⽹络下没有地址层次，⽐如⼀个公司⾥⽤了 B 类地址，但是可能需要根据⽣产环境、测试环境、开发环境来划分地址层次，⽽这种 IP 分类是没有地址层次划分的功能，所以这就缺少地址的灵活性。\nA、B、C类有个尴尬处境，就是不能很好的与现实⽹络匹配\n这两个缺点，都可以在 CIDR ⽆分类地址解决。\n⽆分类地址 CIDR 这种⽅式不再有分类地址的概念，32 ⽐特的 IP 地址被划分为两部分，前⾯是⽹络号，后⾯是主机号。 表示形式 a.b.c.d/x ，其中 /x 表示前 x 位属于⽹络号， x 的范围是 0 ~ 32 ，这就使得 IP 地址更加具有灵活性。\n⽐如 10.100.122.2/24，这种地址表示形式就是 CIDR，/24 表示前 24 位是⽹络号，剩余的 8 位是主机号\n还有另⼀种划分⽹络号与主机号形式，那就是⼦⽹掩码，掩码的意思就是掩盖掉主机号，剩余的就是⽹络号。将⼦⽹掩码和 IP 地址按位计算 AND，就可得到⽹络号\n为什么要分离⽹络号和主机号？ 因为两台计算机要通讯，⾸先要判断是否处于同⼀个⼴播域内，即⽹络地址是否相同。如果⽹络地址相同，表明接受⽅在本⽹络上，那么可以把数据包直接发送到⽬标主机\n路由器寻址⼯作中，也就是通过这样的⽅式来找到对应的⽹络号的，进⽽把数据包转发给对应的⽹络内\n怎么进⾏⼦⽹划分？ 我们知道可以通过⼦⽹掩码划分出⽹络号和主机号，那实际上⼦⽹掩码还有⼀个作⽤，那就是划分⼦⽹\n⼦⽹划分实际上是将主机地址分为两个部分：⼦⽹⽹络地址和⼦⽹主机地址。 未做⼦⽹划分的 ip 地址：⽹络地址＋主机地址 做⼦⽹划分后的 ip 地址：⽹络地址＋（⼦⽹⽹络地址＋⼦⽹主机地址）\n假设对 C 类地址进⾏⼦⽹划分，⽹络地址 192.168.1.0，使⽤⼦⽹掩码 255.255.255.192 对其进⾏⼦⽹划分。 C 类地址中前 24 位是⽹络号，最后 8 位是主机号，根据⼦⽹掩码可知从 8 位主机号中借⽤ 2 位作为⼦⽹号\n公有 IP 地址是有个组织统⼀分配的，假设你要开⼀个博客⽹站，那么你就需要去申请购买⼀个公有 IP，这样全世界的⼈才能访问。并且公有 IP 地址基本上要在整个互联⽹范围内保持唯⼀\n私有 IP 地址通常是内部的 IT ⼈员管理，公有 IP 地址是由 ICANN 组织管理，中⽂叫「互联⽹名称与数字地址分配机构」\nP 地址与路由控制 IP地址的⽹络地址这⼀部分是⽤于进⾏路由控制\n路由控制表中记录着⽹络地址与下⼀步应该发送⾄路由器的地址。在主机和路由器上都会有各⾃的路由器控制表\n在发送 IP 包时，⾸先要确定 IP 包⾸部中的⽬标地址，再从路由控制表中找到与该地址具有相同⽹络地址的记录，根据该记录将 IP 包转发给相应的下⼀个路由器。如果路由控制表中存在多条相同⽹络地址的记录，就选择相同位数最多的⽹络地址，也就是最⻓匹配\nIP 分⽚与重组 每种数据链路的最⼤传输单元 MTU 都是不相同的，如 FDDI 数据链路 MTU 4352、以太⽹的 MTU 是 1500 字节等\n每种数据链路的 MTU 之所以不同，是因为每个不同类型的数据链路的使⽤⽬的不同。使⽤⽬的不同，可承载的MTU 也就不同\n那么当 IP 数据包⼤⼩⼤于 MTU 时， IP 数据包就会被分⽚。\n在分⽚传输中，⼀旦某个分⽚丢失，则会造成整个 IP 数据报作废，所以 TCP 引⼊了 MSS 也就是在 TCP 层进⾏分⽚不由 IP 层分⽚，那么对于 UDP 我们尽ᰁ不要发送⼀个⼤于 MTU 的数据报⽂\nIPv6 基本认识 IPv6 的地址主要有以下类型地址： 单播地址，⽤于⼀对⼀的通信 组播地址，⽤于⼀对多的通信 任播地址，⽤于通信最近的节点，最近的节点是由路由协议决定 没有⼴播地址\nIPv6 相⽐ IPv4 的⾸部改进：\n取消了⾸部校验和字段。 因为在数据链路层和传输层都会校验，因此 IPv6 直接取消了 IP 的校验。\n取消了分⽚/重新组装相关字段。 分⽚与᯿组是耗时的过程，IPv6 不允许在中间路由器进⾏分⽚与重组，这种操作只能在源与⽬标主机，这将⼤⼤提⾼了路由器转发的速度。\n取消选项字段。 选项字段不再是标准 IP ⾸部的⼀部分了，但它并没有消失，⽽是可能出现在 IPv6 ⾸部中的「下⼀个⾸部」指出的位置上。删除该选项字段使的 IPv6 的⾸部成为固定⻓度的 40 字节\n点⼼ —— IP 协议相关技术 DNS 那么实现这⼀技术的就是 DNS 域名解析，DNS 可以将域名⽹址⾃动转换为具体的 IP 地址。\nDNS 中的域名都是⽤句点来分隔的，⽐如 www.server.com ，这⾥的句点代表了不同层次之间的界限\n在域名中，越靠右的位置表示其层级越⾼\n所以域名的层级关系类似⼀个树状结构： 根 DNS 服务器 顶级域 DNS 服务器（com） 权威 DNS 服务器（server.com）\n域名解析的⼯作流程 客户端⾸先会发出⼀个 DNS 请求，问 www.server.com 的 IP 是啥，并发给本地 DNS 服务器（也就是客户端的 TCP/IP 设置中填写的 DNS 服务器地址）。 本地域名服务器收到客户端的请求后，如果缓存⾥的表格能找到 www.server.com，则它直接返回 IP 地址。如果没有，本地 DNS 会去问它的根域名服务器：“⽼⼤， 能告诉我 www.server.com 的 IP 地址吗？” 根域名服务器是最⾼层次的，它不直接⽤于域名解析，但能指明⼀条道路。 根 DNS 收到来⾃本地 DNS 的请求后，发现后置是 .com，说：“www.server.com 这个域名归 .com 区域管理”，我给你 .com 顶级域名服务器地址给你，你去问问它吧。” 本地 DNS 收到顶级域名服务器的地址后，发起请求问“⽼⼆， 你能告诉我 www.server.com 的 IP 地址吗？” 顶级域名服务器说：“我给你负责 www.server.com 区域的权威 DNS 服务器的地址，你去问它应该能问到”。 本地 DNS 于是转向问权威 DNS 服务器：“⽼三，www.server.com对应的IP是啥呀？” server.com 的权威DNS 服务器，它是域名解析结果的原出处。为啥叫权威呢？就是我的域名我做主。 权威 DNS 服务器查询后将对应的 IP 地址 X.X.X.X 告诉本地 DNS。 本地 DNS 再将 IP 地址返回客户端，客户端和⽬标建⽴连接 DNS 域名解析的过程蛮有意思的，整个过程就和我们⽇常⽣活中找⼈问路的过程类似，只指路不带路\nARP 由于主机的路由表中可以找到下⼀跳的 IP 地址，所以可以通过 ARP 协议，求得下⼀跳的 MAC 地址。 简单地说，ARP 是借助 ARP 请求与 ARP 响应两种类型的包确定 MAC 地址的\n主机会通过⼴播发送 ARP 请求，这个包中包含了想要知道的 MAC 地址的主机 IP 地址。 当同个链路中的所有设备收到 ARP 请求时，会去拆开 ARP 请求包⾥的内容，如果 ARP 请求包中的⽬标 IP地址与⾃⼰的 IP 地址⼀致，那么这个设备就将⾃⼰的 MAC 地址塞⼊ ARP 响应包返回给主机 操作系统通常会把第⼀次通过 ARP 获取的 MAC 地址缓存起来，以便下次直接从缓存中找到对应 IP 地址的 MAC地址\nRARP 协议你知道是什么吗？ ARP 协议是已知 IP 地址求 MAC 地址，那 RARP 协议正好相反，它是已知 MAC 地址求 IP 地址。例如将打印机服务器等⼩型嵌⼊式设备接⼊到⽹络时就经常会⽤得到\n通常这需要架设⼀台 RARP 服务器，在这个服务器上注册设备的 MAC 地址及其 IP 地址。然后再将这个设备接⼊到⽹络，接着 该设备会发送⼀条「我的 MAC 地址是XXXX，请告诉我，我的IP地址应该是什么」的请求信息。 RARP 服务器接到这个消息后返回「MAC地址为 XXXX 的设备，IP地址为 XXXX」的信息给这个设备\n最后，设备就根据从 RARP 服务器所收到的应答信息设置⾃⼰的 IP 地址\nDHCP DHCP 在⽣活中我们是很常⻅的了，我们的电脑通常都是通过 DHCP 动态获取 IP 地址，⼤⼤省去了配 IP 信息繁琐的过程\n这 4 个步骤:\n客户端⾸先发起 DHCP 发现报⽂（DHCP DISCOVER） 的 IP 数据报，由于客户端没有 IP 地址，也不知道DHCP 服务器的地址，所以使⽤的是 UDP ⼴播通信，其使⽤的⼴播⽬的地址是 255.255.255.255（端⼝67） 并且使⽤ 0.0.0.0（端⼝ 68） 作为源 IP 地址。DHCP 客户端将该 IP 数据报传递给链路层，链路层然后将帧⼴播到所有的⽹络中设备\nDHCP 服务器收到 DHCP 发现报⽂时，⽤ DHCP 提供报⽂（DHCP OFFER） 向客户端做出响应。该报⽂仍然使⽤ IP ⼴播地址 255.255.255.255，该报⽂信息携带服务器提供可租约的 IP 地址、⼦⽹掩码、默认⽹关、DNS 服务器以及 IP 地址租⽤期。\n客户端收到⼀个或多个服务器的 DHCP 提供报⽂后，从中选择⼀个服务器，并向选中的服务器发送 DHCP 请求报⽂（DHCP REQUEST进⾏响应，回显配置的参数。\n最后，服务端⽤ DHCP ACK 报⽂对 DHCP 请求报⽂进⾏响应，应答所要求的参数。\n⼀旦客户端收到 DHCP ACK 后，交互便完成了，并且客户端能够在租⽤期内使⽤ DHCP 服务器分配的 IP 地址。\n如果租约的 DHCP IP 地址快期后，客户端会向服务器发送 DHCP 请求报⽂：\n服务器如果同意继续租⽤，则⽤ DHCP ACK 报⽂进⾏应答，客户端就会延⻓租期。 服务器如果不同意继续租⽤，则⽤ DHCP NACK 报⽂，客户端就要停⽌使⽤租约的 IP 地址 可以发现，DHCP 交互中，全程都是使⽤ UDP ⼴播通信\n咦，⽤的是⼴播，那如果 DHCP 服务器和客户端不是在同⼀个局域⽹内，路由器⼜不会转发⼴播包，那不是每个⽹络都要配⼀个 DHCP 服务器\n所以，为了解决这⼀问题，就出现了 DHCP 中继代理。有了 DHCP 中继代理以后，对不同⽹段的 IP 地址分配也可以由⼀个 DHCP 服务器统⼀进⾏管理。\nDHCP 客户端会向 DHCP 中继代理发送 DHCP 请求包，⽽ DHCP 中继代理在收到这个⼴播包以后，再以单播的形式发给 DHCP 服务器。 服务器端收到该包以后再向 DHCP 中继代理返回应答，并由 DHCP 中继代理将此包⼴播给 DHCP 客户端 。 因此，DHCP 服务器即使不在同⼀个链路上也可以实现统⼀分配和管理IP地址。\nNAT 提出了⼀种⽹络地址转换 NAT 的⽅法，再次缓解了 IPv4 地址耗尽的问题\n简单的来说 NAT 就是同个公司、家庭、教室内的主机对外部通信时，把私有 IP 地址转换成公有 IP 地址\n由于绝⼤多数的⽹络应⽤都是使⽤传输层协议 TCP 或 UDP 来传输数据的。 因此，可以把 IP 地址 + 端⼝号⼀起进⾏转换。 这样，就⽤⼀个全球 IP 地址就可以了，这种转换技术就叫⽹络地址与端⼝转换 NAPT 图中有两个客户端 192.168.1.10 和 192.168.1.11 同时与服务器 183.232.231.172 进⾏通信，并且这两个客户端的本地端⼝都是 1025\n此时，两个私有 IP 地址都转换 IP 地址为公有地址 120.229.175.121，但是以不同的端⼝号作为区分\n于是，⽣成⼀个 NAPT 路由器的转换表，就可以正确地转换地址跟端⼝的组合，令客户端 A、B 能同时与服务器之间进⾏通信。\n这种转换表在 NAT 路由器上⾃动⽣成。例如，在 TCP 的情况下，建⽴ TCP 连接⾸次握⼿时的 SYN 包⼀经发出，就会⽣成这个表。⽽后⼜随着收到关闭连接时发出 FIN 包的确认应答从表中被删除。\nNAT 那么⽜逼，难道就没缺点了吗 由于 NAT/NAPT 都依赖于⾃⼰的转换表，因此会有以下的问题：\n外部⽆法主动与 NAT 内部服务器建⽴连接，因为 NAPT 转换表没有转换记录。 转换表的⽣成与转换操作都会产⽣性能开销。 通信过程中，如果 NAT 路由器重启了，所有的 TCP 连接都将被重置 第⼀种就是改⽤ IPv6 IPv6 可⽤范围⾮常⼤，以⾄于每台设备都可以配置⼀个公有 IP 地址，就不搞那么多花⾥胡哨的地址转换了，但是IPv6 普及速度还需要⼀些时间。\n第⼆种 NAT 穿透技术 NAT 穿越技术拥有这样的功能，它能够让⽹络应⽤程序主动发现⾃⼰位于 NAT 设备之后，并且会主动获得 NAT 设备的公有 IP，并为⾃⼰建⽴端⼝映射条⽬，注意这些都是 NAT设备后的应⽤程序⾃动完成的\n也就是说，在 NAT 穿透技术中，NAT设备后的应⽤程序处于主动地位，它已经明确地知道 NAT 设备要修改它外发的数据包，于是它主动配合 NAT 设备的操作，主动地建⽴好映射，这样就不像以前由 NAT 设备来建⽴映射了。\n说⼈话，就是客户端主动从 NAT 设备获取公有 IP 地址，然后⾃⼰建⽴端⼝映射条⽬，然后⽤这个条⽬对外通信，就不需要 NAT 设备来进⾏转换了\nICMP ICMP 全称是 Internet Control Message Protocol，也就是互联⽹控制报⽂协议\nICMP 主要的功能包括：确认 IP 包是否成功送达⽬标地址、报告发送过程中 IP 包被废弃的原因和改善⽹络设置等。\n在 IP 通信中如果某个 IP 包因为某种原因未能达到⽬标地址，那么这个具体的原因将由 ICMP 负责通知\nICMP 的这种通知消息会使⽤ IP 进⾏发送\nICMP ⼤致可以分为两⼤类： ⼀类是⽤于诊断的查询消息，也就是「查询报⽂类型」 另⼀类是通知出错原因的错误消息，也就是「差错报⽂类型」\nIGMP 在前⾯我们知道了组播地址，也就是 D 类地址，既然是组播，那就说明是只有⼀组的主机能收到数据包，不在⼀组的主机不能收到数组包，怎么管理是否是在⼀组呢？那么，就需要 IGMP 协议了\nIGMP 是因特⽹组管理协议，⼯作在主机（组播成员）和最后⼀跳路由之间，如上图中的蓝⾊部分 IGMP 报⽂向路由器申请加⼊和退出组播组，默认情况下路由器是不会转发组播包到连接中的主机，除⾮主机通过 IGMP 加⼊到组播组，主机申请加⼊到组播组时，路由器就会记录 IGMP 路由器表，路由器后续就会转发组播包到对应的主机了。\nIGMP 报⽂采⽤ IP 封装，IP 头部的协议号为 2，⽽且 TTL 字段值通常为 1，因为 IGMP 是⼯作在主机与连接的路由器之间\nIGMP ⼯作机制 GMP 分为了三个版本分别是，IGMPv1、IGMPv2、IGMPv3。 接下来，以 IGMPv2 作为例⼦，说说常规查询与响应和离开组播组这两个⼯作机制\n路由器会周期性发送⽬的地址为 224.0.0.1 （表示同⼀⽹段内所有主机和路由器） IGMP 常规查询报⽂。\n主机1 和 主机 3 收到这个查询，随后会启动「报告延迟计时器」，计时器的时间是随机的，通常是 0~10秒，计时器超时后主机就会发送 IGMP 成员关系报告报⽂（源 IP 地址为⾃⼰主机的 IP 地址，⽬的 IP 地址为组播地址）。如果在定时器超时之前，收到同⼀个组内的其他主机发送的成员关系报告报⽂，则⾃⼰不再发送，这样可以减少⽹络中多余的 IGMP 报⽂数量。\n路由器收到主机的成员关系报⽂后，就会在 IGMP 路由表中加⼊该组播组，后续⽹络中⼀旦该组播地址的数据到达路由器，它会把数据包转发出去。\n读者问题：“组播不太懂。。。假设⼀台机器加⼊组播地址，需要把IP改成组播地址吗？如果离开某个组播地址，需要dhcp重新请求个IP吗？” 组播地址不是⽤于机器ip地址的，因为组播地址没有⽹络号和主机号，所以跟dhcp没关系。组播地址⼀般是⽤于udp协议，机器发送UDP组播数据时，⽬标地址填的是组播地址，那么在组播组内的机器都能收到数据包。\n是否加⼊组播组和离开组播组，是由socket⼀个接⼝实现的，主机ip是不⽤改变的\nPING的工作原理 IP协议的助手\u0026ndash;ICMP协议 ping 是基于 ICMP 协议⼯作的，所以要明⽩ ping 的⼯作，⾸先我们先来熟悉 ICMP 协议\nICMP 报⽂是封装在 IP 包⾥⾯，它⼯作在⽹络层，是 IP 协议的助⼿。\n回送消息⽤于进⾏通信的主机或路由器之间，判断所发送的数据包是否已经成功到达对端的⼀种消息， ping 命令就是利⽤这个消息实现的\n可以向对端主机发送回送请求的消息（ ICMP Echo Request Message ，类型 8 ），也可以接收对端主机发回来的回送应答消息（ ICMP Echo Reply Message ，类型 0 ）\n差错报⽂类型 接下来，说明⼏个常⽤的 ICMP 差错报⽂的例⼦： ⽬标不可达消息 —— 类型 为 3 原点抑制消息 —— 类型 4 重定向消息 —— 类型 5 超时消息 —— 类型 11\n⽬标不可达消息（Destination Unreachable Message） —— 类型为 3 ⽹络不可达代码为 0\n主机不可达代码为 1\n协议不可达代码为 2 当主机使⽤ TCP 协议访问对端主机时，能找到对端的主机了，可是对端主机的防⽕墙已经禁⽌ TCP 协议访问，那么会通过 ICMP 协议以协议不可达的原因告知主机\n端⼝不可达代码为 3\n需要进⾏分⽚但设置了不分⽚位代码为 4\n原点抑制消息（ICMP Source Quench Message） —— 类型 4 ICMP 原点抑制消息的⽬的就是为了缓和这种拥堵情况\n当路由器向低速线路发送数据时，其发送队列的缓存变为零⽽⽆法发送出去时，可以向 IP 包的源地址发送⼀个ICMP 原点抑制消息。\n收到这个消息的主机借此了解在整个线路的某⼀处发⽣了拥堵的情况，从⽽增⼤ IP 包的传输间隔，减少⽹络拥堵的情况\n重定向消息（ICMP Redirect Message） —— 类型 5 如果路由器发现发送端主机使⽤了「不是最优」的路径发送数据，那么它会返回⼀个 ICMP 重定向消息给这个主机。\n在这个消息中包含了最合适的路由信息和源数据。这主要发⽣在路由器持有更好的路由信息的情况下。路由器会通过这样的 ICMP 消息告知发送端，让它下次发给另外⼀个路由器\n超时消息（ICMP Time Exceeded Message） —— 类型 11 IP 包中有⼀个字段叫做 TTL （ Time To Live ，⽣存周期），它的值随着每经过⼀次路由器就会减 1，直到减到0 时该 IP 包会被丢弃\nping —— 查询报⽂类型的使⽤ traceroute —— 差错报⽂类型的使⽤ 有⼀款充分利⽤ ICMP 差错报⽂类型的应⽤叫做 traceroute （在UNIX、MacOS中是这个命令，⽽在Windows中对等的命令叫做 tracert ）。\ntraceroute 的第⼀个作⽤就是故意设置特殊的 TTL，来追踪去往⽬的地时沿途经过的路由器。\ntraceroute 还有⼀个作⽤是故意设置不分⽚，从⽽确定路径的 MTU。\n网络综合篇 5.1 键⼊⽹址到⽹⻚显示，期间发⽣了什么 孤单⼩弟 —— HTTP ⾸先浏览器做的第⼀步⼯作就是要对 URL 进⾏解析，从⽽⽣成发送给 Web 服务器的请求信息\n对 URL 进⾏解析之后，浏览器确定了 Web 服务器和⽂件名，接下来就是根据这些信息来⽣成 HTTP 请求消息了\n真实地址查询 —— DNS 通过浏览器解析 URL 并⽣成 HTTP 消息后，需要委托操作系统将消息发送给 Web 服务器 但在发送之前，还有⼀项⼯作需要完成，那就是查询服务器域名对应的 IP 地址，因为委托操作系统发送消息时，必须提供通信对象的 IP 地址\n指南好帮⼿ —— 协议栈 通过 DNS 获取到 IP 后，就可以把 HTTP 的传输⼯作交给操作系统中的协议栈\n协议栈的内部分为⼏个部分，分别承担不同的⼯作。上下关系是有⼀定的规则的，上⾯的部分会向下⾯的部分委托⼯作，下⾯的部分收到委托的⼯作并执⾏。 应⽤程序（浏览器）通过调⽤ Socket 库，来委托协议栈⼯作。协议栈的上半部分有两块，分别是负责收发数据的TCP 和 UDP 协议，它们两会接受应⽤层的委托执⾏收发数据的操作。\n协议栈的下⾯⼀半是⽤ IP 协议控制⽹络包收发操作，在互联⽹上传数据时，数据会被切分成⼀块块的⽹络包，⽽将⽹络包发送给对⽅的操作就是由 IP 负责的。\n此外 IP 中还包括 ICMP 协议和 ARP 协议\nICMP ⽤于告知⽹络包传送过程中产⽣的错误以及各种控制信息。 ARP ⽤于根据 IP 地址查询相应的以太⽹ MAC 地址\nIP 下⾯的⽹卡驱动程序负责控制⽹卡硬件，⽽最下⾯的⽹卡则负责完成实际的收发操作，也就是对⽹线中的信号执⾏发送和接收操作\n可靠传输 —— TCP 这个所谓的「连接」，只是双⽅计算机⾥维护⼀个状态机，在连接建⽴的过程中，双⽅的状态变化时序图就像这样\n所以三次握⼿⽬的是保证双⽅都有发送和接收的能⼒\nTCP 分割数据 MTU ：⼀个⽹络包的最⼤⻓度，以太⽹中⼀般为 1500 字节。 MSS ：除去 IP 和 TCP 头部之后，⼀个⽹络包所能容纳的 TCP 数据的最⼤⻓度。\nTCP 报⽂⽣成 TCP 协议⾥⾯会有两个端⼝，⼀个是浏览器监听的端⼝（通常是随机⽣成的），⼀个是 Web 服务器监听的端⼝（HTTP 默认端⼝号是 80 ， HTTPS 默认端⼝号是 443 ）。\n在双⽅建⽴了连接后，TCP 报⽂中的数据部分就是存放 HTTP 头部 + 数据，组装好 TCP 报⽂之后，就需交给下⾯的⽹络层处理\n远程定位 —— IP TCP 模块在执⾏连接、收发、断开等各阶段操作时，都需要委托 IP 模块将数据封装成⽹络包发送给通信对象。\nIP 报⽂⽣成 两点传输 —— MAC ⽣成了 IP 头部之后，接下来⽹络包还需要在 IP 头部的前⾯加上 MAC 头部\nMAC 头部是以太⽹使⽤的头部，它包含了接收⽅和发送⽅的 MAC 地址等信息。\n在 MAC 包头⾥需要发送⽅ MAC 地址和接收⽅⽬标 MAC 地址，⽤于两点之间的传输\n⼀般在 TCP/IP 通信⾥，MAC 包头的协议类型只使⽤： 0800 ： IP 协议 0806 ： ARP 协议\nMAC 发送⽅和接收⽅如何确认? 发送⽅的 MAC 地址获取就⽐较简单了，MAC 地址是在⽹卡⽣产时写⼊到 ROM ⾥的，只要将这个值读取出来写⼊到 MAC 头部就可以了。\n接收⽅的 MAC 地址就有点复杂了，只要告诉以太⽹对⽅的 MAC 的地址，以太⽹就会帮我们把包发送过去，那么很显然这⾥应该填写对⽅的 MAC 地址。 所以先得搞清楚应该把包发给谁，这个只要查⼀下路由表就知道了。在路由表中找到相匹配的条⽬，然后把包发给Gateway 列中的 IP 地址就可以了。\n在后续操作系统会把本次查询结果放到⼀块叫做 ARP 缓存的内存空间留着以后⽤，不过缓存的时间就⼏分钟\n也就是说，在发包时： 先查询 ARP 缓存，如果其中已经保存了对⽅的 MAC 地址，就不需要发送 ARP 查询，直接使⽤ ARP 缓存中的地址\n⽽当 ARP 缓存中不存在对⽅ MAC 地址时，则发送 ARP ⼴播查询\n出⼝ —— ⽹卡 ⽹络包只是存放在内存中的⼀串⼆进制数字信息，没有办法直接发送给对⽅。因此，我们需要将数字信息转换为电信号，才能在⽹线上传输，也就是说，这才是真正的数据发送过程\n负责执⾏这⼀操作的是⽹卡，要控制⽹卡还需要靠⽹卡驱动程序\n⽹卡驱动从 IP 模块获取到包之后，会将其复制到⽹卡内的缓存区中，接着会在其开头加上报头和起始帧分界符，在末尾加上⽤于检测错误的帧校验序列。\n送别者 —— 交换机 下⾯来看⼀下包是如何通过交换机的。交换机的设计是将⽹络包原样转发到⽬的地。交换机⼯作在 MAC 层，也称为⼆层⽹络设备。\n⾸先，电信号到达⽹线接⼝，交换机⾥的模块进⾏接收，接下来交换机⾥的模块将电信号转换为数字信号。\n然后通过包末尾的 FCS 校验错误，如果没问题则放到缓冲区。这部分操作基本和计算机的⽹卡相同，但交换机的⼯作⽅式和⽹卡不同。\n交换机的端⼝不具有 MAC 地址\n将包存⼊缓冲区后，接下来需要查询⼀下这个包的接收⽅ MAC 地址是否已经在 MAC 地址表中有记录了 交换机的 MAC 地址表主要包含两个信息： ⼀个是设备的 MAC 地址， 另⼀个是该设备连接在交换机的哪个端⼝上。\n交换机根据 MAC 地址表查找 MAC 地址，然后将信号发送到相应的端⼝\n出境⼤⻔ —— 路由器 路由器与交换机的区别 ⽹络包经过交换机之后，现在到达了路由器，并在此被转发到下⼀个路由器或⽬标设备\n这⼀步转发的⼯作原理和交换机类似，也是通过查表判断包转发的⽬标\n因为路由器是基于 IP 设计的，俗称三层⽹络设备，路由器的各个端⼝都具有 MAC 地址和 IP 地址； ⽽交换机是基于以太⽹设计的，俗称⼆层⽹络设备，交换机的端⼝不具有 MAC 地址。\n路由器基本原理 路由器的端⼝具有 MAC 地址，因此它就能够成为以太⽹的发送⽅和接收⽅；同时还具有 IP 地址，从这个意义上来说，它和计算机的⽹卡是⼀样的\n路由器的包接收操作 ⾸先，电信号到达⽹线接⼝部分，路由器中的模块会将电信号转成数字信号，然后通过包末尾的 FCS 进⾏错误校验。\n如果没问题则检查 MAC 头部中的接收⽅ MAC 地址，看看是不是发给⾃⼰的包，如果是就放到接收缓冲区中，否则就丢弃这个包。\n总的来说，路由器的端⼝都具有 MAC 地址，只接收与⾃身地址匹配的包，遇到不匹配的包则直接丢弃\n查询路由表确定输出端⼝ 完成包接收操作之后，路由器就会去掉包开头的 MAC 头部。\nMAC 头部的作⽤就是将包送达路由器，其中的接收⽅ MAC 地址就是路由器端⼝的 MAC 地址。因此，当包到达路由器之后，MAC 头部的任务就完成了，于是 MAC 头部就会被丢弃。\n接下来，路由器会根据 MAC 头部后⽅的 IP 头部中的内容进⾏包的转发操作。\n转发操作分为⼏个阶段，⾸先是查询路由表判断转发⽬标\n路由器的发送操作 ⾸先，我们需要根据路由表的⽹关列判断对⽅的地址。\n如果⽹关是⼀个 IP 地址，则这个IP 地址就是我们要转发到的⽬标地址，还未抵达终点，还需继续需要路由器转发 如果⽹关为空，则 IP 头部中的接收⽅ IP 地址就是要转发到的⽬标地址，也是就终于找到 IP 包头⾥的⽬标地址了，说明已抵达终点。 互相扒⽪ —— 服务器 与 客户端 Linux 系统是如何收发⽹络包的？ ⽹络模型 该模型主要有 7 层，分别是应⽤层、表示层、会话层、传输层、⽹络层、数据链路层以及物理层 应⽤层，负责给应⽤程序提供统⼀的接⼝； 表示层，负责把数据转换成兼容另⼀个系统能识别的格式； 会话层，负责建⽴、管理和终⽌表示层实体之间的通信会话； 传输层，负责端到端的数据传输； ⽹络层，负责数据的路由、转发、分⽚； 数据链路层，负责数据的封帧和差错检测，以及 MAC 寻址； 物理层，负责在物理⽹络中传输数据帧\nTCP/IP ⽹络模型共有 4 层，分别是应⽤层、传输层、⽹络层和⽹络接⼝层，每⼀层负责的职能如下 应⽤层，负责向⽤户提供⼀组应⽤程序，⽐如 HTTP、DNS、FTP 等; 传输层，负责端到端的通信，⽐如 TCP、UDP 等； ⽹络层，负责⽹络包的封装、分⽚、路由、转发，⽐如 IP、ICMP 等； ⽹络接⼝层，负责⽹络包在物理⽹络中的传输，⽐如⽹络包的封帧、 MAC 寻址、差错检测，以及通过⽹卡传输⽹络帧等\nLinux ⽹络协议栈 我们可以把⾃⼰的身体⽐作应⽤层中的数据，打底⾐服⽐作传输层中的 TCP 头，外套⽐作⽹络层中 IP 头，帽⼦和鞋⼦分别⽐作⽹络接⼝层的帧头和帧尾。\n这些新增和头部和尾部，都有各⾃的作⽤，也都是按照特定的协议格式填充，这每⼀层都增加了各⾃的协议头，那⾃然⽹络包的⼤⼩就增⼤了，但物理链路并不能传输任意⼤⼩的数据包，所以在以太⽹中，规定了最⼤传输单元（MTU）是 1500 字节，也就是规定了单次传输的最⼤ IP 包⼤⼩。\n应⽤程序需要通过系统调⽤，来跟 Socket 层进⾏数据交互； Socket 层的下⾯就是传输层、⽹络层和⽹络接⼝层； 最下⾯的⼀层，则是⽹卡驱动程序和硬件⽹卡设备\nLinux 接收⽹络包的流程 最简单的⼀种⽅式就是触发中断，也就是每当⽹卡收到⼀个⽹络包，就触发⼀个中断告诉操作系统 采⽤了更为简化的 TCP/IP 模型，Linux ⽹络协议栈就是按照了该模型来实现的。\n当应⽤程序通过 Socket 接⼝发送数据包，数据包会被⽹络协议栈从上到下进⾏逐层处理后，才会被送到⽹卡队列中，随后由⽹卡将⽹络包发送出去\n⽽在接收⽹络包时，同样也要先经过⽹络协议栈从下到上的逐层处理，最后才会被送到应⽤程序。\n","date":"2024-05-09T13:28:01+08:00","permalink":"https://example.com/p/%E5%9B%BE%E8%A7%A3%E7%BD%91%E7%BB%9C/","title":"图解网络"},{"content":"\n图解HTTP 了解Web及网络基础 使用HTTP协议访问Web HTTP的诞生 网络基础TCP/IP TCP/IP协议族 协议:计算机与网络设备要相互通信，双方就必须基于相同的方法。比如，如何探测到通信目标、由哪一边先发起通信、使用哪种语言进行通信、怎样结束通信等规则都需要事先确定。不同的硬件、操作系统之 间的通信，所有的这一切都需要一种规则。而我们就把这种规则称为协议（protocol）。\nTCP/IP的分层管理 TCP/IP 协议族里重要的一点就是分层。TCP/IP 协议族按层次分别分为以下 4 层：应用层、传输层、网络层和数据链路层。\n把 TCP/IP 层次化是有好处的。比如，如果互联网只由一个协议统筹，某个地方需要改变设计时，就必须把所有部分整体替换掉。而分层之后只需把变动的层替换掉即可。把各层之间的接口部分规划好之后，每个层次内部的设计就能够自由改动了\n应用层：应用层决定了向用户提供应用服务时通信的活动，TCP/IP 协议族内预存了各类通用的应用服务。比如，FTP（FileTransfer Protocol，文件传输协议）和 DNS（Domain Name System，域名系统）服务就是其中两类。 HTTP 协议也处于该层。\n传输层：传输层对上层应用层，提供处于网络连接中的两台计算机之间的数据传输，在传输层有两个性质不同的协议：TCP（Transmission ControlProtocol，传输控制协议）和 UDP（User Data Protocol，用户数据报协议）。\n网络层（网络互连层）：网络层用来处理在网络上流动的数据包。数据包是网络传输的最小数据单位。该层规定了通过怎样的路径（所谓的传输路线）到达对方计算机，并把数据包传送给对方。与对方计算机之间通过多台计算机或网络设备进行传输时，网络层所起的作用就是在众多的选项内选择一条传输路线\n链路层（数据链路层，网络接口层）：用来处理连接网络的硬件部分。包括控制操作系统、硬件的设备驱动、NIC（Network Interface Card，网络适配器，即网卡），及光纤等物理可见部分（还包括连接器等一切传输媒介）。硬件上的范畴均在链路层的作用范围之内\nTCP/IP通信传输流 利用 TCP/IP 协议族进行网络通信时，会通过分层顺序与对方进行通信。发送端从应用层往下走，接收端则往应用层往上走。\n发送端在层与层之间传输数据时，每经过一层时必定会被打上一个该层所属的首部信息。反之，接收端在层与层传输数据时，每经过一层时会把对应的首部消去。\n这种把数据信息包装起来的做法称为封装（encapsulate）。\n与HTTP关系密切的协议：IP,TCP和DNS 负责传输的IP协议 “IP”其实是一种协议的名称\nIP 协议的作用是把各种数据包传送给对方。而要保证确实传送到对方那里，则需要满足各类条件。其中两个重要的条件是 IP 地址和 MAC地址（Media Access Control Address）。\nIP 地址指明了节点被分配到的地址，MAC 地址是指网卡所属的固定地址。IP 地址可以和 MAC 地址进行配对。IP 地址可变换，但 MAC地址基本上不会更改。\n使用 ARP 协议凭借 MAC 地址进行通信，ARP 是一种用以解析地址的协议，根据通信方的 IP 地址就可以反查出对应的 MAC 地址。\n确保可靠性的TCP协议 TCP 位于传输层，提供可靠的字节流服务。\n所谓的字节流服务（Byte Stream Service）是指，为了方便传输，将大块数据分割成以报文段（segment）为单位的数据包进行管理。而可靠的传输服务是指，能够把数据准确可靠地传给对方。一言以蔽之，TCP 协议为了更容易传送大数据才把数据分割，而且 TCP 协议能够确认数据最终是否送达到对方。\n为了准确无误地将数据送达目标处，TCP 协议采用了三次握手（three-way handshaking）策略\n握手过程中使用了 TCP 的标志（flag） —— SYN（synchronize） 和 ACK（acknowledgement）。\n发送端首先发送一个带 SYN 标志的数据包给对方。接收端收到后，回传一个带有 SYN/ACK 标志的数据包以示传达确认信息。最后，发送端再回传一个带 ACK 标志的数据包，代表“握手”结束\n若在握手过程中某个阶段莫名中断，TCP 协议会再次以相同的顺序发送相同的数据包。\n负责域名解析的DNS服务 DNS（Domain Name System）服务是和 HTTP 协议一样位于应用层的协议。它提供域名到 IP 地址之间的解析服务。\n计算机既可以被赋予 IP 地址，也可以被赋予主机名和域名。\n用户通常使用主机名或域名来访问对方的计算机，而不是直接通过 IP地址访问。因为与 IP 地址的一组纯数字相比，用字母配合数字的表示形式来指定计算机名更符合人类的记忆习惯\n但要让计算机去理解名称，相对而言就变得困难了。因为计算机更擅长处理一长串数字\n为了解决上述的问题，DNS 服务应运而生。DNS 协议提供通过域名查找 IP 地址，或逆向从 IP 地址反查域名的服务 各种协议与HTTP协议的关系 URI和URL 统一资源标识符URI URI格式 表示指定的 URI，要使用涵盖全部必要信息的绝对 URI、绝对 URL以及相对 URL。相对 URL，是指从浏览器中基本 URI 处指定的 URL，形如 /image/logo.gif。\n让我们先来了解一下绝对 URI 的格式\n使用 http: 或 https: 等协议方案名获取访问资源时要指定协议类型。不区分字母大小写，最后附一个冒号（:）。 也可使用 data: 或 javascript: 这类指定数据或脚本程序的方案名。\n登录信息（认证） 指定用户名和密码作为从服务器端获取资源时必要的登录信息（身份认证）。此项是可选项。\n服务器地址 使用绝对 URI 必须指定待访问的服务器地址。地址可以是类似hackr.jp 这种 DNS 可解析的名称，或是 192.168.1.1 这类 IPv4 地址名，还可以是 [0:0:0:0:0:0:0:1] 这样用方括号括起来的 IPv6 地址名。\n服务器端口号 指定服务器连接的网络端口号。此项也是可选项，若用户省略则自动使用默认端口号。\n带层次的文件路径 指定服务器上的文件路径来定位特指的资源。这与 UNIX 系统的文件目录结构相似\n查询字符串 针对已指定的文件路径内的资源，可以使用查询字符串传入任意参数。此项可选。\n片段标识符 使用片段标识符通常可标记出已获取资源中的子资源（文档内的某个位置）。但在 RFC 中并没有明确规定其使用方法。该项也为可选项。\n并不是所有的应用程序都符合 RFC\n有一些用来制定 HTTP 协议技术标准的文档，它们被称为RFC（Request for Comments，征求修正意见书）。\n通常，应用程序会遵照由 RFC 确定的标准实现。可以说，RFC 是互联网的设计文档，要是不按照 RFC 标准执行，就有可能导致无法通信的状况。比如，有一台 Web 服务器内的应用服务没有遵照RFC 的标准实现，那 Web 浏览器就很可能无法访问这台服务器了。\n简单的HTTP协议 HTTP协议用于客户端和服务端之间的通信 通过请求和响应的交换达成通信 请求报文是由请求方法、请求 URI、协议版本、可选的请求首部字段和内容实体构成的。\n响应报文基本上由协议版本、状态码（表示请求成功或失败的数字代码）、用以解释状态码的原因短语、可选的响应首部字段以及实体主体构成。\nHTTP是不保存状态的协议 请求URI定位资源 告知服务器意图的HTTP方法 GET:获取资源\nPOST：传输实体主体 虽然用 GET 方法也可以传输实体的主体，但一般不用 GET 方法进行传输，而是用 POST 方法。虽说 POST 的功能与 GET 很相似，但POST 的主要目的并不是获取响应的主体内容。\nPUT：传输文件 鉴于 HTTP/1.1 的 PUT 方法自身不带验证机制，任何人都可以上传文件 , 存在安全性问题，因此一般的 Web 网站不使用该方法。若配合 Web 应用程序的验证机制，或架构设计采用REST（REpresentational State Transfer，表征状态转移）标准的同类Web 网站，就可能会开放使用 PUT方法\nHEAD:获取报文首部 HEAD 方法和 GET 方法一样，只是不返回报文主体部分。用于确认URI 的有效性及资源更新的日期时间等\nDELETE:删除文件 DELETE 方法用来删除文件，是与 PUT 相反的方法。DELETE 方法按请求 URI 删除指定的资源。\nOPTIONS:询问支持的方法 OPTIONS 方法用来查询针对请求 URI 指定的资源支持的方法\nTRACE：追踪路径 TRACE 方法是让 Web 服务器端将之前的请求通信环回给客户端的方法。 发送请求时，在 Max-Forwards 首部字段中填入数值，每经过一个服务器端就将该数字减 1，当数值刚好减到 0 时，就停止继续传输，最后接收到请求的服务器端则返回状态码 200 OK 的响应。 客户端通过 TRACE 方法可以查询发送出去的请求是怎样被加工修改/ 篡改的。这是因为，请求想要连接到源目标服务器可能会通过代理中转，TRACE 方法就是用来确认连接过程中发生的一系列操作。\nCONNECT:CONNECT 方法要求在与代理服务器通信时建立隧道，实现用隧道协议进行 TCP 通信。主要使用 SSL（Secure Sockets Layer，安全套接层）和 TLS（Transport Layer Security，传输层安全）协议把通信内容加密后经网络隧道传输\n使用方法下达命令 持久连接节省通信量 持久连接 持久连接的特点是，只要任意一端没有明确提出断开连接，则保持 TCP 连接状态。 持久连接旨在建立 1 次 TCP 连接后进行多次请求和响应的交互\n持久连接的好处在于减少了 TCP 连接的重复建立和断开所造成的额外开销，减轻了服务器端的负载。另外，减少开销的那部分时间，使HTTP 请求和响应能够更早地结束，这样 Web 页面的显示速度也就相应提高了。\n管线化 持久连接使得多数请求以管线化（pipelining）方式发送成为可能。从前发送请求后需等待并收到响应，才能发送下一个请求。管线化技术出现后，不用等待响应亦可直接发送下一个请求。 使用Cookie的状态管理 HTTP 是无状态协议，它不对之前发生过的请求和响应的状态进行管理。也就是说，无法根据之前的状态进行本次的请求处理。不可否认，无状态协议当然也有它的优点。由于不必保存状态，自然可减少服务器的 CPU 及内存资源的消耗。从另一侧面来说，也正是因为 HTTP 协议本身是非常简单的，所以才会被应用在各种场景里\nCookie 会根据从服务器端发送的响应报文内的一个叫做 Set-Cookie 的首部字段信息，通知客户端保存 Cookie。当下次客户端再往该服务器发送请求时，客户端会自动在请求报文中加入 Cookie 值后发送出去。\n服务器端发现客户端发送过来的 Cookie 后，会去检查究竟是从哪一个客户端发来的连接请求，然后对比服务器上的记录，最后得到之前的状态信息。\nHTTP报文内的HTTP信息 HTTP报文 用于 HTTP 协议交互的信息被称为 HTTP 报文。请求端（客户端）的HTTP 报文叫做请求报文，响应端（服务器端）的叫做响应报文。HTTP 报文本身是由多行（用 CR+LF 作换行符）数据构成的字符串文本。\nHTTP 报文大致可分为报文首部和报文主体两块。两者由最初出现的空行（CR+LF）来划分。通常，并不一定要有报文主体。\n请求报文和响应报文的首部内容由以下数据组成\n请求行 包含用于请求的方法，请求 URI 和 HTTP 版本\n状态行 包含表明响应结果的状态码，原因短语和 HTTP 版本\n首部字段 包含表示请求和响应的各种条件和属性的各类首部：一般有 4 种首部，分别是：通用首部、请求首部、响应首部和实体首部。\n其他 可能包含 HTTP 的 RFC 里未定义的首部（Cookie 等）\n编码提升传输速率 HTTP 在传输数据时可以按照数据原貌直接传输，但也可以在传输过程中通过编码提升传输速率。通过在传输时编码，能有效地处理大量的访问请求。但是，编码的操作需要计算机来完成，因此会消耗更多的 CPU 等资源。\n报文主体和实体主体的差异 报文：是 HTTP 通信中的基本单位，由 8 位组字节流（octet sequence，其中 octet 为 8 个比特）组成，通过 HTTP 通信传输。 实体：作为请求或响应的有效载荷数据（补充项）被传输，其内容由实体首部和实体主体组成。 HTTP 报文的主体用于传输请求或响应的实体主体。\n通常，报文主体等于实体主体。只有当传输中进行编码操作时，实体主体的内容发生变化，才导致它和报文主体产生差异。\n压缩传输的内容编码 向待发送邮件内增加附件时，为了使邮件容量变小，我们会先用 ZIP压缩文件之后再添加附件发送。HTTP 协议中有一种被称为内容编码的功能也能进行类似的操作。\n内容编码指明应用在实体内容上的编码格式，并保持实体信息原样压缩。内容编码后的实体由客户端接收并负责解码。\n常用的内容编码有以下几种。\ngzip（GNU zip） compress（UNIX系统的标准压缩） defate（zlib） identity（不进行编码） 分割发送的分块传输编码 在 HTTP 通信过程中，请求的编码实体资源尚未全部传输完成之前，浏览器无法显示请求页面。在传输大容量数据时，通过把数据分割成多块，能够让浏览器逐步显示页面。\n这种把实体主体分块的功能称为分块传输编码\n分块传输编码会将实体主体分成多个部分（块）。每一块都会用十六进制来标记块的大小，而实体主体的最后一块会使用“0(CR+LF)”来标记。\n发送多种数据的多部分对象集合 在 MIME 扩展中会使用一种称为多部分对象集合（Multipart）的方法，来容纳多份不同类型的数据。\n相应地，HTTP 协议中也采纳了多部分对象集合，发送的一份报文主体内可含有多类型实体。通常是在图片或文本文件等上传时使用\n多部分对象集合包含的对象如下。\nmultipart/form-data 在 Web 表单文件上传时使用\nmultipart/byteranges 状态码 206（Partial Content，部分内容）响应报文包含了多个范 围的内容时使用。\n在 HTTP 报文中使用多部分对象集合时，需要在首部字段里加上Content-type。\n使用 boundary 字符串来划分多部分对象集合指明的各类实体。在boundary 字符串指定的各个实体的起始行之前插入“\u0026ndash;”标记（例如：\u0026ndash;AaB03x、\u0026ndash;THIS_STRING_SEPARATES），而在多部分对象集合对应的字符串的最后插入“\u0026ndash;”标记（例如：\u0026ndash;AaB03x\u0026ndash;、\u0026ndash;THIS_STRING_SEPARATES\u0026ndash;）作为结束。\n获取部分内容的范围请求 以前，用户不能使用现在这种高速的带宽访问互联网，当时，下载一个尺寸稍大的图片或文件就已经很吃力了。如果下载过程中遇到网络中断的情况，那就必须重头开始。为了解决上述问题，需要一种可恢复的机制。所谓恢复是指能从之前下载中断处恢复下载。\n要实现该功能需要指定下载的实体范围。像这样，指定范围发送的请求叫做范围请求（Range Request）。\n对一份 10 000 字节大小的资源，如果使用范围请求，可以只请求5001~10 000 字节内的资源\n内容协商返回最合适的内容 当浏览器的默认语言为英语或中文，访问相同 URI 的 Web 页面时，则会显示对应的英语版或中文版的 Web 页面。这样的机制称为内容协商（Content Negotiation）。\n内容协商机制是指客户端和服务器端就响应的资源内容进行交涉，然后提供给客户端最为适合的资源。内容协商会以响应资源的语言、字符集、编码方式等作为判断的基准\n内容协商技术有以下 3 种类型。\n服务器驱动协商 客户端驱动协商 透明协商：是服务器驱动和客户端驱动的结合体，是由服务器端和客户端各自进行内容协商的一种方法。 返回结果的HTTP状态码 状态码告知从服务器端返回的请求结果 状态码如 200 OK，以 3 位数字和原因短语组成 2xx成功 200 ok 204 no content 该状态码代表服务器接收的请求已成功处理，但在返回的响应报文中不含实体的主体部分\n206 partial content 该状态码表示客户端进行了范围请求，而服务器成功执行了这部分的GET 请求。响应报文中包含由 Content-Range 指定范围的实体内容。\n3xx重定向 301 moved permanently 永久性重定向。该状态码表示请求的资源已被分配了新的 URI，以后应使用资源现在所指的 URI。\n302 found 临时性重定向。该状态码表示请求的资源已被分配了新的 URI，希望用户（本次）能使用新的 URI 访问。\n303 see other 该状态码表示由于请求对应的资源存在着另一个 URI，应使用 GET方法定向获取请求的资源\n当 301、302、303 响应状态码返回时，几乎所有的浏览器都会把POST 改成 GET，并删除请求报文内的主体，之后请求会自动再次发送。\n304 not modified 该状态码表示客户端发送附带条件的请求 2 时，服务器端允许请求访问资源，但未满足条件的情况。304 状态码返回时，不包含任何响应的主体部分\n307 temporary redirect 临时重定向。该状态码与 302 Found 有着相同的含义\n4xx客户端错误 400 bad request 该状态码表示请求报文中存在语法错误。当错误发生时，需修改请求的内容后再次发送请求\n401 unauthorized 该状态码表示发送的请求需要有通过 HTTP 认证（BASIC 认证、DIGEST 认证）的认证信息。\n403 forbidden 该状态码表明对请求资源的访问被服务器拒绝了\n404 not found 该状态码表明服务器上无法找到请求的资源\n5xx服务器错误 500 internal server error 该状态码表明服务器端在执行请求时发生了错误。也有可能是 Web应用存在的 bug 或某些临时的故障\n503 servicre unavailable 该状态码表明服务器暂时处于超负载或正在进行停机维护，现在无法处理请求\n状态码和状况的不一致\n不少返回的状态码响应都是错误的，但是用户可能察觉不到这点。比如 Web 应用程序内部发生错误，状态码依然返回 200 OK，这种情况也经常遇到。\n与HTTP协作的Web服务器 一台 Web 服务器可搭建多个独立域名的 Web 网站，也可作为通信路径上的中转服务器提升传输效率。\n用单台虚拟主机实现多个域名 所以，如果一台服务器内托管了 www.tricorder.jp 和 www.hackr.jp 这两个域名，当收到请求时就需要弄清楚究竟要访问哪个域名。\n在相同的 IP 地址下，由于虚拟主机可以寄存多个不同主机名和域名的 Web 网站，因此在发送 HTTP 请求时，必须在 Host 首部内完整指定主机名或域名的 URI。\n通信数据转发程序：代理，网关，隧道 HTTP 通信时，除客户端和服务器以外，还有一些用于通信数据转发的应用程序，例如代理、网关和隧道。它们可以配合服务器工作。\n这些应用程序和服务器可以将请求转发给通信线路上的下一站服务器，并且能接收从那台服务器发送的响应再转发给客户端。\n代理：代理是一种有转发功能的应用程序，它扮演了位于服务器和客户端“中间人”的角色，接收由客户端发送的请求并转发给服务器，同时也接收服务器返回的响应并转发给客户端。\n网关：网关是转发其他服务器通信数据的服务器，接收从客户端发送来的请求时，它就像自己拥有资源的源服务器一样对请求进行处理。有时客户端可能都不会察觉，自己的通信目标是一个网关。\n隧道：隧道是在相隔甚远的客户端和服务器两者之间进行中转，并保持双方通信连接的应用程序\n代理 代理服务器的基本行为就是接收客户端发送的请求后转发给其他服务器。代理不改变请求 URI，会直接发送给前方持有资源的目标服务器。\n持有资源实体的服务器被称为源服务器。从源服务器返回的响应经过代理服务器后再传给客户端。\n每次通过代理服务器转发请求或响应时，会追加写入 Via 首部信息\n在 HTTP 通信过程中，可级联多台代理服务器。请求和响应的转发会经过数台类似锁链一样连接起来的代理服务器。转发时，需要附加Via 首部字段以标记出经过的主机信息。\n使用代理服务器的理由有：利用缓存技术（稍后讲解）减少网络带宽的流量，组织内部针对特定网站的访问控制，以获取访问日志为主要目的，等等。\n代理有多种使用方法，按两种基准分类。一种是是否使用缓存，另一种是是否会修改报文。\n缓存代理 代理转发响应时，缓存代理（Caching Proxy）会预先将资源的副本（缓存）保存在代理服务器上。 当代理再次接收到对相同资源的请求时，就可以不从源服务器那里获取资源，而是将之前缓存的资源作为响应返回\n透明代理 转发请求或响应时，不对报文做任何加工的代理类型被称为透明代理（Transparent Proxy）。反之，对报文内容进行加工的代理被称为非透明代理。 网关 利用网关可以由 HTTP 请求转化为其他协议通信\n利用网关能提高通信的安全性，因为可以在客户端与网关之间的通信线路上加密以确保连接的安全。比如，网关可以连接数据库，使用SQL语句查询数据。另外，在 Web 购物网站上进行信用卡结算时， 网关可以和信用卡结算系统联动。\n隧道 隧道可按要求建立起一条与其他服务器的通信线路，届时使用 SSL等加密手段进行通信。隧道的目的是确保客户端能与服务器进行安全的通信。\n隧道本身不会去解析 HTTP 请求。也就是说，请求保持原样中转给之后的服务器。隧道会在通信双方断开连接时结束。\n保存资源的缓存 缓存是指代理服务器或客户端本地磁盘内保存的资源副本。利用缓存可减少对源服务器的访问，因此也就节省了通信流量和通信时间。\n缓存的有效期限 客户端的缓存 缓存不仅可以存在于缓存服务器内，还可以存在客户端浏览器中。以Internet Explorer 程序为例，把客户端缓存称为临时网络文件\n浏览器缓存如果有效，就不必再向服务器请求相同的资源了，可以直接从本地磁盘内读取\n另外，和缓存服务器相同的一点是，当判定缓存过期后，会向源服务器确认资源的有效性。若判断浏览器缓存失效，浏览器会再次请求新资源。\nHTTP首部 HTTP报文首部 HTTP首部字段 HTTP首部字段传递重要信息 使用首部字段是为了给浏览器和服务器提供报文主体大小、所使用的语言、认证信息等内容。\nHTTP首部字段结构 HTTP 首部字段是由首部字段名和字段值构成的，中间用冒号“:” 分隔。\n4种HTTP首部字段类型 通用首部字段 请求报文和响应报文两方都会使用的首部\n请求首部字段 从客户端向服务器端发送请求报文时使用的首部。补充了请求的附加内容、客户端信息、响应内容相关优先级等信息。\n响应首部字段 从服务器端向客户端返回响应报文时使用的首部。补充了响应的附加内容，也会要求客户端附加额外的内容信息\n实体首部字段 针对请求报文和响应报文的实体部分使用的首部。补充了资源内容更新时间等与实体有关的信息\nHTTP/1.1首部一览 4个表\n非HTTP/1.1首部字段 还有 Cookie、Set-Cookie 和 Content-Disposition等在其他 RFC 中定义的首部字段，它们的使用频率也很高。\n这些非正式的首部字段统一归纳在 RFC4229 HTTP Header Field Registrations 中\nend-to-end首部和hop-by-hop首部 HTTP 首部字段将定义成缓存代理和非缓存代理的行为，分成 2 种类型\n端到端首部 分在此类别中的首部会转发给请求 / 响应对应的最终接收目标，且必须保存在由缓存生成的响应中，另外规定它必须被转发\n逐跳首部 分在此类别中的首部只对单次转发有效，会因通过缓存或代理而不再转发。HTTP/1.1 和之后版本中，如果要使用 hop-by-hop 首部，需提供 Connection 首部字段。\nHTTP/1.1通用首部字段 cache-control 通过指定首部字段 Cache-Control 的指令，就能操作缓存的工作机制。\n表示是否能缓存的指令\npublic：当指定使用 public 指令时，则明确表明其他用户也可利用缓存\nprivate：当指定 private 指令后，响应只以特定的用户作为对象，这与 public指令的行为相反。缓存服务器会对该特定用户提供资源缓存的服务，对于其他用户发送过来的请求，代理服务器则不会返回缓存。\nno-cache 使用 no-cache 指令的目的是为了防止从缓存中返回过期的资源。\n控制可执行缓存的对象的指令\nno-store 当使用 no-store 指令 1 时，暗示请求（和对应的响应）或响应中包含机密信息。 从字面意思上很容易把 no-cache 误解成为不缓存，但事实上 no-cache 代表不缓存过期的资源，缓存会向源服务器进行有效期确认后处理资源，也许称为 do-not-serve-from-cache-without-revalidation 更合适。no-store 才是真正地不进行缓存，请读者注意区别\n因此，该指令规定缓存不能在本地存储请求或响应的任一部分。\ns-maxage s-maxage 指令的功能和 max-age 指令的相同，它们的不同点是 s-maxage 指令只适用于供多位用户使用的公共缓存服务器。也就是说，对于向同一用户重复返回响应的服务器来说，这个指令没有任何作用。\nmax-age 当客户端发送的请求中包含 max-age 指令时，如果判定缓存资源的缓存时间数值比指定时间的数值更小，那么客户端就接收缓存的资源。另外，当指定 max-age 值为 0，那么缓存服务器通常需要将请求转发给源服务器。\nmin-fresh 要求缓存服务器返回至少还未过指定时间的缓存资源\nmax-stale 使用 max-stale 可指示缓存资源，即使过期也照常接收\nonly-if-cached 使用 only-if-cached 指令表示客户端仅在缓存服务器本地缓存目标资源的情况下才会要求其返回。换言之，该指令要求缓存服务器不重新加载响应，也不会再次确认资源有效性。若发生请求缓存服务器的本地缓存无响应，则返回状态码 504 Gateway Timeout。\nmust-revalidate 使用 must-revalidate 指令，代理会向源服务器再次验证即将返回的响应缓存目前是否仍然有效。\nproxy-revaliadte proxy-revalidate 指令要求所有的缓存服务器在接收到客户端带有该指令的请求返回响应之前，必须再次验证缓存的有效性。\nno-transform 使用 no-transform 指令规定无论是在请求还是响应中，缓存都不能改变实体主体的媒体类型\n这样做可防止缓存或代理压缩图片等类似操作。\ncache-control 扩展\ncache-extension token\n通过 cache-extension 标记（token），可以扩展 Cache-Control 首部字段内的指令\n如上例，Cache-Control 首部字段本身没有 community 这个指令。借助extension tokens 实现了该指令的添加。如果缓存服务器不能理解community 这个新指令，就会直接忽略。因此，extension tokens 仅对能理解它的缓存服务器来说是有意义的\nConnection Connection 首部字段具备如下两个作用。\n控制不再转发给代理的首部字段 管理持久化连接 控制不再转发给代理的首部字段 Connection: 不再转发的首部字段名\nHTTP/1.1 版本的默认连接都是持久连接。为此，客户端会在持久连接上连续发送请求。当服务器端想明确断开连接时，则指定Connection 首部字段的值为 Close。\nDate 首部字段 Date 表明创建 HTTP 报文的日期和时间\nPragma Pragma 是 HTTP/1.1 之前版本的历史遗留字段，仅作为与 HTTP/1.0的向后兼容而定义\n所有的中间服务器如果都能以 HTTP/1.1 为基准，那直接采用 Cache-Control: no-cache 指定缓存的处理方式是最为理想的。但要整体掌握全部中间服务器使用的 HTTP 协议版本却是不现实的。因此，发送的请求会同时含有下面两个首部字段。\nCache-Control: no-cache Pragma: no-cache\nTrailer 首部字段 Trailer 会事先说明在报文主体后记录了哪些首部字段。该首部字段可应用在 HTTP/1.1 版本分块传输编码时\nTransfer-Encoding 首部字段 Transfer-Encoding 规定了传输报文主体时采用的编码方式。\nUpgrade 首部字段 Upgrade 用于检测 HTTP 协议及其他协议是否可使用更高的版本进行通信，其参数值可以用来指定一个完全不同的通信协议\nVia 使用首部字段 Via 是为了追踪客户端与服务器之间的请求和响应报文的传输路径。\nWarning HTTP/1.1 的 Warning 首部是从 HTTP/1.0 的响应首部（Retry-After）演变过来的。该首部通常会告知用户一些与缓存相关的问题的警告。 请求首部字段 Accept Accept 首部字段可通知服务器，用户代理能够处理的媒体类型及媒体类型的相对优先级。可使用 type/subtype 这种形式，一次指定多种媒体类型。\nAccept-Charset Accept-Charset 首部字段可用来通知服务器用户代理支持的字符集及字符集的相对优先顺序\nAccept-Encoding Accept-Encoding 首部字段用来告知服务器用户代理支持的内容编码及内容编码的优先级顺序\n压缩方式或不压缩\nAccept-Language Authorization 首部字段 Authorization 是用来告知服务器，用户代理的认证信息（证书值）。\nExpect 客户端使用首部字段 Expect 来告知服务器，期望出现的某种特定行为。\nFrom 首部字段 From 用来告知服务器使用用户代理的用户的电子邮件地址\nHost 首部字段 Host 会告知服务器，请求的资源所处的互联网主机名和端口号。Host 首部字段在 HTTP/1.1 规范内是唯一一个必须被包含在请求内的首部字段。\nIf-Match 形如 If-xxx 这种样式的请求首部字段，都可称为条件请求，服务器接收到附带条件的请求后，只有判断指定条件为真时，才会执行请求\n只有当 If-Match 的字段值跟 ETag 值匹配一致时，服务器才会接受请求\n服务器会比对 If-Match 的字段值和资源的 ETag 值，仅当两者一致时，才会执行请求。反之，则返回状态码 412 Precondition Failed 的响应。\n还可以使用星号（*）指定 If-Match 的字段值。针对这种情况，服务器将会忽略 ETag 的值，只要资源存在就处理请求\nIf-None-Match If-Range 首部字段 If-Range 属于附带条件之一。它告知服务器若指定的 If-Range 字段值（ETag 值或者时间）和请求资源的 ETag 值或时间相一致时，则作为范围请求处理。反之，则返回全体资源。\nIf-Unmodified-Since 首部字段 If-Unmodified-Since 和首部字段 If-Modified-Since 的作用相反。它的作用的是告知服务器，指定的请求资源只有在字段值内指定的日期时间之后，未发生更新的情况下，才能处理请求。如果在指定日期时间后发生了更新，则以状态码 412 Precondition Failed 作为响应返回。\nMax-Forwards 通过 TRACE 方法或 OPTIONS 方法，发送包含首部字段 Max-Forwards 的请求时，该字段以十进制整数形式指定可经过的服务器最大数目。服务器在往下一个服务器转发请求之前，Max-Forwards 的值减 1 后重新赋值。当服务器接收到 Max-Forwards 值为 0 的请求时，则不再进行转发，而是直接返回响应。\nProxy-Authorization 接收到从代理服务器发来的认证质询时，客户端会发送包含首部字段Proxy-Authorization 的请求，以告知服务器认证所需要的信息。\nRange 对于只需获取部分资源的范围请求，包含首部字段 Range 即可告知服务器资源的指定范围。上面的示例表示请求获取从第 5001 字节至第10000 字节的资源。\nReferer 首部字段 Referer 会告知服务器请求的原始资源的 URI。\n客户端一般都会发送 Referer 首部字段给服务器。但当直接在浏览器的地址栏输入 URI，或出于安全性的考虑时，也可以不发送该首部字段。\n因为原始资源的 URI 中的查询字符串可能含有 ID 和密码等保密信息，要是写进 Referer 转发给其他服务器，则有可能导致保密信息的泄露。\nTE 首部字段 TE 会告知服务器客户端能够处理响应的传输编码方式及相对优先级。它和首部字段 Accept-Encoding 的功能很相像，但是用于传输编码\nUser-Agent User-Agent 用于传达浏览器的种类\n首部字段 User-Agent 会将创建请求的浏览器和用户代理名称等信息传达给服务器。\n由网络爬虫发起请求时，有可能会在字段内添加爬虫作者的电子邮件地址。此外，如果请求经过代理，那么中间也很可能被添加上代理服务器的名称。\n响应首部字段 Accpet-Range 首部字段 Accept-Ranges 是用来告知客户端服务器是否能处理范围请求，以指定获取服务器端某个部分的资源。\n可指定的字段值有两种，可处理范围请求时指定其为 bytes，反之则指定其为 none。\nAge 首部字段 Age 能告知客户端，源服务器在多久前创建了响应。字段值的单位为秒。\nETag 首部字段 ETag 能告知客户端实体标识。它是一种可将资源以字符串形式做唯一性标识的方式。服务器会为每份资源分配对应的 ETag值。\n资源被缓存时，就会被分配唯一性标识。例如，当使用中文版的浏览器访问 http://www.google.com/ 时，就会返回中文版对应的资源，而使用英文版的浏览器访问时，则会返回英文版对应的资源。两者的URI 是相同的，所以仅凭 URI 指定缓存的资源是相当困难的。若在下载过程中出现连接中断、再连接的情况，都会依照 ETag 值来指定资源。\n强ETag值：不论实体发生多么细微的变化都会改变其值\n弱Etag值：弱 ETag 值只用于提示资源是否相同。只有资源发生了根本改变，产生差异时才会改变 ETag 值。这时，会在字段值最开始处附加 W/\nLocation 使用首部字段 Location 可以将响应接收方引导至某个与请求 URI 位置不同的资源。\n几乎所有的浏览器在接收到包含首部字段 Location 的响应后，都会强制性地尝试对已提示的重定向资源的访问。\nProxy-Authenticate 首部字段 Proxy-Authenticate 会把由代理服务器所要求的认证信息发送给客户端\nRetry-After 首部字段 Retry-After 告知客户端应该在多久之后再次发送请求。主要配合状态码 503 Service Unavailable 响应，或 3xx Redirect 响应一起使用。\nServer 首部字段 Server 告知客户端当前服务器上安装的 HTTP 服务器应用程序的信息。不单单会标出服务器上的软件应用名称，还有可能包括版本号和安装时启用的可选项。\nVary 当代理服务器接收到带有 Vary 首部字段指定获取资源的请求时，如果使用的 Accept-Language 字段的值相同，那么就直接从缓存返回响应。反之，则需要先从源服务器端获取资源后才能作为响应返回\nWWW-Authenticate 首部字段 WWW-Authenticate 用于 HTTP 访问认证。它会告知客户端适用于访问请求 URI 所指定资源的认证方案（Basic 或是 Digest）和带参数提示的质询\n实体首部字段 Allow 首部字段 Allow 用于通知客户端能够支持 Request-URI 指定资源的所有 HTTP 方法。\nContent-Encodeing Content-Languange Content-Length 首部字段 Content-Length 表明了实体主体部分的大小\nContent-Location 首部字段 Content-Location 给出与报文主体部分相对应的 URI。和首部字段 Location 不同，Content-Location 表示的是报文主体返回资源对应的 URI。\nContent-MD5 客户端会对接收的报文主体执行相同的 MD5 算法，然后与首部字段 Content-MD5 的字段值比较\n首部字段 Content-MD5 是一串由 MD5 算法生成的值，其目的在于检查报文主体在传输过程中是否保持完整，以及确认传输到达。\nContent-Range 针对范围请求，返回响应时使用的首部字段 Content-Range，能告知客户端作为响应返回的实体的哪个部分符合范围请求\nContent-Type 首部字段 Content-Type 说明了实体主体内对象的媒体类型\nExpires 首部字段 Expires 会将资源失效的日期告知客户端。缓存服务器在接收到含有首部字段 Expires 的响应后，会以缓存来应答请求，在Expires 字段值指定的时间之前，响应的副本会一直被保存。当超过指定的时间后，缓存服务器在请求发送过来时，会转向源服务器请求资源。\nLast-Modified 首部字段 Last-Modified 指明资源最终修改的时间\n为Cookie服务的首部字段 Cookie 的工作机制是用户识别及状态管理\nSet-Cookie 当服务器准备开始管理客户端的状态时，会事先告知各种信息\nCookie 首部字段 Cookie 会告知服务器，当客户端想获得 HTTP 状态管理支持时，就会在请求中包含从服务器接收到的 Cookie。接收到多个Cookie 时，同样可以以多个 Cookie 形式发送。\n其他首部字段 X-Frame-Options 首部字段 X-Frame-Options 属于 HTTP 响应首部，用于控制网站内容在其他 Web 网站的 Frame 标签内的显示问题。其主要目的是为了防止点击劫持（clickjacking）攻击\nDENY ：拒绝 SAMEORIGIN ：仅同源域名下的页面（Top-level-browsing-context）匹配时许可 DNT 首部字段 DNT 属于 HTTP 请求首部，其中 DNT 是 Do Not Track 的简称，意为拒绝个人信息被收集，是表示拒绝被精准广告追踪的一种方法。\nX-XSS-Protection 首部字段 X-XSS-Protection 属于 HTTP 响应首部，它是针对跨站脚本攻击（XSS）的一种对策，用于控制浏览器 XSS 防护机制的开关。\nP3P 首部字段 P3P 属于 HTTP 相应首部，通过利用 P3P（The Platform forPrivacy Preferences，在线隐私偏好平台）技术，可以让 Web 网站上的个人隐私变成一种仅供程序可理解的形式，以达到保护用户隐私的目的。\n确保Web安全的HTTPS HTTP的缺点 通信使用明文可能会被窃听 由于 HTTP 本身不具备加密的功能，所以也无法做到对通信整体（使用 HTTP 协议通信的请求和响应的内容）进行加密。即，HTTP 报文使用明文（指未经过加密的报文）方式发送\n加密处理防止被窃听\n通信的加密 通过和 SSL（Secure Socket Layer，安全套接层）或TLS（Transport Layer Security，安全层传输协议）的组合使用，加密 HTTP 的通信内容\n与 SSL组合使用的 HTTP 被称为 HTTPS（HTTPSecure，超文本传输安全协议）或 HTTP over SSL\n内容的加密 还有一种将参与通信的内容本身加密的方式。由于 HTTP 协议中没有加密机制，那么就对 HTTP 协议传输的内容本身加密。即把HTTP 报文里所含的内容进行加密处理。\n不验证通信方的身份就可能遭遇伪装 任何人都可发起请求\n查明对手的证书 虽然使用 HTTP 协议无法确定通信方，但如果使用 SSL则可以。SSL不仅提供加密处理，而且还使用了一种被称为证书的手段，可用于确定方。\n证书由值得信任的第三方机构颁发，用以证明服务器和客户端是实际存在的。\n无法证明报文完整性，可能已遭篡改 接收到的内容可能有误\n如何防止篡改 虽然有使用 HTTP 协议确定报文完整性的方法，但事实上并不便捷、可靠。其中常用的是 MD5 和 SHA-1 等散列值校验的方法，以及用来确认文件的数字签名方法\nHTTP+加密+认证+完整性保护 = HTTPS HTTPS是身披SSL外壳的HTTP 通常，HTTP 直接和 TCP 通信。当使用 SSL时，则演变成先和 SSL通信，再由 SSL和 TCP 通信了\n可以说 SSL是当今世界上应用最为广泛的网络安全技术。\n相互交换密钥的公开密钥加密技术 在对 SSL进行讲解之前，我们先来了解一下加密方法。SSL采用一种叫做公开密钥加密（Public-key cryptography）的加密处理方式。\n近代的加密方法中加密算法是公开的，而密钥却是保密的。通过这种方式得以保持加密方法的安全性\n加密和解密同用一个密钥的方式称为共享密钥加密（Common keycrypto system），也被叫做对称密钥加密\n公开密钥加密方式很好地解决了共享密钥加密的困难。\n公开密钥加密使用一对非对称的密钥。一把叫做私有密钥（private key），另一把叫做公开密钥（public key）。顾名思义，私有密钥不能让其他任何人知道，而公开密钥则可以随意发布，任何人都可以获得。\nHTTPS采用混合混合加密机制 HTTPS 采用共享密钥加密和公开密钥加密两者并用的混合加密机制。 若密钥能够实现安全交换，那么有可能会考虑仅使用公开密钥加密来通信。但是公开密钥加密与共享密钥加密相比，其处理速度要慢。\n证明公开密钥正确性的证书 遗憾的是，公开密钥加密方式还是存在一些问题的。那就是无法证明公开密钥本身就是货真价实的公开密钥。\n为了解决上述问题，可以使用由数字证书认证机构（CA，CertificateAuthority）和其相关机关颁发的公开密钥证书。\n数字证书认证机构处于客户端与服务器双方都可信赖的第三方机构的立场上。威瑞信（VeriSign）就是其中一家非常有名的数字证书认证机构。我们来介绍一下数字证书认证机构的业务流程。首先，服务器的运营人员向数字证书认证机构提出公开密钥的申请。数字证书认证机构在判明提出申请者的身份之后，会对已申请的公开密钥做数字签名，然后分配这个已签名的公开密钥，并将该公开密钥放入公钥证书后绑定在一起。服务器会将这份由数字证书认证机构颁发的公钥证书发送给客户端，以进行公开密钥加密方式通信。公钥证书也可叫做数字证书或直接称为证书接到证书的客户端可使用数字证书认证机构的公开密钥，对那张证书上的数字签名进行验证，一旦验证通过，客户端便可明确两件事：一，认证服务器的公开密钥的是真实有效的数字证书认证机构。二，服务器的公开密钥是值得信赖的。\n可证明组织真实性的EV SSL证书 证书的一个作用是用来证明作为通信一方的服务器是否规范，另外一个作用是可确认对方服务器背后运营的企业是否真实存在。拥有该特性的证书就是 EV SSL证书（Extended Validation SSLCertificate）\n用以确认客户端的客户端证书\n认证机构信誉第一\n由自认证机构颁发的证书称为自签名证书\nHTTPS的安全通信机制 HTTPS通信\n步骤 1： 客户端通过发送 Client Hello 报文开始 SSL通信。报文中包含客户端支持的 SSL的指定版本、加密组件（Cipher Suite）列表（所使用的加密算法及密钥长度等）。\n步骤 2： 服务器可进行 SSL通信时，会以 Server Hello 报文作为应答。和客户端一样，在报文中包含 SSL版本以及加密组件。服务器的加密组件内容是从接收到的客户端加密组件内筛选出来的\n步骤 3：之后服务器发送 Certificate 报文。报文中包含公开密钥证书。\n步骤 4： 最后服务器发送 Server Hello Done 报文通知客户端，最初阶段的 SSL握手协商部分结束。\n步骤 5： SSL第一次握手结束之后，客户端以 Client Key Exchange 报文作为回应。报文中包含通信加密中使用的一种被称为 Pre-mastersecret 的随机密码串。该报文已用步骤 3 中的公开密钥进行加密。\n步骤 6： 接着客户端继续发送 Change Cipher Spec 报文。该报文会提示服务器，在此报文之后的通信会采用 Pre-master secret 密钥加密。\n步骤 7： 客户端发送 Finished 报文。该报文包含连接至今全部报文的整体校验值。这次握手协商是否能够成功，要以服务器是否能够正确解密该报文作为判定标准。\n步骤 8： 服务器同样发送 Change Cipher Spec 报文。\n步骤 9： 服务器同样发送 Finished 报文。\n步骤 10： 服务器和客户端的 Finished 报文交换完毕之后，SSL连接就算建立完成。当然，通信会受到 SSL的保护。从此处开始进行应用层协议的通信，即发送 HTTP 请求。\n步骤 11： 应用层协议通信，即发送 HTTP 响应。\n步骤 12： 最后由客户端断开连接。断开连接时，发送 close_notify 报文。上图做了一些省略，这步之后再发送 TCP FIN 报文来关闭与 TCP的通信。\n在以上流程中，应用层发送数据时会附加一种叫做 MAC（MessageAuthentication Code）的报文摘要。MAC 能够查知报文是否遭到篡改，从而保护报文的完整性。\nHTTPS 也存在一些问题，那就是当使用 SSL时，它的处理速度会变慢。\n与纯文本通信相比，加密通信会消耗更多的CPU 及内存资源。如果每次通信都加密，会消耗相当多的资源，平摊到一台计算机上时，能够处理的请求数量必定也会随之减少。\n因此，如果是非敏感信息则使用 HTTP 通信，只有在包含个人信息等敏感数据时，才利用 HTTPS 加密通信。\n要进行 HTTPS 通信，证书是必不可少的。而使用的证书必须向认证机构（CA）购买\n确认访问用户身份的认证 何为认证 核对的信息通常是指以下这些。\n密码：只有本人才会知道的字符串信息。 动态令牌：仅限本人持有的设备内显示的一次性密码。 数字证书：仅限本人（终端）持有的信息 生物认证：指纹和虹膜等本人的生理信息。 IC 卡等：仅限本人持有的信息。 BASIC认证 DIGEST认证 DIGEST 认证同样使用质询 / 响应的方式（challenge/response），但不会像 BASIC 认证那样直接发送明文密码。\n所谓质询响应方式是指，一开始一方会先发送认证要求给另一方，接着使用从另一方那接收到的质询码计算生成响应码。最后将响应码返回给对方进行认证的方式。\nSSL客户端认证 SSL客户端认证是借由 HTTPS 的客户端证书完成认证的方式。凭借客户端证书（在 HTTPS 一章已讲解）认证，服务器可确认访问是否来自已登录的客户端\nSSL客户端认证采用双因素认证 换言之，第一个认证因素的 SSL客户端证书用来认证客户端计算机，另一个认证因素的密码则用来确定这是用户本人的行为。\nSSL客户端认证必要的费用 基于表单认证 认证多半为基于表单认证 由于使用上的便利性及安全性问题，HTTP 协议标准提供的 BASIC 认证和 DIGEST 认证几乎不怎么使用。另外，SSL客户端认证虽然具有高度的安全等级，但因为导入及维持费用等问题，还尚未普及。\nSession管理及Cookie应用 基于表单认证的标准规范尚未有定论，一般会使用 Cookie 来管理Session（会话）。\n步骤 1： 客户端把用户 ID 和密码等登录信息放入报文的实体部分，通常是以 POST 方法把请求发送给服务器。而这时，会使用 HTTPS通信来进行 HTML表单画面的显示和用户输入数据的发送\n步骤 2： 服务器会发放用以识别用户的 Session ID。通过验证从客户端发送过来的登录信息进行身份认证，然后把用户的认证状态与Session ID 绑定后记录在服务器端。\n步骤 3： 客户端接收到从服务器端发来的 Session ID 后，会将其作为Cookie 保存在本地。下次向服务器发送请求时，浏览器会自动发送Cookie，所以 Session ID 也随之发送到服务器。服务器端可通过验证接收到的 Session ID 识别用户和其认证状态。\n通常，一种安全的保存方法是，先利用给密码加盐（salt）1 的方式增加额外信息，再使用散列（hash）函数计算出散列值后保存。但是我们也经常看到直接保存明文密码的做法，而这样的做法具有导致密码泄露的风险。\n基于HTTP的功能追加协议 基于HTTP协议 消除HTTP瓶颈的SPDY HTTP的瓶颈 一条连接上只可发送一个请求。 请求只能从客户端开始。客户端不可以接收除响应以外的指令。 请求 / 响应首部未经压缩就发送。首部信息越多延迟越大 发送冗长的首部。每次互相发送相同的首部造成的浪费较多 可任意选择数据压缩格式。非强制压缩发 Ajax 的解决方法： Ajax（Asynchronous JavaScript and XML， 异 步 JavaScript 与 XML技术）是一种有效利用 JavaScript 和 DOM（Document Object Model，文档对象模型）的操作，以达到局部 Web 页面替换加载的异步通信手段。和以前的同步通信相比，由于它只更新一部分页面，响应中传输的数据量会因此而减少，这一优点显而易见\nAjax 的核心技术是名为 XMLHttpRequest 的 API，通过 JavaScript 脚本语言的调用就能和服务器进行 HTTP 通信。借由这种手段，就能从已加载完毕的 Web 页面上发起请求，只更新局部页面。\nComet 的解决方法： 一旦服务器端有内容更新了，Comet 不会让请求等待，而是直接给客户端返回响应。这是一种通过延迟应答，模拟实现服务器端向客户端推送（Server Push）的功能。\n通常，服务器端接收到请求，在处理完毕后就会立即返回响应，但为了实现推送功能，Comet 会先将响应置于挂起状态，当服务器端有内容更新时，再返回该响应。因此，服务器端一旦有更新，就可以立即反馈给客户端。\n内容上虽然可以做到实时更新，但为了保留响应，一次连接的持续时间也变长了。期间，为了维持连接会消耗更多的资源\nSPDY的设计与功能 SPDY 没有完全改写 HTTP 协议，而是在 TCP/IP 的应用层与运输层之间通过新加会话层的形式运作。同时，考虑到安全性问题，SPDY 规定通信中使用 SSL SPDY 以会话层的形式加入，控制对数据的流动，但还是采用 HTTP建立通信连接。因此，可照常使用 HTTP 的 GET 和 POST 等方 法、Cookie 以及 HTTP 报文等\n使用 SPDY 后，HTTP 协议额外获得以下功能。\n多路复用流：通过单一的 TCP 连接，可以无限制处理多个 HTTP 请求。所有请求的处理都在一条 TCP 连接上完成，因此 TCP 的处理效率得到提高\n赋予请求优先级:这样主要是为了在发送多个请求时，解决因带宽低而导致响应变慢的问题。\n压缩 HTTP 首部\n推送功能\n服务器提示功能: 服务器可以主动提示客户端请求所需的资源。由于在客户端发现资源之前就可以获知资源的存在，因此在资源已缓存等情况下，可以避免发送不必要的请求。\n使用浏览器进行全双工通信的WebSocket WebSocket 的设计与功能 WebSocket，即 Web 浏览器与 Web 服务器之间全双工通信标准\nWebSocket协议 一旦确立 WebSocket 通信连接，不论服务器还是客户端，任意一方都可直接向对方发送报文。\n主要特点。\n推送功能 减少通信量 为了实现 WebSocket 通信，在 HTTP 连接建立之后，需要完成一次“握手”（Handshaking）的步骤\n期盼已久的HTTP/2.0 Web服务器管理文件的WebDAV WebDAV（Web-based Distributed Authoring and Versioning，基于万维网的分布式创作和版本控制）是一个可对 Web 服务器上的内容直接进行文件复制、编辑等操作的分布式文件系统。\n扩展HTTP/1.1D的WebDAV 针对服务器上的资源，WebDAV 新增加了一些概念\n集合（Collection）：是一种统一管理多个资源的概念。以集合为单位可进行各种操作。也可实现类似集合的集合这样的叠加 资源（Resource）：把文件或集合称为资源。 属性（Property）：定义资源的属性。定义以“名称 = 值”的格式执行。 锁（Lock）：把文件设置成无法编辑状态。多人同时编辑时，可防止在同一时间进行内容写入。 WebDAV内新增的方法及状态码 WebDAV 为实现远程文件管理，向 HTTP/1.1 中追加了以下这些方法。\nPROPFIND ：获取属性\nPROPPATCH ：修改属性\nMKCOL ：创建集合\nCOPY ：复制资源及属性\nMOVE ：移动资源\nLOCK ：资源加锁\nUNLOCK ：资源解锁\n102 Processing ：可正常处理请求，但目前是处理中状态\n207 Multi-Status ：存在多种状态\n422 Unprocessible Entity ：格式正确，内容有误\n423 Locked ：资源已被加锁\n424 Failed Dependency ：处理与某请求关联的请求失败，因此不再维持依赖关系\n507 Insufficient Storage ：保存空间不足\n为何 HTTP 协议受众如此广泛 其中与企业或组织的防火墙设定有着莫大的关系。防火墙的基本功能就是禁止非指定的协议和端口号的数据包通过。因此如果使用新协议或端口号则必须修改防火墙设置。\n构建Web内容的技术 HTML Web 页面几乎全由 HTML 构建 HTML（HyperText Markup Language，超文本标记语言）是为了发送 Web 上的超文本（Hypertext）而开发的标记语言。超文本是一种文档系统，可将文档中任意位置的信息与其他信息（文本或图片等）建立关联，即超链接文本。标记语言是指通过在文档的某部分穿插特别的字符串标签，用来修饰文档的语言。我们把出现在 HTML文档内的这种特殊字符串叫做 HTML标签（Tag）\n设计应用CSS CSS（Cascading Style Sheets，层叠样式表）可以指定如何展现 HTML内的各种元素，属于样式表标准之一。\n动态HTML 让 Web 页面动起来的动态 HTML 所谓动态 HTML（Dynamic HTML），是指使用客户端脚本语言将静态的 HTML内容变成动态的技术的总称。鼠标单击点开的新闻、Google Maps 等可滚动的地图就用到了动态 HTML。\n动态 HTML技术是通过调用客户端脚本语言 JavaScript，实现对HTML的 Web 页面的动态改造。利用 DOM（Document ObjectModel，文档对象模型）可指定欲发生动态变化的 HTML元素。\n更易控制HTML的DOM DOM 是用以操作 HTML文档和 XML文档的 API（ApplicationProgramming Interface，应用编程接口）。使用 DOM 可以将 HTML内的元素当作对象操作，如取出元素内的字符串、改变那个 CSS 的属性等，使页面的设计发生改变。\nWeb应用 通过Web提供功能的Web应用 Web 应用是指通过 Web 功能提供的应用程序。比如购物网站、网上银行、SNS、BBS、搜索引擎和 e-learning 等。互联网（Internet）或企业内网（Intranet）上遍布各式各样的 Web 应用。\n类似这种由程序创建的内容称为动态内容，而事先准备好的内容称为静态内容。Web 应用则作用于动态内容之上。\n与服务器及程序协作的CGI CGI（Common Gateway Interface，通用网关接口）是指 Web 服务器在接收到客户端发送过来的请求后转发给程序的一组机制。在 CGI 的作用下，程序会对请求内容做出相应的动作，比如创建 HTML等动态内容。\n使用 CGI 的程序叫做 CGI 程序，通常是用 Perl、PHP、Ruby 和 C 等编程语言编写而成。\n因Java而普及的Servlet Servlet是一种能在服务器上创建动态内容的程序。Servlet 是用 Java语言实现的一个接口，属于面向企业级 Java（JavaEE，JavaEnterprise Edition）的一部分。\n之前提及的 CGI，由于每次接到请求，程序都要跟着启动一次。因此一旦访问量过大，Web 服务器要承担相当大的负载。而 Servlet 运行在与 Web 服务器相同的进程中，因此受到的负载较小 2。Servlet 的运行环境叫做 Web 容器或 Servlet 容器。\n数据发布的格式及语言 可扩展标记语言 XML（eXtensible Markup Language，可扩展标记语言）是一种可按应用目标进行扩展的通用标记语言。旨在通过使用 XML，使互联网数据共享变得更容易。\n从 XML文档中读取数据比起 HTML更为简单。由于 XML的结构基本上都是用标签分割而成的树形结构，因此通过语法分析器（Parser）的解析功能解析 XML结构并取出数据元素，可更容易地对数据进行读取。\n发布更新信息的RSS/Atom RSS（简易信息聚合，也叫聚合内容）和 Atom 都是发布新闻或博客日志等更新信息文档的格式的总称。两者都用到了 XML。\nJavaScript衍生的轻量级易用API JSON（JavaScript Object Notation）是一种以JavaScript（ECMAScript）的对象表示法为基础的轻量级数据标记语言。能够处理的数据类型有 false/null/true/ 对象 / 数组 / 数字 / 字符 串，这 7 种类型。\nWeb的攻击技术 针对 Web 的攻击技术 应用 HTTP 协议的服务器和客户端，以及运行在服务器上的 Web 应用等资源才是攻击目标。\nHTTP 不具备必要的安全功能 在客户端即可篡改请求 针对 Web 应用的攻击模式 以服务器为目标的主动攻击 以服务器为目标的被动攻击 因输出值转义不完全引发的安全漏洞 跨站脚本攻击 跨站脚本攻击（Cross-Site Scripting，XSS）是指通过存在安全漏洞的Web 网站注册用户的浏览器内运行非法的 HTML标签或 JavaScript 进行的一种攻击。\nSQL 注入攻击 SQL是用来操作关系型数据库管理系统（Relational DataBaseManagement System，RDBMS）的数据库语言，可进行操作数据或定义数据等。\nOS 命令注入攻击 OS 命令注入攻击（OS Command Injection）是指通过 Web 应用，执行非法的操作系统命令达到攻击的目的。只要在能调用 Shell 函数的地方就有存在被攻击的风险。\nHTTP 首部注入攻击 邮件首部注入攻击 目录遍历攻击 目录遍历（Directory Traversal）攻击是指对本无意公开的文件目录，通过非法截断其目录路径后，达成访问目的的一种攻击。这种攻击有时也称为路径遍历（Path Traversal）攻击。\n远程文件包含漏洞 因设置或设计上的缺陷引发的安全漏洞 强制浏览 不正确的错误消息处理 开放重定向 因会话管理疏忽引发的安全漏洞 会话劫持 会话劫持（Session Hijack）是指攻击者通过某种手段拿到了用户的会话 ID，并非法使用此会话 ID 伪装成用户，达到攻击的目的。\n会话固定攻击 跨站点请求伪造 其他安全漏洞 密码破解 点击劫持 点击劫持（Clickjacking）是指利用透明的按钮或链接做成陷阱，覆盖在 Web 页面之上。然后诱使用户在不知情的情况下，点击那个链接访问内容的一种攻击手段。这种行为又称为界面伪装\nDoS 攻击 DoS 攻击（Denial of Service attack）是一种让运行中的服务呈停止状态的攻击。有时也叫做服务停止攻击或拒绝服务攻击。DoS 攻击的对象不仅限于 Web 网站，还包括网络设备及服务器等\n其中，集中利用访问请求的 DoS 攻击，单纯来讲就是发送大量的合法请求。服务器很难分辨何为正常请求，何为攻击请求，因此很难防止 DoS 攻击。\n后门程序 后门程序（Backdoor）是指开发设置的隐藏入口，可不按正常步骤使用受限功能。利用后门程序就能够使用原本受限制的功能。\n开发阶段作为 Debug 调用的后门程序 开发者为了自身利益植入的后门程序 攻击者通过某种方法设置的后门程序 ","date":"2024-05-08T13:28:01+08:00","permalink":"https://example.com/p/%E5%9B%BE%E8%A7%A3http/","title":"图解HTTP"},{"content":"\r# 什么是Gitee\rGitee 是一个版本控制和协作的代码托管平台（可以托管代码，还可以托管文档与图片资料）。 它可以让你和其他人一起在远程或本地项目上进行协作。\r本教程将为您介绍 Gitee 的一些基础知识，如：仓库、分支、分支修改确认以及 Pull Request （代码评审）。您将创建自己的 Hello Gitee 仓库，并学习 Gitee 的 Pull Request 工作流\n创建Hello Gitee仓库 第一步 创建 Hello Gitee 仓库 仓库可用于存放自己的一个创意或项目的资料库。\n仓库内可包含：文件夹和文件，图片，视频，电子文档和代码等你能想到的任何元素。\n创建新仓库时建议设置一个 README.md 的文档来介绍您的项目。\n（新手默认不选）另外可选开源许可证文件，让你明确声明自己资源他人可以如何使用。\n提示：社区版Gitee提供5G的总仓库空间，单文件最大支持50M\n详细内容可查看：https://gitee.com/help/articles/4167\n步骤 创建名字为 hello-gitee 的仓库 仓库介绍可自定义，或直接填写：入门学习 是否开源选择：公开 勾选使用 Readme 文件初始化这个仓库 点击创建按钮\n（其他选项使用默认设置即可）\n创建一个新分支 分支是给您提供后悔药的一种方式，以自己写的一段文字记录为例，复制出一个一模一样的文档，在新复制出的文档上修改内容，然后再合并到原始文档时，对比两个文档可以看到哪些地方做了修改，如果觉得副本中一些有价值的原始记录内容被删除了，可以继续修改副本，以免一份文档修改后，原本写的有价值的文字也被删除，就得不偿失了。\n步骤 点击下图中的“1个分支”进入分支管理 点击右上角“新建分支”按钮，命名，提交 点击新建好的分支，即可进入新分支界面\n修改分支并提交更改 提交Pull Request Pull Requests 是 Gitee 上分支操作的一项很重要的功能。我们可以通过审核并通过 Pull Requests 从而进行不同分支的合并\n步骤 点击顶部 Pull Requests 进入配置页面，点击右上角“新建 Pull Requests” 创建请求 命名本次操作：PR，在文本框中填入备注信息：My first PR 点击创建\n合并提交的Pull Request 作为仓库的拥有者，在合并提交的 Pull Requests 前一定要确认新分支的修改是否符合自己的期望，如果不符合可以在线反馈自己的意见。\n步骤 进入 Pull Requests 页面，点击可合并的请求 可在文件选项中查看提交的分支与 master 分支有什么差别，可通过颜色对比查看 （白色：无修改；红色：删减内容；蓝色：新增内容） 确认无误可点击合并按钮，如有疑问可在评论中回复 点击合并中的按钮“合并分支”并再次点击“接收 Pull Requests” 合并完成后显示为“已合并”，但Gitee依旧提供了强力后悔药“回退”功能（手快不用愁）\n","date":"2024-05-06T13:28:01+08:00","permalink":"https://example.com/p/gitte/","title":"gitte"},{"content":"一个最小的应用 1 2 3 4 5 6 from flask import Flask app = Flask(__name__) @app.route(\u0026#39;/\u0026#39;) def hello_world(): return \u0026#39;Hello,World!\u0026#39; 那么，这些代码是什么意思呢？\n首先我们导入了 Flask 类。 该类的实例将会成为我们的 WSGI 应用。\n接着我们创建一个该类的实例。第一个参数是应用模块或者包的名称。如果你使用 一个单一模块（就像本例），那么应当使用 name ，因为名称会根据这个 模块是按应用方式使用还是作为一个模块导入而发生变化（可能是 ‘main’ ， 也可能是实际导入的名称）。这个参数是必需的，这样 Flask 才能知道在哪里可以 找到模板和静态文件等东西。更多内容详见 Flask 文档。\n然后我们使用 route() 装饰器来告诉 Flask 触发函数的 URL 。\n函数名称被用于生成相关联的 URL 。函数最后返回需要在用户浏览器中显示的信息。\n把它保存为 hello.py 或其他类似名称。请不要使用 flask.py 作为应用名称，这会与 Flask 本身发生冲突。\n外部可见的服务器 运行服务器后，会发现只有你自己的电脑可以使用服务，而网络中的其他电脑却 不行。缺省设置就是这样的，因为在调试模式下该应用的用户可以执行你电脑中 的任意 Python 代码。\n如果你关闭了调试器或信任你网络中的用户，那么可以让服务器被公开访问。 只要在命令行上简单的加上 \u0026ndash;host=0.0.0.0 即可:\n$ flask run \u0026ndash;host=0.0.0.0 这行代码告诉你的操作系统监听所有公开的 IP 。\n调试模式 虽然 flask 命令可以方便地启动一个本地开发服务器，但是每次应用代码 修改之后都需要手动重启服务器。这样不是很方便， Flask 可以做得更好。如果你打开 调试模式，那么服务器会在修改应用代码之后自动重启，并且当应用出错时还会提供一个 有用的调试器。\n如果需要打开所有开发功能（包括调试模式），那么要在运行服务器之前导出 FLASK_ENV 环境变量并把其设置为 development:\n$ export FLASK_ENV=development\r$ flask run\r（在 Windows 下需要使用 set 来代替 export 。）\n这样可以实现以下功能：\n激活调试器。\n激活自动重载。\n打开 Flask 应用的调试模式。\n还可以通过导出 FLASK_DEBUG=1 来单独控制调试模式的开关。\nAttention 虽然交互调试器不能在分布环境下工作（这使得它基本不可能用于生产环境），但是 它允许执行任意代码，这样会成为一个重大安全隐患。因此， 绝对不能在生产环境 中使用调试器 。\n路由 现代 web 应用都使用有意义的 URL ，这样有助于用户记忆，网页会更得到用户的青睐， 提高回头率。\n使用 route() 装饰器来把函数绑定到 URL:\n1 2 3 4 5 6 7 @app.route(\u0026#39;/\u0026#39;) def index(): return \u0026#39;Index Page\u0026#39; @app.route(\u0026#39;/hello\u0026#39;) def hello(): return \u0026#39;Hello, World\u0026#39; 变量规则 通过把 URL 的一部分标记为 \u0026lt;variable_name\u0026gt; 就可以在 URL 中添加变量。标记的 部分会作为关键字参数传递给函数。通过使用 converter:variable_name ，可以 选择性的加上一个转换器，为变量指定规则。请看下面的例子:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 @app.route(\u0026#39;/user/\u0026lt;username\u0026gt;\u0026#39;) def show_user_profile(username): # show the user profile for that user return \u0026#39;User %s\u0026#39; % escape(username) @app.route(\u0026#39;/post/\u0026lt;int:post_id\u0026gt;\u0026#39;) def show_post(post_id): # show the post with the given id, the id is an integer return \u0026#39;Post %d\u0026#39; % post_id @app.route(\u0026#39;/path/\u0026lt;path:subpath\u0026gt;\u0026#39;) def show_subpath(subpath): # show the subpath after /path/ return \u0026#39;Subpath %s\u0026#39; % escape(subpath) 唯一的 URL / 重定向行为 projects 的 URL 是中规中矩的，尾部有一个斜杠，看起来就如同一个文件夹。 访问一个没有斜杠结尾的 URL 时 Flask 会自动进行重定向，帮你在尾部加上一个斜杠。\nabout 的 URL 没有尾部斜杠，因此其行为表现与一个文件类似。如果访问这个 URL 时添加了尾部斜杠就会得到一个 404 错误。这样可以保持 URL 唯一，并帮助 搜索引擎避免重复索引同一页面。\nURL 构建 url_for() 函数用于构建指定函数的 URL。它把函数名称作为第一个 参数。它可以接受任意个关键字参数，每个关键字参数对应 URL 中的变量。未知变量 将添加到 URL 中作为查询参数\nHTTP 方法 Web 应用使用不同的 HTTP 方法处理 URL 。当你使用 Flask 时，应当熟悉 HTTP 方法。 缺省情况下，一个路由只回应 GET 请求。 可以使用 route() 装饰器的 methods 参数来处理不同的 HTTP 方法\n静态文件 动态的 web 应用也需要静态文件，一般是 CSS 和 JavaScript 文件。理想情况下你的 服务器已经配置好了为你的提供静态文件的服务。但是在开发过程中， Flask 也能做好 这项工作。只要在你的包或模块旁边创建一个名为 static 的文件夹就行了。 静态文件位于应用的 /static 中。\nurl_for('static', filename='style.css')\r这个静态文件在文件系统中的位置应该是 static/style.css 。\n渲染模板 在 Python 内部生成 HTML 不好玩，且相当笨拙。因为你必须自己负责 HTML 转义， 以确保应用的安全。因此， Flask 自动为你配置 Jinja2 模板引擎。\n使用 render_template() 方法可以渲染模板，你只要提供模板名称和需要 作为参数传递给模板的变量就行了。下面是一个简单的模板渲染例子:\n1 2 3 4 5 6 from flask import render_template @app.route(\u0026#39;/hello/\u0026#39;) @app.route(\u0026#39;/hello/\u0026lt;name\u0026gt;\u0026#39;) def hello(name=None): return render_template(\u0026#39;hello.html\u0026#39;, name=name) Flask 会在 templates 文件夹内寻找模板。因此，如果你的应用是一个模块， 那么模板文件夹应该在模块旁边；如果是一个包，那么就应该在包里面：\n操作请求数据 对于 web 应用来说对客户端向服务器发送的数据作出响应很重要。在 Flask 中由全局 对象 request 来提供请求信息。如果你有一些 Python 基础，那么 可能 会奇怪：既然这个对象是全局的，怎么还能保持线程安全？答案是本地环境：\n请求对象 请求对象在 API 一节中有详细说明这里不细谈（参见 Request ）。 这里简略地谈一下最常见的操作。首先，你必须从 flask 模块导入请求对象: from flask import request\n通过使用 method 属性可以操作当前请求方法，通过使用 form 属性处理表单数据（在 POST 或者 PUT 请求 中传输的数据）。以下是使用上述两个属性的例子\n1 2 3 4 5 6 7 8 9 10 11 12 @app.route(\u0026#39;/login\u0026#39;, methods=[\u0026#39;POST\u0026#39;, \u0026#39;GET\u0026#39;]) def login(): error = None if request.method == \u0026#39;POST\u0026#39;: if valid_login(request.form[\u0026#39;username\u0026#39;], request.form[\u0026#39;password\u0026#39;]): return log_the_user_in(request.form[\u0026#39;username\u0026#39;]) else: error = \u0026#39;Invalid username/password\u0026#39; # the code below is executed if the request method # was GET or the credentials were invalid return render_template(\u0026#39;login.html\u0026#39;, error=error) 当 form 属性中不存在这个键时会发生什么？会引发一个 KeyError 。 如果你不像捕捉一个标准错误一样捕捉 KeyError ，那么会显示一个 HTTP 400 Bad Request 错误页面。因此，多数情况下你不必处理这个问题。\n要操作 URL （如 ?key=value ）中提交的参数可以使用 args 属性:\nsearchword = request.args.get('key', '')\r文件上传 用 Flask 处理文件上传很容易，只要确保不要忘记在你的 HTML 表单中设置 enctype=\u0026ldquo;multipart/form-data\u0026rdquo; 属性就可以了。否则浏览器将不会传送你的文件。\n已上传的文件被储存在内存或文件系统的临时位置。你可以通过请求对象 files 属性来访问上传的文件。每个上传的文件都储存在这个 字典型属性中。这个属性基本和标准 Python file 对象一样，另外多出一个 用于把上传文件保存到服务器的文件系统中的 save() 方法\n1 2 3 4 5 6 7 8 from flask import request @app.route(\u0026#39;/upload\u0026#39;, methods=[\u0026#39;GET\u0026#39;, \u0026#39;POST\u0026#39;]) def upload_file(): if request.method == \u0026#39;POST\u0026#39;: f = request.files[\u0026#39;the_file\u0026#39;] f.save(\u0026#39;/var/www/uploads/uploaded_file.txt\u0026#39;) ... Cookles 要访问 cookies ，可以使用 cookies 属性。可以使用响应 对象 的 set_cookie 方法来设置 cookies 。请求对象的 cookies 属性是一个包含了客户端传输的所有 cookies 的字典。在 Flask 中，如果使用会话 ，那么就不要直接使用 cookies ，因为 会话 比较安全一些。\n读取 cookies:\n1 2 3 4 5 6 7 from flask import request @app.route(\u0026#39;/\u0026#39;) def index(): username = request.cookies.get(\u0026#39;username\u0026#39;) # use cookies.get(key) instead of cookies[key] to not get a # KeyError if the cookie is missing. 储存 cookies:\n1 2 3 4 5 6 7 from flask import make_response @app.route(\u0026#39;/\u0026#39;) def index(): resp = make_response(render_template(...)) resp.set_cookie(\u0026#39;username\u0026#39;, \u0026#39;the username\u0026#39;) return resp 注意， cookies 设置在响应对象上。通常只是从视图函数返回字符串， Flask 会把它们 转换为响应对象。如果你想显式地转换，那么可以使用 make_response() 函数，然后再修改它。\n重定向和错误 使用 redirect() 函数可以重定向。使用 abort() 可以 更早退出请求，并返回错误代码:\n1 2 3 4 5 6 7 8 9 10 from flask import abort, redirect, url_for @app.route(\u0026#39;/\u0026#39;) def index(): return redirect(url_for(\u0026#39;login\u0026#39;)) @app.route(\u0026#39;/login\u0026#39;) def login(): abort(401) this_is_never_executed() 缺省情况下每种出错代码都会对应显示一个黑白的出错页面。使用 errorhandler() 装饰器可以定制出错页面:\n1 2 3 4 5 from flask import render_template @app.errorhandler(404) def page_not_found(error): return render_template(\u0026#39;page_not_found.html\u0026#39;), 404 注意 render_template() 后面的 404 ，这表示页面对就的出错 代码是 404 ，即页面不存在。缺省情况下 200 表示：一切正常。\n关于响应 视图函数的返回值会自动转换为一个响应对象。如果返回值是一个字符串，那么会被 转换为一个包含作为响应体的字符串、一个 200 OK 出错代码 和一个 text/html 类型的响应对象。如果返回值是一个字典，那么会调用 jsonify() 来产生一个响应。以下是转换的规则：\n如果视图返回的是一个响应对象，那么就直接返回它。\n如果返回的是一个字符串，那么根据这个字符串和缺省参数生成一个用于返回的 响应对象。\n如果返回的是一个字典，那么调用 jsonify 创建一个响应对象。\n如果返回的是一个元组，那么元组中的项目可以提供额外的信息。元组中必须至少 包含一个项目，且项目应当由 (response, status) 、 (response, headers) 或者 (response, status, headers) 组成。 status 的值会重载状态代码， headers 是一个由额外头部值组成的列表 或字典。\n如果以上都不是，那么 Flask 会假定返回值是一个有效的 WSGI 应用并把它转换为 一个响应对象。\n如果想要在视图内部掌控响应对象的结果，那么可以使用 make_response() 函数。\n可以使用 make_response() 包裹返回表达式，获得响应对象，并对该对象 进行修改，然后再返回:\nJSON格式的API JSON 格式的响应是常见的，用 Flask 写这样的 API 是很容易上手的。如果从视图 返回一个 dict ，那么它会被转换为一个 JSON 响应。\n1 2 3 4 5 6 7 8 @app.route(\u0026#34;/me\u0026#34;) def me_api(): user = get_current_user() return { \u0026#34;username\u0026#34;: user.username, \u0026#34;theme\u0026#34;: user.theme, \u0026#34;image\u0026#34;: url_for(\u0026#34;user_image\u0026#34;, filename=user.image), } 如果 dict 还不能满足需求，还需要创建其他类型的 JSON 格式响应，可以使用 jsonify() 函数。该函数会序列化任何支持的 JSON 数据类型。 也可以研究研究 Flask 社区扩展，以支持更复杂的应用。\n1 2 3 4 @app.route(\u0026#34;/users\u0026#34;) def users_api(): users = get_all_users() return jsonify([user.to_json() for user in users]) 会话 除了请求对象之外还有一种称为 session 的对象，允许你在不同请求 之间储存信息。这个对象相当于用密钥签名加密的 cookie ，即用户可以查看你的 cookie ，但是如果没有密钥就无法修改它\n使用会话之前你必须设置一个密钥。举例说明:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 from flask import Flask, session, redirect, url_for, escape, request app = Flask(__name__) # Set the secret key to some random bytes. Keep this really secret! app.secret_key = b\u0026#39;_5#y2L\u0026#34;F4Q8z\\n\\xec]/\u0026#39; @app.route(\u0026#39;/\u0026#39;) def index(): if \u0026#39;username\u0026#39; in session: return \u0026#39;Logged in as %s\u0026#39; % escape(session[\u0026#39;username\u0026#39;]) return \u0026#39;You are not logged in\u0026#39; @app.route(\u0026#39;/login\u0026#39;, methods=[\u0026#39;GET\u0026#39;, \u0026#39;POST\u0026#39;]) def login(): if request.method == \u0026#39;POST\u0026#39;: session[\u0026#39;username\u0026#39;] = request.form[\u0026#39;username\u0026#39;] return redirect(url_for(\u0026#39;index\u0026#39;)) return \u0026#39;\u0026#39;\u0026#39; \u0026lt;form method=\u0026#34;post\u0026#34;\u0026gt; \u0026lt;p\u0026gt;\u0026lt;input type=text name=username\u0026gt; \u0026lt;p\u0026gt;\u0026lt;input type=submit value=Login\u0026gt; \u0026lt;/form\u0026gt; \u0026#39;\u0026#39;\u0026#39; @app.route(\u0026#39;/logout\u0026#39;) def logout(): # remove the username from the session if it\u0026#39;s there session.pop(\u0026#39;username\u0026#39;, None) return redirect(url_for(\u0026#39;index\u0026#39;)) 如何生成一个好的密钥 生成随机数的关键在于一个好的随机种子，因此一个好的密钥应当有足够的随机性。 操作系统可以有多种方式基于密码随机生成器来生成随机数据。使用下面的命令 可以快捷的为 Flask.secret_key （ 或者 SECRET_KEY ）生成值:\n$ python -c \u0026lsquo;import os; print(os.urandom(16))\u0026rsquo; b\u0026rsquo;_5#y2L\u0026quot;F4Q8z\\n\\xec]/\u0026rsquo;\n消息闪现 一个好的应用和用户接口都有良好的反馈，否则到后来用户就会讨厌这个应用。 Flask 通过闪现系统来提供了一个易用的反馈方式。闪现系统的基本工作原理是在请求结束时 记录一个消息，提供且只提供给下一个请求使用。通常通过一个布局模板来展现闪现的 消息。\nflash() 用于闪现一个消息。在模板中，使用 get_flashed_messages() 来操作消息。完整的例子参见 消息闪现 。\n日志 有时候可能会遇到数据出错需要纠正的情况。例如因为用户篡改了数据或客户端代码出错 而导致一个客户端代码向服务器发送了明显错误的 HTTP 请求。多数时候在类似情况下 返回 400 Bad Request 就没事了，但也有不会返回的时候，而代码还得继续运行 下去。\n这时候就需要使用日志来记录这些不正常的东西了。自从 Flask 0.3 后就已经为你配置好 了一个日志工具。\n以下是一些日志调用示例: app.logger.debug(\u0026lsquo;A value for debugging\u0026rsquo;) app.logger.warning(\u0026lsquo;A warning occurred (%d apples)\u0026rsquo;, 42) app.logger.error(\u0026lsquo;An error occurred\u0026rsquo;)\n集成 WSGI 中间件 如果想要在应用中添加一个 WSGI 中间件，那么可以包装内部的 WSGI 应用。假设为了 解决 lighttpd 的错误，你要使用一个来自 Werkzeug 包的中间件，那么可以这样做:\nfrom werkzeug.contrib.fixers import LighttpdCGIRootFix\rapp.wsgi_app = LighttpdCGIRootFix(app.wsgi_app)\r使用 Flask 扩展 扩展是帮助完成公共任务的包。例如 Flask-SQLAlchemy 为在 Flask 中轻松使用 SQLAlchemy 提供支持。\n部署到网络服务器 ","date":"2024-04-30T13:28:01+08:00","permalink":"https://example.com/p/flask/","title":"Flask"},{"content":"\r# CSV\r什么是CSV CSV（Comma-Separated Values，逗号分隔的值）是一种简单、实用的文件格式，用于存储和表示包括文本、数值等各种类型的数据。CSV 文件通常以 .csv 作为文件扩展名。这种文件格式的一个显著特点是：文件内的数据以逗号 , 分隔，呈现一个表格形式。CSV 文件已广泛应用于存储、传输和编辑数据。\n为什么使用CSV CSV 文件因其简单易用、兼容性高、易于数据交换等特点受到了广泛的欢迎。以下是有关 CSV 使用的一些优点：\n简单易懂：CSV 文件基于纯文本格式，因此可以使用任何文本编辑器(如Notepad)轻松打开和编辑。 数据兼容性：CSV 文件中的数据可以很容易地跨平台进行传输和处理，任何具有 CSV 处理功能的软件(如Microsoft Excel、Google Sheets、甚至编程语言库)都能处理该类型的文件。 资源占用低：CSV 文件以纯文本形式存储数据，其体积相对较小，便于节省存储空间 文件的结构 每行表示一条记录：CSV 文件中的每一行代表一条记录，相当于数据库中的一行数据。 逗号分隔：每行数据中，使用逗号 , 进行数据分隔，代表不同的数据。 引号包围：当数据单元格中的内容含有逗号时，为避免混淆，需要引号 (单引号 \u0026rsquo; 或双引号 \u0026ldquo;）将这个数据包围起来，防止误认为是两个不同数据。 ","date":"2024-04-27T13:28:01+08:00","permalink":"https://example.com/p/csv/","title":"CSV"},{"content":"\rPython项目管理 事情起因是这样，我开开心心把代码提交到码云后，结果师兄跟我说去看他发的项目管理，按他的流程改好代码格式，属实把我小吓了一下，感觉自己作为一个学校里学生，有幸在学校间接触到这些观念，是很幸运的。\n环境管理 使用Anaconda和Pipenv共同管理Python项目环境\nAnaconda包含了许多常用的Python库、工具和环境，使得安装和管理这些工具变得更加容易。它包括了Python解释器本身以及许多流行的科学计算库，比如NumPy、SciPy、Pandas、Matplotlib等。此外，Anaconda还提供了一个名为Conda的包管理器，用于安装、更新和管理这些库，以及创建和管理不同的Python环境。\n对于Python新手来说，Anaconda是一个很好的选择，因为它提供了一个完整的Python环境，无需手动安装和配置每个库。你只需安装Anaconda，就可以开始编写Python代码并使用各种科学计算工具了。\nPipenv 是 Python 项目的包管理器和虚拟环境管理器。它旨在提供一种简单的方式来创建和管理项目的依赖项，并确保这些依赖项在不同环境中的一致性\n下面是 Pipenv 的一些主要功能：\n虚拟环境管理：Pipenv 可以为每个项目创建独立的虚拟环境，这意味着每个项目都有自己的 Python 解释器和依赖项，而不会干扰系统中的其他项目。\n依赖项管理：Pipenv 使用 Pipfile 和 Pipfile.lock 文件来管理项目的依赖项。Pipfile 是项目的声明性文件，用于指定所需的包和版本，而 Pipfile.lock 文件则记录了确切的依赖项版本，以确保在不同环境中的一致性。\n自动环境激活：当你进入项目目录时，Pipenv 会自动激活该项目的虚拟环境，这意味着你可以立即开始使用项目的依赖项而无需手动激活虚拟环境。\n命令行工具：Pipenv 提供了一组简单的命令行工具，用于安装、更新和删除依赖项，以及管理虚拟环境。\n胎教版：\n当你开始一个新的 Python 项目时，你需要安装各种各样的库来帮助你完成任务。Pipenv 就像一个保姆，帮助你照顾这些库，确保它们安装正确且不会互相冲突。\r想象一下你在一个大杂货店里购物，每个库就像是你要买的商品。Pipenv 就是你的购物清单和购物车。你列出你要买的东西（依赖库），然后 Pipenv 帮你把它们一个一个加到你的购物车里（项目环境）。\r同时，Pipenv 还能确保你购物车里的东西都是正确的版本，就像是每个商品上都有一个标签标明它的准确型号和规格一样。这样，当你需要重建你的购物车时，你就可以确保每个东西都是一样的。\r最后，Pipenv 还能帮你管理购物车的整个过程。它会告诉你什么时候需要买新的东西（更新库），或者什么时候需要把一些东西扔掉（删除库）。\r总的来说，Pipenv 就像是你的 Python 项目的好帮手，确保你所需的库都安装正确，没有任何混乱\r师兄画的图 编码标准 对于编码标准，推荐跟着社区的PEP8走\nPEP8 是 Python Enhancement Proposal 8 的缩写，它是 Python 社区中的一项规范，用于指导 Python 代码的编写风格和格式。PEP8 旨在提高代码的可读性，并促进代码在不同项目和团队之间的一致性。\n以下是 PEP8 涵盖的一些主要方面：\n缩进：使用 4 个空格作为缩进的标准，而不是制表符。\r行长度：每行代码应尽量控制在 79 个字符以内，但可以允许最多 99 个字符。\r命名约定：变量名应该采用小写字母，单词之间使用下划线分隔（例如，my_variable），而类名应采用驼峰命名法（例如，MyClass）。\r空格：在逗号、冒号、分号等符号后应添加一个空格，但在圆括号内部不需要添加空格。\r导入：每个导入应该独立一行，避免使用通配符导入（例如，from module import *）。\r注释：使用适当的注释来解释代码的作用和目的，注释应该清晰、简洁且易于理解。\r代码布局：遵循统一的代码布局规范，包括适当的缩进、空行和代码段分隔。\rpep8链接： https://pep8.org/\n规范化 black：代码格式化 Black 是一个自动化代码格式化工具，它可以帮助你自动将 Python 代码按照一致的规范进行格式化，从而使得代码风格更加统一，减少手动调整格式的工作量。\npylint：代码检查 Pylint 是 Python 中一种静态代码分析工具，它的主要作用是检查 Python 代码中的语法错误、代码风格问题以及潜在的逻辑错误，并提供相应的建议和警告，以帮助开发者编写更加规范、可靠和易于维护的代码。\n语法错误检查：Pylint 可以检测出代码中的语法错误，并指出出错的位置和可能的原因。\r代码风格检查：Pylint 可以根据 PEP8 等 Python 代码规范，检查代码中的格式问题，如缩进、空格、命名规范等，并提供相应的建议。\r代码质量检查：Pylint 可以评估代码的质量，并提供一些度量指标，如代码的复杂度、重复代码等，帮助开发者识别出代码中的潜在问题。\r错误和警告提示：Pylint 可以检测出代码中的潜在逻辑错误、不安全的操作、未使用的变量等，并给出相应的警告或错误提示，帮助开发者尽早发现并修复问题。\risort：导包规划化 isort 的作用就是帮助开发者自动将导入语句按照指定的规范进行排序和格式化，以保持代码的清晰易读，并且符合约定俗成的编码规范。\n导入语句排序：isort 可以自动将导入语句按照特定的顺序排序，例如将标准库模块、第三方库模块和本地模块分组，并按字母顺序排列。\r分组和对齐：isort 可以将导入语句分组，并且对齐每个组内的导入语句，使得代码结构更加清晰易读。\r移除重复导入：isort 可以检测并移除重复的导入语句，避免在代码中出现不必要的重复导入。\r自定义配置：isort 提供了丰富的配置选项，可以根据项目的需要进行定制，包括导入顺序、分组规则、对齐方式等。\rflake8(mccabe)：代码复杂度检查 flake8是一个Python工具，用于检查你的代码是否符合PEP 8样式指南 Flake8 是 Python 中常用的代码质量检查工具之一，而 mccabe 则是 Flake8 的一个插件，用于检测代码中的复杂度。\n使用方法： 终端激活虚拟环境 activate 环境名 进入所需项目 cd 路径 进行pipenv初始化 进行对应的工具处理\n文件作用 setup.cfg setup.cfg文件是一个配置文件，用于存储与项目相关的各种设置\nPipfile.lock 是由Pipenv生成的一个文件，用于锁定项目的依赖包的精确版本。这个文件确保了你的项目在不同的环境和时间点上都能使用相同版本的依赖，从而避免了因为依赖版本不一致导致的问题\nPipfile 是由Pipenv工具使用的一个文件，用于管理Python项目的依赖。它类似于requirements.txt文件，但提供了更强大的功能，例如锁定依赖的精确版本，区分开发和生产环境的依赖，以及自动管理虚拟环境。\n[[source]]：这个部分定义了包的源。在这个例子中，包的源被设置为PyPI。\n[packages]：这个部分列出了项目的主要依赖。在这个例子中，项目依赖了requests，lxml，black，isort，pylint，flake8这几个包。\n[dev-packages]：这个部分列出了项目的开发依赖。这些依赖只在开发环境中需要，例如测试工具，代码格式化工具等。在这个例子中，项目的开发依赖包括black，pylint，isort，pytest。\n[requires]这个部分定义了项目需要的Python版本。在这个例子中，项目需要Python 3.10。\n[scripts]：在Pipfile中用于定义一些自定义的命令。这些命令可以是任何你想要的shell命令，它们可以帮助你自动化一些常见的任务，例如运行测试，构建项目，或者启动开发服务器\n当你运行pipenv install命令时，Pipenv会查看Pipfile，然后安装列出的所有依赖。如果你运行pipenv install \u0026ndash;dev，Pipenv还会安装[dev-packages]中列出的依赖。\n*[packages]和[dev-packages]两个部分都是用来列出项目的依赖的，但它们的用途有所不同。\n[packages]部分列出的是项目运行时需要的依赖。这些依赖是项目的核心部分，无论是在开发环境还是在生产环境，都需要这些依赖。例如，如果你的项目是一个Web应用，那么你可能需要像Flask或Django这样的Web框架，这些依赖应该被列在[packages]部分。\n[dev-packages]部分列出的是只在开发环境中需要的依赖。这些依赖在生产环境中通常是不需要的。例如，你可能需要像pytest这样的测试框架来运行你的测试，或者需要像flake8或black这样的工具来检查你的代码格式，这些依赖应该被列在[dev-packages]部分。\n当你运行pipenv install命令时，Pipenv会安装[packages]部分列出的所有依赖。如果你运行pipenv install \u0026ndash;dev命令，Pipenv会额外安装[dev-packages]部分列出的依赖。这样，你可以在开发环境中安装所有的依赖，而在生产环境中只安装必要的依赖，从而减少生产环境的复杂性和安全风险。*\nDockerfile 这个文件是一个Dockerfile，它是一种文本文档，用于自动化Docker镜像的构建过程。Dockerfile中的每一行都代表在镜像中执行的一条命令。\nDocker作用：\nDocker是一个开源的应用容器引擎，它允许开发者将应用及其依赖打包到一个可移植的容器中，然后发布到任何流行的Linux或Windows机器上，也可以实现虚拟化。容器是完全使用沙箱机制，相互之间不会有任何接口。\n以下是Docker的一些主要用途：\n提供一致的环境：Docker可以确保在不同的环境中（开发，测试，生产等）运行相同的软件和配置。\n简化配置：Docker使得配置应用环境变得更加简单。你只需要编写一个Dockerfile或者docker-compose.yml文件，就可以定义你的整个环境。\n隔离应用：每个Docker容器都在其自己的环境中运行，这意味着你可以在同一台机器上运行多个不同版本的同一软件，而不会有冲突。\n微服务架构：Docker非常适合微服务架构，因为它允许你为每个服务创建一个单独的容器。\n持续集成/持续部署（CI/CD）：Docker可以与CI/CD工具（如Jenkins，GitLab CI等）集成，使得自动化构建，测试和部署变得更加简单。\n快速部署：Docker容器比传统的虚拟机启动得更快，这使得它非常适合需要快速扩展的应用。\n总的来说，Docker是一种使得软件开发，测试和部署变得更加简单和一致的工具。\n.pylintrc 这个文件是一个.pylintrc文件，它是Pylint工具的配置文件。Pylint是一个Python代码静态分析工具，它可以检查代码中的错误，查找不符合PEP 8编码规范的代码，以及查找代码中的其他问题\n总的来说，这个.pylintrc文件定义了Pylint如何检查你的Python代码。你可以根据你的需要修改这个文件，以定制Pylint的行为\n.gitinore 这个文件是一个.gitignore文件，它告诉Git哪些文件或目录不应该被版本控制系统跟踪 在这个.gitignore文件中，每一行都代表一个忽略规则，Git将忽略与这些规则匹配的文件和目录\npycache/和*.py[cod]规则告诉Git忽略Python编译的字节码文件和优化的字节码文件。\n*.so规则告诉Git忽略C扩展的共享对象文件。\nbuild/，dist/，*.egg-info/等规则告诉Git忽略Python打包和分发过程中生成的文件和目录。\n.manifest和.spec规则告诉Git忽略PyInstaller生成的文件。\nhtmlcov/，.tox/，.coverage等规则告诉Git忽略单元测试和覆盖率报告生成的文件和目录。\n总的来说，.gitignore文件帮助你管理你的Git仓库，确保只有需要跟踪的文件被包含在版本控制中。\n.gitattributes 这个文件是一个.gitattributes文件，它用于设置Git仓库的特定行为\n在这个.gitattributes文件中，Dockerfile linguist-language=Python这行告诉GitHub的Linguist工具将Dockerfile文件识别为Python语言。Linguist是GitHub用来在仓库中进行语言检测的工具，它决定了在GitHub仓库概览中显示的语言比例，以及在\u0026quot;搜索\u0026quot;功能中如何对代码进行语法高亮\n通常，Linguist会自动识别文件的语言，但有时你可能希望覆盖这个行为。在这个例子中，即使Dockerfile实际上是Docker的语言，但这行设置让Linguist将其识别为Python语言\n总的来说，.gitattributes文件允许你自定义Git在你的仓库中的行为\n.env 这个文件是一个.env文件，它用于设置环境变量。在这个文件中，PYTHONPATH=${PYTHONPATH}:${PWD}这行代码将当前工作目录（${PWD}）添加到PYTHONPATH环境变量中。\nPYTHONPATH是一个环境变量，它告诉Python解释器在哪里查找模块。当你尝试导入一个模块时，Python解释器会在PYTHONPATH中列出的目录中查找这个模块。\n在这个例子中，${PWD}是一个环境变量，它表示当前工作目录。所以，这行代码的效果是将当前工作目录添加到PYTHONPATH中。这意味着你可以直接导入当前工作目录中的Python模块，而不需要将它们移动到Python的安装目录或其他位置。\n总的来说，.env文件允许你设置环境变量，这可以帮助你配置你的应用的运行环境。\n.dockerignore 这个文件是一个.dockerignore文件，它的作用类似于.gitignore文件，但是它是用于Docker的。.dockerignore文件告诉Docker在构建镜像时应该忽略哪些文件和目录。\n在这个.dockerignore文件中：\n.idea/：这个规则告诉Docker忽略.idea/目录。这个目录通常包含由JetBrains IDE（如PyCharm）生成的项目设置和配置文件。\n.git/：这个规则告诉Docker忽略.git/目录。这个目录包含Git的版本控制信息。\n.vscode/：这个规则告诉Docker忽略.vscode/目录。这个目录通常包含由Visual Studio Code生成的项目设置和配置文件。\n总的来说，.dockerignore文件帮助你管理你的Docker镜像，确保只有需要的文件被包含在镜像中，从而减小镜像的大小并提高构建速度。\ntest文件夹 在Python项目中，test文件夹通常用于存放所有的测试代码。这些测试代码用于验证你的应用的功能和行为，确保它们按照预期工作。\n以下是test文件夹的一些主要用途：\n单元测试：这些是针对单个函数或类的测试，用于验证它们的行为。例如，你可能有一个测试用例来验证你的函数是否正确地处理边界条件。\n集成测试：这些是针对多个组件或模块的测试，用于验证它们是否能够正确地一起工作。\n回归测试：当你修改或添加新的代码时，你可以运行你的测试套件来确保你没有引入新的错误。\n性能测试：这些测试用于检查你的代码的性能，例如，检查一个函数是否在给定的时间内完成。\n在Python中，你可以使用unittest库来编写测试用例，并使用pytest或nose等工具来运行你的测试。\n总的来说，test文件夹是你的项目的重要组成部分，它帮助你保持你的代码的质量和可靠性。\nsrc文件夹 在Python项目中，src文件夹通常用于存放项目的源代码。这个目录通常包含一个__init__.py文件，这个文件告诉Python这个目录应该被视为一个包\n以下是src文件夹的一些主要用途：\n代码组织：src文件夹提供了一个地方，你可以在其中组织你的Python模块和包。你可以在src文件夹中创建子目录来进一步组织你的代码。\n导入模块：当你的Python文件在src文件夹中时，你可以使用相对导入来导入其他模块。例如，如果你有一个在src/my_package目录中的my_module.py文件，你可以在src/my_package目录中的其他Python文件中使用from . import my_module来导入它。\n测试：将你的源代码放在src文件夹中可以使得测试更加容易。你可以在一个单独的tests文件夹中编写测试，然后在测试中导入src文件夹中的模块。\n总的来说，src文件夹是你的项目的重要组成部分，它帮助你组织和管理你的源代码。\ndocs文件夹 在Python项目中，docs文件夹通常用于存放项目的文档。这些文档可能包括：\n项目说明：对项目的概述，包括它的目的，主要功能，以及如何使用它。\nAPI文档：对项目中的类，函数，方法和模块的详细描述。\n开发者指南：对如何为项目贡献代码的指南，包括代码风格指南，测试策略，以及代码提交流程。\n用户手册：对如何使用项目的详细指南，包括安装指南，教程，以及常见问题解答。\n这些文档可以使用Markdown，reStructuredText，或其他标记语言编写，然后使用工具如Sphinx生成HTML或PDF格式的文档。\n总的来说，docs文件夹是你的项目的重要组成部分，它帮助用户和开发者理解和使用你的项目。\n.vscode文件夹 .vscode文件夹是Visual Studio Code（VS Code）编辑器为特定项目创建的一个配置文件夹。这个文件夹通常包含两个文件：settings.json和launch.json。\nsettings.json：这个文件包含了VS Code的工作区设置。这些设置会覆盖用户级别和全局的VS Code设置。例如，你可以在这个文件中设置特定的Python解释器，或者设置代码格式化工具的参数。\nlaunch.json：这个文件定义了调试配置。例如，你可以在这个文件中设置启动和调试Python程序的参数。\n.vscode文件夹通常会被添加到.gitignore文件中，因为这个文件夹通常包含特定用户或特定环境的设置，这些设置可能不适用于其他用户或环境。\n.pytestcache文件夹 .pytest_cache文件夹是由pytest测试框架自动创建的。pytest在运行测试时使用这个文件夹来存储一些中间数据和测试结果，以便在后续的测试运行中重用。\n以下是.pytest_cache文件夹中可能包含的一些文件和目录：\nv/cache/lastfailed：这个文件包含了上次测试失败的测试用例的信息。pytest可以使用这个信息来首先运行失败的测试用例。\nv/cache/nodeids：这个文件包含了所有测试用例的节点ID。pytest使用节点ID来唯一标识每个测试用例。\nd/：这个目录包含了一些由pytest插件生成的数据。\n通常，你不需要手动修改.pytest_cache文件夹中的内容。这个文件夹通常会被添加到.gitignore文件中，因为它包含的是特定于本地环境的数据，不应该被添加到版本控制系统中\nCACHEDIR.TAG 这个文件名为CACHEDIR.TAG，它是一个缓存目录标签文件。这种文件通常用于标记一个目录被用作缓存，也就是说，该目录中的文件是可以被安全删除的，因为它们可以被重新生成。\n在这个特定的情况下，CACHEDIR.TAG文件是由pytest测试框架创建的，用于标记.pytest_cache目录为缓存目录。\n文件中的Signature: 8a477f597d28d172789f06886806bc55是一个固定的签名，用于标识这个文件是一个缓存目录标签。\n总的来说，CACHEDIR.TAG文件的存在告诉其他工具和用户，.pytest_cache目录中的文件是临时的，可以被安全删除。\n_pycache_文件 __pycache__是Python自动创建的一个目录，用于存储编译后的Python代码，也就是字节码文件。当你运行一个Python程序时，Python解释器会首先将源代码（.py文件）编译成字节码（.pyc文件），然后执行这个字节码。\n字节码文件的主要目的是加速程序的启动。当Python解释器再次运行同一个程序时，如果源代码没有改变，解释器可以直接加载字节码文件，而不需要再次编译源代码。\n__pycache__目录中的文件通常有如下的命名格式：module.version.pyc，其中module是源代码文件的名称，version是Python解释器的版本。\n通常，你不需要手动管理__pycache__目录或其中的文件。Python解释器会自动创建和更新这些文件。这个目录通常会被添加到.gitignore文件中，因为字节码文件是特定于Python解释器的，不应该被添加到版本控制系统中。\n","date":"2024-04-22T13:28:01+08:00","permalink":"https://example.com/p/python%E9%A1%B9%E7%9B%AE%E7%AE%A1%E7%90%86/","title":"python项目管理"},{"content":"\rDjango 基于蛇书的django项目\n建立项目 制定规范 建立虚拟环境 虚拟环境是系统的⼀个位置，你可在其中安装包，并将这些包与其他 Python 包隔离开来。将项⽬的 库与其他项⽬分离是有益的，为了部署到服务器，这也是必须的\npython -m venv ll_env\r激活虚拟环境 Linux:source ll_env/bin/activate\rWindow:ll_env\\Scripts\\activate\r安装Django pip install --upgrade pip\rpip install django\r安装特定版本： pip install django==4.1.*\r在Django中创建项目 django_admin startproject ll_project . ls (在 Windows 系统上为 dir)\rls ll_project\rDjango 新建了⼀个名为 ll_project 的⽬录。它还创建了⽂件 manage.py，这是⼀个简单的程序，接受命令并将其交给 Django 的相关部分。我们将使⽤这些命令来管理使⽤数据库和运⾏服务器等任务\n⽬录 ll_project 包含 4 个⽂件，其中最重要的是 settings.py、urls.py和 wsgi.py。⽂件 settings.py 指定 Django 如何与系统交互以及如何管理项⽬。在开发项⽬的过程中，我们将修改其中的⼀些设置，并添加⼀些设置。⽂件 urls.py 告诉 Django，应创建哪些⽹⻚来响应浏览器请求。⽂件 wsgi.py 帮助 Django 提供它创建的⽂件，名称是 web server gateway interface（Web 服务器⽹关接⼝）的⾸字⺟缩写\n创建数据库 python manage.py migrate\rdir\rSQLite 是⼀种使⽤单个⽂件的数据库，是编写简单应⽤程序的理想选择，因为它让你不⽤太关注数据库的管理问题\n查看项目 python manage.py runserver\rDjango 启动⼀个服务器（development server），让你能够查看系统中的项⽬，了解它的⼯作情况。如果你在浏览器中输⼊ URL 以请求⽹⻚，那么该Django 服务器将进⾏响应：⽣成合适的⽹⻚，并将其发送给浏览器。\n创建应用程序 Django 项⽬（project）由⼀系列应⽤程序组成，它们协同⼯作让项⽬成为⼀个整体\nsource ll_env/bin/activate\rpython manage.py startapp learning_logs\rls\rls learning_logs/\r定义模型 模型告诉 Django 如何处理应⽤程序中存储的数据。模型就是⼀个类，就像前⾯讨论的每个类⼀样，包含属性和⽅法。\n激活模型 python manage.py makemigrations learning_logs\rpython manage.py migrate\r每当需要修改“学习笔记”管理的数据时，都采取如下三个步骤：修改models.py，对 learning_logs 调⽤ makemigrations，以及让 Django迁移项⽬\nDjango管理网站 Django 提供的管理⽹站（admin site）让你能够轻松地处理模型。Django 管理⽹站仅供⽹站的管理员使⽤，普通⽤户不能使⽤。本节将建⽴管理⽹站，并通过它使⽤模型 Topic 来添加⼀些主题\n创建超级用户 Django 允许创建具备所有权限的⽤户，即超级⽤户（superuser）。权限决定了⽤户可执⾏的操作。最严格的权限设置只允许⽤户阅读⽹站的公开信息。注册⽤户通常可阅读⾃⼰的私有数据，还可查看⼀些只有会员才能查看的信息。为了有效地管理项⽬，⽹站所有者通常需要访问⽹站存储的所有信息。优秀的管理员会⼩⼼地对待⽤户的敏感信息，因为⽤户对其访问的应⽤程序有极⼤的信任。\npython manage.py createsuperuser\r向管理网站注册模型 Django ⾃动在管理⽹站中添加了⼀些模型，如 User 和 Group，如果要添加我们创建的模型，则必须⼿动注册\n添加主题 定义模型Entry 迁移模型Entry Django shell 输⼊⼀些数据后，就可以通过交互式终端会话以编程的⽅式查看这些数据了。这种交互式环境称为 Django shell，是测试项⽬和排除故障的理想之地\npython manage.py shell\rfrom learning_logs.models import Topic\rTopic.objects.all()\rtopics = Topic.objects.all()\rfor topic in topics:\rprint(topic.id, topic)\rt = Topic.objects.get(id=1)\rt.text\rt.date_added\rt.entry_set.all()\r每次修改模型后，都需要重启 shell，以便看到修改的效果。要退出 shell 会话，可按 Ctr + D。如果你使⽤的是 Windows 系统，应先按 Ctr + Z，再按回⻋键\n创建网页：学习笔记主页 使⽤ Django 创建⽹⻚的过程分为三个阶段：定义 URL，编写视图，以及编写模板。按什么顺序完成这三个阶段⽆关紧要，但在本项⽬中，总是先定义 URL 模式。URL 模式描述了 URL 的构成，让 Django 知道如何将浏览器请求与⽹站 URL 匹配，以确定返回哪个⽹⻚\n每个 URL 都被映射到特定的视图。视图函数获取并处理⽹⻚所需的数据。视图函数通常使⽤模板来渲染⽹⻚，⽽模板定义⽹⻚的总体结构。为了明⽩其中的⼯作原理，我们来创建学习笔记的主⻚。这包括定义该主⻚的URL，编写其视图函数，以及创建⼀个简单的模板\n映射URL ⽤户通过在浏览器中输⼊ URL 和单击链接来请求⽹⻚，因此需要确定项⽬需要哪些 URL。主⻚的 URL 最重要，它是⽤户⽤来访问项⽬的基础URL。当前，基础 URL（http://localhost:8000/）返回默认的 Django ⽹站，让我们知道正确地建⽴了项⽬\n编写视图 视图函数接受请求中的信息，准备好⽣成⽹⻚所需的数据，再将这些数据发送给浏览器。这通常是使⽤定义⽹⻚外观的模板实现的。 learning_logs 中的⽂件 views.py 是执⾏命令 python manage.pystartapp 时⾃动⽣成的\n编写模板 模板定义⽹⻚的外观，⽽每当⽹⻚被请求时，Django 都将填⼊相关的数据。模板让你能够访问视图提供的任何数据。我们的主⻚视图没有提供任何数据，因此相应的模板⾮常简单\n模板继承 在创建⽹站时，⼀些通⽤元素会出现在所有⽹⻚中。在这种情况下，可编写⼀个包含通⽤元素的⽗模板，并让每个⽹⻚都继承⽗模板，⽽不是在每个⽹⻚中重复定义这些通⽤元素。这种⽅法不仅能够让你专注于开发每个⽹⻚的独特⽅⾯，还使得修改项⽬的整体外观容易得多。\n父模板 子模版 显示所有主题的页面 URL模式 ⾸先，定义显⽰所有主题的⻚⾯的 URL。通常，使⽤⼀个简单的 URL⽚段来指出⽹⻚显⽰的信息；这⾥将使⽤单词 topics，因此 URL http://localhost:8000/topics/ 将返回显⽰所有主题的⻚⾯。\n视图 模板 显示特定主题的页面 URL模式 视图 模板 将显示所有主题的页面中的每个主题都设置为链接 用户账户 Web 应⽤程序的核⼼是让任何地⽅的任何⽤户都能够注册账户并使⽤它。本章将创建⼀些表单，让⽤户能够添加主题和条⽬并编辑既有的条⽬。你将了解到，Django 能够防范对基于表单的⽹⻚发起的常⻅攻 击，让你⽆须花⼤量时间考虑应⽤程序的安全问题。\n让用户能够输入数据 添加新主题 用于添加主题的表单 URL模式new_topic 视图函数new_topic GET请求和POST请求 模板new_topic 链接到页面new_topic 添加新条目 用于添加新条目的表单 URL模式new_entry 视图函数new_entry() 模板new_entry 链接到页面new_entry 编辑条目 URL模式edit_entry 视图函数edit_entry() 模板edit_entry 链接到页面edit_entry 创建用户账户 本节将建⽴⽤户注册和⾝份验证系统，让⽤户能够注册账户、登录和注销。为此，我们将新建⼀个应⽤程序，其中包含与处理⽤户账户相关的所有功能。这个应⽤程序将尽可能使⽤ Django ⾃带的⽤户⾝份验证系统来完成⼯作。\n应用程序accounts python manage.py startapp accounts\rls\rls accounts\r将应用程序accounts添加到settings.py中 包含应用程序accounts的URL 登录页面 模板login.html 设置LOGIN_REDIRECT_URL 链接到登录页面 使用登录页面 注销 在base.html中添加注销表单 设置LOGOUT_REDIRECT_URL 注册页面 注册页面的URL模式 视图函数register() 注册模板 链接到注册页面 让用户拥有自己的数据 使用@login_required限制访问 Django 提供了装饰器 @login_required，有助于轻松地限制对某些⻚⾯的访问。第 11 章介绍过，装饰器（decorator）是放在函数定义前⾯的指令，⽤于改变函数的⾏为\n全面限制对项目“学习笔记”的访问 将数据关联到用户 现在，需要将数据关联到提交它们的⽤户。只需将最⾼层的数据关联到⽤户，低层的数据也将⾃动关联到该⽤户。在项⽬“学习笔记”中，应⽤程序的最⾼层数据是主题，所有条⽬都与特定的主题相关联。只要每个主题都归属于特定的⽤户，就能确定数据库中每个条⽬的所有者。\n修改模型Topic 确认当前有哪些用户 python manage.py shell\rfrom django.contrib.auth.models import User\rUser.objects.all()\rfor user in User.objects.all():\rprint(user.username, user.id)\r迁移数据库 知道⽤户 ID 后，就可迁移数据库了。在这样做时，Python 将询问是要暂时将模型 Topic 关联到特定的⽤户，还是在⽂件 models.py 中指定默认⽤户。\npython manage.py makemigrations learning_logs\r1\r1\rpython manage.py migrate\r只允许用户访问自己的主题 保护用户的主题 保护页面edit_entry 将新主题关联到当前用户 设置应用程序的样式并部署 设置项目\u0026quot;学习笔记\u0026quot;的样式 应用程序django-bootstrap5 pip install django-bootstrap5\r使用Bootstarp设置项目\u0026quot;学习笔记\u0026quot;的样式 修改base.html 定义HTML头部 定义导航栏 添加用户账户链接 在导航栏中添加注销表单 定义页面的主要部分 使用jumbotron设置主页的样式 设置登录页面的样式 设置页面topics的样式 设置页面topic中条目的样式 部署\u0026quot;学习笔记\u0026quot; 注册Platform.sh账户 安装Platform.sh CLI 要将项⽬部署到 Platform.sh 服务器上并对其进⾏管理，需要使⽤Platform.sh CLI（command lineinterface，命令⾏界⾯）中的⼯具。要安装该CLI 的最新版本\n安装platformshconfig 还需安装⼀个名为 platformshconfig 的包。这个包可帮助我们监测项⽬运⾏在本地系统还是 Platform.sh 服务器上。为了安装这个包，可在活动的虚拟环境中执⾏如下命令\npip install platformshconfig\r创建文件requirements.txt 远程服务器需要知道项⽬“学习笔记”依赖于哪些包，因此我们将使⽤ pip ⽣成⼀个⽂件，在其中列出这些包。\npip freeze \u0026gt; requirements.txt\r其他部署要求 添加配置文件 显示隐藏的文件 配置文件 .platform.app.yaml 配置文件routes.yaml 路由（route）指的是请求在被服务器处理的过程中经过的路径。Platform.sh 需要知道应将收到的请求发送到哪⾥\n配置文件services.yaml 为部署到Platform.sh而修改settings.py 使用Git跟踪项目文件 安装Git 配置Git 忽略文件 提交项目 在Platform.sh上创建项目 platform login\rY\rplatform create\rll_project\rus-3.platform.sh\r推送到Platform.sh platform push\r查看线上项目 platform url\r改进Platform.sh部署 在Platform.sh上创建超级用户 platform environment:ssh\rls\rpython manage.py createsuperuser\rll_admin_live\r确保线上项目的安全 提交并推送修改 git commit -am \u0026quot;Set DEBUG False on live\rgit status\rplatform push\r创建定制错误页面 创建定制模板 将修改推送到Platform.sh git add .\rgit commit -am \u0026quot;Added custom 404 and 500 error pages.\u0026quot;\rplatform push\r继续开发 将项⽬“学习笔记”推送到远程服务器上之后，你可能想进⼀步开发它或开发要部署的其他项⽬。更新项⽬的过程⼏乎完全相同，如下所⽰。⾸先，对本地项⽬做必要的修改。如果在修改过程中创建了新⽂件，使⽤命令 git add .（千万别忘记末尾的句点）将它们加⼊ Git 仓库。如果有修改要求迁移数据库，也需要执⾏这个命令，因为每次迁移都将⽣成新的迁移⽂件。然后，使⽤命令 git commit -am \u0026ldquo;commit message\u0026rdquo; 将修改提交到仓库，再使⽤命令 platform push 将修改推送到 Platform.sh 上。然后，访问线上的项⽬，确认期望看到的修改已⽣效。\n将项目从Platform.sh删除 要删除项⽬，可使⽤ Platform.sh CLI：\nplatform project:delete\r命令 platform create 还在本地 Git 仓库中添加了⼀个引⽤，它指向位于 Platform.sh 服务器上的远程仓库。可在命令⾏中删除这个远程仓库\ngit remote\rgit remote remove platform\r还可以删除项⽬的资源。⾸先登录 Platform.sh ⽹站，并访问你的仪表盘（dashboard）。这个⻚⾯列出了你的所有活动项⽬。单击项⽬框中的三个点，再单击 Edit Plan。这将打开项⽬的计价⻚⾯（pricing page），单击该⻚⾯底部的 Delete Project 按钮，将出现⼀个确认⻚⾯，然后就可以按其中的说明完成项⽬的删除了。即便你选择使⽤ CLI 删除项⽬，也应该熟悉托管提供商提供的仪表盘。\n","date":"2024-04-21T13:28:01+08:00","permalink":"https://example.com/p/django/","title":"Django"},{"content":" ## 连接 MySQL 数据库 `mysql -u root -p` Mysql基础 EXISTS 语法 在 MySQL 中，EXISTS 操作符用来判断一个子查询是否返回数据行。如果一个子查询返回了至少一个数据行，则 EXISTS 的计算结果为 TRUE，否则计算结果为 FALSE。\nLIKE % 匹配零或多个任意字符。 _ 匹配单个任意字符。 如果需要匹配通配符，则需要使用 \\ 转义字符，如 % 和 _。 使用通配符匹配文本时，不区分字母大小写。\n按自定义顺序排序 使用 CASE 实现自定义排序 使用 FIELD() 函数实现自定义排序 在 MySQL 中的升序排序中， NULL 值出现在非 NULL 值之前 当我们使用 ORDER BY 子句降序 DESC 排序时， NULL 值排在非 NULL 值的后面\nMySQL LIMIT 在 MySQL 中，我们使用 LIMIT 子句来限定 SELECT 语句返回的行的数量\n当 DISTINCT 遇到 NULL 值时，只保留一个 NULL 值。因为 DISTINCT 认为所有的 NULL 值都是相同的，这与字段的类型无关。\nMySQL 连接类型 MySQL 支持以下类型的连接：\n内部联接 (INNER JOIN) 左连接 (LEFT JOIN) 右连接 (RIGHT JOIN) 交叉连接 (CROSS JOIN) MySQL 目前不支持全连接 FULL OUTER JOIN 。\n交叉连接返回两个集合的笛卡尔积。也就是两个表中的所有的行的所有可能的组合。这相当于内连接没有连接条件或者连接条件永远为真\n内连接基于连接条件组合两个表中的数据。内连接相当于加了过滤条件的交叉连接。\n内连接将第一个表的每一行与第二个表的每一行进行比较，如果满足给定的连接条件，则将两个表的行组合在一起作为结果集中的一行\n由于两个表都使用相同的字段进行等值匹配，因此您可以使用 USING 以下查询\n左连接是左外连接的简称，左连接需要连接条件。\n两个表左连接时，第一个表称为左表，第二表称为右表。例如 A LEFT JOIN B，A 是左表，B 是右表。\n左连接以左表的数据行为基础，根据连接匹配右表的每一行，如果匹配成功则将左表和右表的行组合成新的数据行返回；如果匹配不成功则将左表的行和 NULL 值组合成新的数据行返回\n右连接是右外连接的简称，右连接需要连接条件。\n右连接与左连接处理逻辑相反，右连接以右表的数据行为基础，根据条件匹配左表中的数据。如果匹配不到左表中的数据，则左表中的列为 NULL 值\n右连接其实是左右表交换位置的左连接，即 A RIGHT JOIN B 就是 B LEFT JOIN A，因此右连接很少使用。\n右连接可以转换为下面的左连接\nGROUP BY HAVING 子句用来过滤 GROUP BY 分组的数据，需要使用逻辑表达式作为条件，其中逻辑表达式中的字段或表达式只能使用分组使用的字段和聚合函数\nGROUP BY 子句用于将结果集根据指定的字段或者表达式进行分组。 GROUP BY 子句的分组字段或表达式至少一个，可以多个。 HAVING 子句是可选的，用来过滤分组数据。 GROUP BY 子句经常用于数据统计汇总，通常使用聚合函数。\nUNION 在 MySQL 中，UNION 操作符是一个集合操作符，它用于合并 2 个结果集中的所有的行。\nSQL 标准中定义了 3 个集合操作符： UNION, INTERSECT 和 MINUS。目前 MySQL 只支持 UNION\nUNION 运算删除了结果集中的重复项，返回一个唯一记录值的结果集。\nUNION 是 UNION DISTINCT 的简写\nUNION ALL 运算 UNION ALL 保留了两个结果集中的所有行\nUNION 排序 当需要对 UNION 运算的结果进行排序时，最需要在 SQL 语句的最后添加 ORDER BY 子句。\nUNION 列数 当对两个结果集进行 UNION 运算的时候，要保证每个结果集具有相同的列数。否则就会产生错误。\n参与 UNION 运算的结果集和字段的名称没有关系，只要列数一样就可以\nUNION 列名 参与 UNION 运算的结果集只要列数一样就可以。返回结果集的列名采用第一个结果集的列名\n别名 列别名 表别名 派生表别名 使用派生表必须指定别名。因为，FROM 子句中的所有表都必须有一个名字\n可以通过 AS 关键字指定别名，但是 AS 关键字是可选的。 当别名中包含空格时，必须使用 反引号 将别名引起来。 除了为字段指定别名，表达式也可以指定别名。 当 SQL 中涉及多个表时，使用表别名很重要。 派生表必须指定别名。\n子查询 派生表 当一个子查询位于 FORM 子句中时，这个子查询被称为派生表。\n子查询是一个嵌套在语句中的查询。 子查询经常做为比较运算的一个操作数被用在 WHERE 子句中。 位于 FORM 子句中的子查询被称为派生表。派生表必须具有别名。\ninsert修饰符 在 MySQL 中， INSERT 语句支持 4 个修饰符: LOW_PRIORITY: 如果你指定了 LOW_PRIORITY 修饰符，MySQL 服务器将延迟执行 INSERT 操作直到没有客户端对表进行读操作。\nLOW_PRIORITY 修饰符影响那些只支持表级锁的存储引擎，比如： MyISAM, MEMORY, 和 MERGE。\nHIGH_PRIORITY: 如果你指定了 HIGH_PRIORITY 修饰符，它会覆盖掉服务器启动时的 \u0026ndash;low-priority-updates 选项。\nHIGH_PRIORITY 修饰符影响那些只支持表级锁的存储引擎，比如： MyISAM, MEMORY, 和 MERGE。\nIGNORE: 如果你指定了 IGNORE 修饰符，MySQL 服务器会在执行 INSERT 操作期间忽略那些可忽略的错误。这些错误最终会作为 WARNING 返回。\nDELAYED: 这个修饰符已经在 MySQL 5.6 版本中弃用，将来会被删除。在 MySQL 8.0 中，这个修饰符可用但会被忽略。\nDELETE 多表删除 只要是 SELECT 语句中允许使用的 JOIN 类型，多表删除语句都可以使用。\n多表删除语句中不能使用 LIMIT 子句和 ORDER BY 子句。\nDELETE 修饰符 LOW_PRIORITY: 如果你指定了 LOW_PRIORITY 修饰符，MySQL 服务器将延迟执行 DELETE 操作直到没有客户端对表进行读操作。这个修饰符影响那些只支持表级锁的存储引擎，比如： MyISAM, MEMORY, 和 MERGE。\nQUICK: 如果你指定了 QUICK 修饰符，MyISAM 存储引擎不会在 DELETE 操作期间合并索引。这在某种程度上会加快 DELETE 操作。\nIGNORE: 如果你指定了 IGNORE 修饰符，MySQL 服务器会在执行 DELETE 操作期间忽略那些可忽略的错误。这些错误最终会作为 WARNING 返回。\nUPDATE 修饰符 LOW_PRIORITY: 如果你指定了 LOW_PRIORITY 修饰符，MySQL 服务器将延迟执行 UPDATE 操作直到没有客户端对表进行读操作。\nLOW_PRIORITY 修饰符影响那些只支持表级锁的存储引擎，比如： MyISAM, MEMORY, 和 MERGE。\nIGNORE: 如果你指定了 IGNORE 修饰符，MySQL 服务器会在执行 UPDATE 操作期间忽略那些可忽略的错误。这些错误最终会作为 WARNING 返回\nREPLACE 语句和 INSERT 语句很像，它们的不同之处在于，当插入过程中出现了重复的主键或者重复的唯一索引的时候，INSERT 语句会产生一个错误，而 REPLACE 语句则先删除旧的行，再插入新的行。\nREPLACE 语句还可以使用 SET 关键词，这只适用于操作单行\nMySQL数据库和表 数据库是存储数据的容器。一个数据库中可以包含多个表。要想创建表，必须首先创建数据库。\n在 MySQL 中，CREATE DATABASE 和 CREATE SCHEMA 语句用来创建数据库 CREATE DATABASE 和 CREATE SCHEMA 的是一样的 DROP DATABASE 语句将永久删除数据库和数据库中的所有表，请谨慎操作。 DROP DATABASE 和 DROP SCHEMA 是一样的。\n登陆时指定数据库 mysql -u root -p -D testdb\n查看当前数据库 使用 SELECT DATABASE() 使用 STATUS 使用 SHOW TABLES CREATE TABLEtestdb.user_hobby(hobby_idINT NOT NULL AUTO_INCREMENT,user_idINT NOT NULL,hobbyVARCHAR(45) NOT NULL,created_atDATETIME NOT NULL, INDEXfk_user_idx (user_id ASC) VISIBLE, PRIMARY KEY (hobby_id), CONSTRAINT fk_user FOREIGN KEY (user_id) REFERENCES testdb.user (user_id) ON DELETE CASCADE ON UPDATE RESTRICT); 这里创建的 user_hobby 表有 4 个字段：\nhobby_id 列的数据类型是 INT，它不能为 NULL，并且它是一个自增列。 user_id 列的数据类型是 INT。它不能为 NULL。它通过外键指向了 user 表的 user_id 列。 hobby 列的数据类型是 VARCHAR，它最多为 45 个字符。 它不能为 NULL。 created_at 列的数据类型是 DATETIME。它不能为 NULL。 user_hobby 表的约束有：\nPRIMARY KEY (hobby_id) 子句表明 hobby_id 列是主键。 INDEX fk_user_idx 设定了在 user_id 列上建立索引。 CONSTRAINT fk_user 设定了一个外键。这个外键将 user_id 列引用了 user 表的 user_id 列\nCREATE TABLE … LIKE 语句可以用来克隆另一个表的定义。它以另一个表的定义为基础创建一个新的空表，包含了原表中定义的列属性和索引\nCREATE TABLE … SELECT 你可以使用 CREATE TABLE \u0026hellip; SELECT 语句从另一个表创建一个新表。该语句会一句 SELECT 子句中的列创建新表，并将 SELECT 的结果集插入到新表中\nALTER TABLE 语法 其中 alter_action 是一个修改动作，包括：\nADD 关键字可用来添加列、索引、约束等，包括：\nADD [COLUMN]: 添加列 ADD INDEX: 添加索引 ADD PRIMARY KEY: 添加主键 ADD FOREIGN KEY: 添加外键 ADD UNIQUE INDEX: 添加唯一索引 ADD CHECK: 添加检查约束 DROP 关键字可用来删除列、索引、约束等，包括：\nDROP [COLUMN] col_name: 删除列 ADD INDEX index_name: 删除索引 DROP PRIMARY KEY: 删除主键 DROP FOREIGN KEY fk_symbol: 删除外键 DROP CHECK symbol: 删除检查约束 MODIFY 关键字用来修改列的定义。与 CHANGE 关键字不同，它不能重命名列。例如: MODIFY [COLUMN] col_name column_definition。\nCHANGE 关键字用来修改列的定义。与 MODIFY 关键字不同，它可以重命名列。例如: CHANGE [COLUMN] old_col_name new_col_name column_definition。\nRENAME 关键字可以重命名列、索引和表。包括：\nRENAME COLUMN old_col_name TO new_col_name: 重命名列。 RENAME INDEX old_index_name TO new_index_name: 重命名索引。 RENAME new_tbl_name: 重命名表。\nALTER TABLE 关键字后面跟要修改的表名。 ADD 关键字可用来添加列、索引、约束等。 DROP 关键字可用来删除列、索引、约束等。 RENAME 关键字可以重命名列、索引和表。 MODIFY 关键字用来修改列的定义。 CHANGE 关键字用来修改列的定义和列名。 RENAME TABLE \u0026hellip; TO \u0026hellip; 用来重命名表。\n您可以在一个 RENAME TABLE 语句中同时重命名多个表。 RENAME TABLE 语句不可以用来重命名临时表，而 ALTER TABLE 语句可以用来重命名临时表。\nMySQL 提供了 RENAME TABLE 和 ALTER TABLE 语句重命名表。\n请记住，在重命名一个表的时候，此表中不能有未完成的事务，并且此表不能是锁定状态。\nTRUNCATE TABLE 语法 如果想要清空一个表， TRUNCATE TABLE 语句比 DELETE 语句更加有效。\nTRUNCATE TABLE 语句相当于先将此表删除掉，再创建一个新表。TRUNCATE TABLE 语句需要对操作的表具有 DROP 权限。\nTRUNCATE 被归类为 DDL 语句，而 DELETE 被归类为 DML 语句。 TRUNCATE 操作无法被回滚，而 DELETE 可以被回滚。 TRUNCATE 操作删除和重建表，它的速度比 DELETE 快得多。 TRUNCATE 操作会重置表的自增值，而 DELETE 不会。 TRUNCATE 操作不会激活删除触发器，而 DELETE 会。 TRUNCATE 操作不返回代表删除行的数量的值，它通常返回 0 rows affected。DELETE 返回删除的行数。 如果一个表被其他表的外键引用，对此表的 TRUNCATE 操作会失败。\n主键可以包含一个列或者多个列。\n添加主键 ALTER TABLE user ADD PRIMARY KEY(id);\n删除主键 ALTER TABLE user DROP PRIMARY KEY;\n如何产生主键值 通常在业务系统中，我们不使用业务字段作为主键，虽然它们也是唯一的。我们一般使用单独的字段作为主键，这主要是出于以下两方面的原因：\n保密业务数据 方便这些业务字段的修改 为了生成唯一的主键值，我们通常采用以下方法：\n将主键字段设置为 AUTO_INCREMENT。\n声明为 AUTO_INCREMENT 的字段会自动生成连续的整数值。\n使用 UUID() 函数。\nUUID() 函数产生一个长度为 36 个字符的字符串，并且永不重复。\nUUID() 适合用在集群环境下。这样即使一个表被分区在多个服务器上，也不会产生相同的主键的记录\n使用 UUID_SHORT() 函数。\nUUID_SHORT() 函数返回一个 64 位无符号整数并全局唯一\n主键 vs 唯一索引 主键和唯一索引都要求值是唯一的，但它们之间存在一些不同：\n一个表中只能定义一个主键，但是能定义多个唯一索引。 主键中的值不能为 NULL，而索引中的值可以为 NULL\n什么是外键 外键相对于主键而言，用来引用其他表。外键通过子表的一个或多个列对应到父表的主键或唯一键值，将子表的行和父表行建立起关联关系\n这里定义了一个外键：\n位于 CONSTRAINT 关键字之后的 fk_city_country 是外键的名字。它是可选的。\n位于 FOREIGN KEY 关键字之后的是作为外键的列名。\n位于 REFERENCES 关键字之后的是被引用的表和列。\nON DELETE 和 ON UPDATE 指定了删除或更新被引用的表中的数据时要采取的约束策略。你可以使用以下 3 个策略中的一个：\nCASCADE：如果被引用的表中的一行被删除或更新，该表中匹配行的值会自动删除或更新。 SET NULL：如果被引用的表中的一行被删除或更新，该表中匹配行的值设置为 NULL。 RESTRICT: 如果被引用的表中的一行在该表中有匹配的行，试图删除或更新被引用的表中行时会引发 MySQL 错误。这是默认的策略。 通常，外键所属的表被称作子表，被外键引用的表被称作父表。\nDROP FOREIGN KEY 后面指定外键名，也就是约束名。 DROP CONSTRAINT 后面指定约束名。它可以通过名字删除任何约束，并不仅仅是外键\nCASCADE 策略 如果外键的 ON DELETE 和 ON UPDATE 使用了 CASCADE 策略：\n当父表的行被删除的时候，子表中匹配的行也会被删除。 当父表的行的键值更新的时候，子表中匹配的行的字段也会被更新\nRESTRICT 策略 MySQL 禁止删除父表中与子表匹配的行。 MySQL 禁止删除父表中与子表匹配的行的键的值\nSET NULL 策略 当父表的行被删除的时候，子表中匹配的行的列的值被设置为 NULL。 当父表的行的键值被更新的时候，子表中匹配的行的列的值被设置为 NULL\n自引用外键 有时，子表和父表可能是同一个表。这种表中的外键被称为自引用外键。\n通常，自引用外键定义在表示树形数据结构的表中。比如一个代表分类的表\n启用或禁用外键约束 要禁用外键约束 SET foreign_key_checks = 0;\n要启用外键约束 SET foreign_key_checks = 1;\n禁用外键约束在批量导入数据的时候很有用\n确定列是否存在 在向表中添加一个列之前，您可以需要首先确定此表中是否存在同名的列。\n要查看一个表中的所有列的信息，您可以使用 DESC 或者 SHOW COLUMNS 两个语句中的一个。这两个语句都可以显示一个表中的所有的列，但是 SHOW COLUMNS 语句更灵活和方便，因为它可以根据您的要求过滤结果集。\nMySQL 为非空的 VARCHAR 列使用空字符串作为默认值\n另外，删除列还可能带来一些隐藏的问题：\n如果要删除的列被外键引用，您需要同步删除外键后才能进行。这可能会破坏数据的完整性。 删除列后，您需要同步修改应用程序中依赖此列的代码。这包括独立的应用程序和触发器、视图、存储过程和函数中的引用。 对于一个大表来说，删除列是一个很耗时的过程。 重要：删除之前请一定要备份表和表中的数据\nMySQL AUTO_INCREMENT 自增列 在 MySQL 中，如果需要一个列的值为一个有序的整数序列，请使用自增列。\n自增列是 MySQL 中的一个特殊的列，该列的值可由 MySQL 服务器自动生成，并且是一个按升序增长的正整数序列。自增列能够被用来为表的新行产生唯一的标识\n当修改了表的 AUTO_INCREMENT 值之后， INFORMATION_SCHEMA.TABLES 表中的 AUTO_INCREMENT 列并不会立刻更新。你可以使用 SHOW CREATE TABLE 语句查看。\n一个表中只能有一个自增列。 自增列的数据类型只能使用整数和浮点数。 自增列的初始值是 1。你可以在创建表的时候设置自增列的初始值，也可以修改自增列的值。 删除一些行后，删除的自增列的值不能重用。 你可以使用 SHOW CREATE TABLE 语句查看自增列的值。\n什么是生成列 在 MySQL 中，生成列（GENERATED COLUMN）是一个特殊的列，它的值会根据列定义中的表达式自动计算得出。并且，你不能直接写入或更新生成列的值。\n生成列有 2 种类型：\n虚拟生成列：列值不会被存储下来。当读取该列时，MySQL 自动计算该列的值。 存储生成列：当插入或修改数据时，MySQL 自动计算该列的值并存储在磁盘上\nMySQL 生成列可以简化我们的工作，让你不用写这么复杂的 SELECT 语句。现在我们要通过以下语句添加一个生成列 ALTER TABLE order_item ADD COLUMN total_amount DECIMAL GENERATED ALWAYS AS (price * quantity) STORED;\n生成列有两种类型： VIRTUAL 和 STORED。他们之间有些不同：\n虚拟生成列不需要存储空间；存储生成列需要存储空间。 虚拟生成列的值在每次读操作的时候都会被重新计算；存储生成列的值在插入行或者修改行的时候被计算。 如果数据经常发生变动，请考虑使用虚拟生成列；如果数据在创建后不经常变动，请考虑使用存储生成列。\n像上面的例子中，一个订单被创建后一般不会再改动，这里很适合使用存储生成列\nMySQL UNIQUE KEY 唯一键 主键列不能包含 NULL 值，而唯一键列可以包含 NULL 值。\n在 MySQL 中，KEY 是 INDEX 的同义词。一个唯一键对应了一个唯一索引\n不像主键，唯一键允许其中的列接受 NULL 值。但是，NULL 值会破坏唯一键约束。也就是唯一键对 NULL 值无效。\nNOT NULL 也是一种特殊的约束\n假设在一个银行系统中有这样的逻辑：\n当用户 A 从自己的银行账户取出 500 元时，用户 A 的余额为 原余额 减去 500。当另一个用户 B 给用户转入 500 元时，用户 A 的余额为 原余额 加上 500。\n如果这两个操作同时发生，则可能导致用户 A 的余额是错误的。\nMySQL 的锁就是为了解决这种并发问题的。MySQL 支持三种类型的锁：表级锁、行级锁和页面所。\nMySQL 允许您在会话中显式地获取表锁，以防止其他会话在您需要独占访问表的期间修改表。\n锁的操作是在当前会话中进行的。一个会话只能为自己获取锁，并只能释放自己的锁。\nMySQL 提供了 LOCK TABLES 和 UNLOCK TABLES 语句用于显式地的获取表锁和释放表锁\n锁类型 表锁支持 READ 和 WRITE 两种类型的锁。 READ 锁用于共享读取表， WRITE 锁用于排斥的读写表，他们的特点如下：\nREAD 锁 持有表锁的会话只能读取表，但不能写入表。\n多个会话可以同时获取一个表的 READ 锁。\n其他会话无需显式获取 READ 锁即可读取该表，但是不能写入表。其他会话的写操作会一直等待知道读锁被释放。\nWRITE 锁 持有锁的会话可以读写表。\n只有持有锁的会话才能访问该表。在释放锁之前，没有其他会话可以访问它。\n持有 WRITE 锁时，其他会话对表的锁请求会阻塞。\n如果您没有显式地的释放表锁，当会话结束后，无论是 READ 锁还是 WRITE 锁，都会被 MySQL 释放掉。\n设置服务器字符集和排序规则 在配置文件中设置 MySQL 服务器的字符集和排序规则 这是推荐的设置方式，它是永久的。在修改配置文件后，请记得重启 MySQL 服务器。\n启动 MySQL 服务器时指定字符集和排序规则\n在命令行修改字符集和排序规则\n要查看数据库的字符集和排序规则 要查看当前数据库的字符集和排序规则，请使用如下语句： SELECT @@character_set_database, @@collation_database;\n要查看指定数据库的字符集和排序规则 SHOW CREATE DATABASE testdb;\nMySQL 提供了各种字符集以有效地存储各种字符。您可以为服务器、数据库、表、和列设置不同的字符级和排序规则。\n如果您需要在不同的字符集之间转换字符串，请使用 MySQL 提供的两个函数： CONVERT 和 CAST\n一个 ENUM 是一个字符串的列表，它定义了一个列中允许的值，列的值只能是创建列时定义的允许值列表中的的一个\nENUM (\u0026lsquo;v1\u0026rsquo;, \u0026lsquo;v2\u0026rsquo;, \u0026hellip;, \u0026lsquo;vn\u0026rsquo;)\n现在，我们已经创建好了 orders 表，其中 state 列为 ENUM 数据类型，并且它将只接受四个值: Unpaid, Paid, Shipped 和 Completed。同时，按照列定义时的顺序，Unpaid, Paid, Shipped 和 Completed 的索引分别为 1, 2, 3, 4\nMySQL 创建索引 索引是一种数据结构，例如 B-Tree，它提高了从表中检索数据行的速度，但需要额外的写入和存储来维护它。\n查询优化器可以使用索引来快速定位数据，而不必针对给定查询扫描表中的每一行。\n当您使用主键 或唯一键创建表时，MySQL 会自动创建一个名为 PRIMARY 的索引。 该索引称为聚集索引。\nPRIMARY 索引是特殊的，因为索引本身与数据一起存储在同一个表中。聚集索引强制执行表中行的顺序。\nPRIMARY 索引以外的其他索引称为二级索引或非聚集索引。\n如果您不指定索引类型，MySQL 将创建 B-Tree 索引。下面显示了基于表的存储引擎允许的索引类型\n让我们使用以下 CREATE INDEX 语句为该列 first_name 创建索引 CREATE INDEX first_name ON actor(first_name);\nMySQL 删除主键索引 DROP INDEX PRIMARY ON t;\nMySQL 唯一索引是一种特殊的索引，它不但可以加快从表中检索数据的速度，还能防止在指定的一个或多个列中出现重复值。\nMySQL 索引提示：USE INDEX MySQL 查询优化器是 MySQL 数据库服务器的一个组件，它为 SQL 语句制定最佳执行计划。 MySQL 优化器通常根据索引基数进行决策。 有时候，虽然你创建了索引，但是你的 SQL 语句却不一定使用索引。 这是因为 MySQL 查询优化器的做出了它认为的更优的选择。\nMySQL 允许您使用 USE INDEX 语句建议查询优化器去使用指定的命名索引。\n但是， MySQL 查询优化器依然有可能不适用您建议的索引。 如果您想 MySQL 必须使用您指定的索引，请使用 FORCE INDEX 子句。\n在 EXPLAIN 显示查询优化器使用错误索引的情况下， USE INDEX 很有用\n从输出可以发现， MySQL 查询优化器选择使用 idx_last_name 索引。\n如果您认为使用 idx_last_name_first_name 更好，则使用 USE INDEX 指定它\nUSE INDEX 告诉 MySQL 用列表中的其中一个索引去做本次查询，但是 MySQL 不一定会用。 FORCE INDEX 强制 MySQL 使用一个特定的索引。\n有时候，虽然你创建了索引，但是你的 SQL 语句却不一定使用索引。 这是因为 MySQL 查询优化器的做出了它认为的更优的选择。\nMySQL 查询优化器是 MySQL 数据库服务器的一个组件，它为 SQL 语句制定最佳执行计划。\n但是，您可以是使用 FORCE INDEX 子句告诉 MySQL 查询优化器必须使用指定的索引。\n要查看该语句的执行计划，请使用 EXPLAIN 语句：\nEXPLAIN SELECT * FROM film WHERE language_id = 1;\n当您定义多列索引时，您应该始终考虑业务上下文以确定哪些列经常用于查找，并在定义索引时将这些列放在列列表的开头\nMySQL 聚集索引 聚集索引是一种特殊的索引，此索引中的键值的顺序决定了表中相应行的物理顺序。作为类比，聚集索引类似于一个词典，词典中的目录相当于聚集索引，目录和词语都是按照字母顺序排序的。\n由于表中的数据只能按照一种顺序进行存储，因此一个表中最多只能有一个聚集索引\nMySQL 索引基数 一个索引的基数是指这个索引的列中的唯一值的数量。它是根据统计信息生成的一个估计值，不一定是准确的。\n索引的基数是 MySQL 查询优化器决定是否使用索引的一个重要依据。索引基数越高，使用索引越有效。\n如果索引的基数很低，全表扫描可能比使用索引更有效。\nMySQL 隐藏索引 MySQL 8 引入了隐藏索引（invisible index）。隐藏索引是实际存在的，但是对 MySQL 查询优化器不可见的索引。即使使用 FORCE INDEX，优化器也不会使用隐藏索引。\n在删除一个索引前，您可以先将索引隐藏。如果这不影响性能，您再去真正的删除索引。\n隐藏索引对 MySQL 查询优化器是不可见的，但是它是真实存在的，并且对写入操作保持最新\nMySQL 允许您使用 VISIBLE 和 INVISIBLE 标识索引是否可见\nMySQL 隐藏索引开关 MySQL 查询优化器默认不使用隐藏索引，但是您可以通过系统变量 optimizer_switch 中的 use_invisible_indexes 修改这一行为\nMySQL 字符串前缀索引 在 MySQL 中，您可以为字符串列的指定长度的前缀创建前缀索引。\n相比于为整个字符串列创建索引，前缀索引能减少磁盘的使用量，并提高索引的写入速度\nMySQL 索引顺序 在 MySQL 中，您可以在创建索引的时候指定索引的顺序。默认情况下，索引按照升序存储。\nLinux 启动/停止 MySQL 启动 MySQL 服务器 sudo systemd start mysqld\n停止 MySQL 服务器 sudo service stop mysqld\n重启 MySQL 服务器 sudo service restart mysqld\n在一些 Linux 发行版中，请使用 mysql 替代上面命令中的 mysqld。\n创建一个名为 sqliz 的新用户 CREATE user \u0026lsquo;sqliz\u0026rsquo;@\u0026rsquo;%\u0026rsquo; IDENTIFIED by \u0026lsquo;SqLiZ9879123!\u0026rsquo;;\n使用以下 DROP USER 语句删除用户 sqliz@localhost： DROP USER sqliz@localhost;\n杀掉已删除用户的会话 如果删除的用户在删除之前已经登录了一个会话，删除后并不会影响此会话，直到会话结束。这也会会带来危险。\n你可以使用以下 SHOW PROCESSLIST 语句查看会话列表，并使用 KILL 语句结束已删除的用户的会话。\n如您所见，用户帐户 sqliz@localhost 会话的 ID 是 26 。\n您可以使用使用 KILL 语句终止会话 26 KILL 26;\n您不能使用一个已有的用户账户作为新的用户账户，否则您将收到错误消息。\nRENAME USER 将旧用户的所有权限转移给新用户。但是，它不会删除或使依赖于旧用户的数据库对象无效。\n选择 mysql 数据库： USE mysql;\n更新密码 UPDATE user SET password = PASSWORD(\u0026lsquo;Db123654\u0026rsquo;) WHERE user = \u0026lsquo;dbadmin\u0026rsquo; AND host = \u0026rsquo;localhost\u0026rsquo;;\n刷新权限 FLUSH PRIVILEGES;\n请注意，从 MySQL 5.7.6 开始，用户表使用列 authentication_string 来存储密码。并且，它删除了 password 列。\n因此，如果您使用 MySQL 5.7.6+，则必须修改 UPDATE 语句中的 authentication_string 列 UPDATE user SET authentication_string = PASSWORD(\u0026lsquo;Db123654\u0026rsquo;) WHERE user = \u0026lsquo;dbadmin\u0026rsquo; AND host = \u0026rsquo;localhost\u0026rsquo;;\n通过使用该 SET PASSWORD 语句，您无需执行该 FLUSH PRIVILEGES 语句即可从授权表重新加载权限 以下语句使用 SET PASSWORD 语句更改用户帐户 dbadmin 的密码 SET PASSWORD FOR \u0026lsquo;dbadmin\u0026rsquo;@\u0026rsquo;localhost\u0026rsquo; = PASSWORD(\u0026lsquo;Db123654\u0026rsquo;);\n请注意，从 5.7.6 版开始，您不需要在 SET PASSWORD 语句中使用 PASSWORD()，而是直接使用明文密码。 SET PASSWORD FOR \u0026lsquo;dbadmin\u0026rsquo;@\u0026rsquo;localhost\u0026rsquo; = \u0026lsquo;Db123654\u0026rsquo;;\n第三种更改用户帐户密码的方法是使用 ALTER USER 带有 IDENTIFIED BY 子句的语句 ALTER USER dbadmin@localhost IDENTIFIED BY \u0026lsquo;Db123654\u0026rsquo;;\n如何在 MySQL 中锁定用户帐户 某些特定的场景下，您可能想要锁定一个用户账户，比如：\n创建一个锁定的用户，等授权完成后再解锁 此用户账户已经不被使用 此用户账户已经被泄露 此用户只是临时使用，使用完成后将用户锁定 要锁定一个已经存在的用户，请使用 ALTER USER .. ACCOUNT LOCK 语句。\n要直接创建一个锁定的用户，请使用 CREATE USER .. ACCOUNT LOCK 语句。\n查询用户的锁定状态 SELECT user, host, account_locked FROM mysql.user;\n在 MySQL 中使用 GRANT 语句给用户授权 作为一个数据库管理员或者维护人员，为了数据库的安全性，您需要更精确的权限控制。您可以给不同的用户赋予不同的权限。\n当您创建了一个新用户之后，这个新的用户可以登录 MySQL 数据库服务器，但是他可能没有任何权限。只有在赋予他数据库和相关表的权限之后，他才可以进行选择数据库和查询等操作。\n在 MySQL 中， GRANT 语句用于给用户赋予权限。 分配全局权限 GRANT ALL ON . TO sqliz@localhost; 这里将全部数据库全部对象的全部权限分配给了用户 sqliz@localhost\n分配数据库全部对象的全部权限 GRANT ALL ON sqliz.* TO sqliz@localhost; 这里将 sqliz 数据库全部对象的全部权限分配给了用户 sqliz@localhost\n分配数据库中某个表的的查询和插入权限 GRANT SELECT, INSERT ON sqliz.test_table TO sqliz@localhost; 这里将 sqliz 数据库中的 test_table 表的 SELECT 和 INSERT 权限分配给了用户 sqliz@localhost\nMySQL REVOKE 语句介绍 MySQL REVOKE 语句用于撤销用户帐户的一项或多项权限。\nMySQL REVOKE 语句有几种形式。\n撤销代理 要撤销代理用户，请使用以下 REVOKE PROXY 命令\n代理用户是 MySQL 中可以模拟另一个用户的有效用户，因此，代理用户拥有它模拟的用户的所有权限。\n在撤销用户的权限之前，使用以下 SHOW GRANTS 语句显示用户帐户的权限是一个好习惯\nMySQL REVOKE 生效时机 REVOKE 语句的生效时机取决于权限级别：\n全局: 当用户帐户在后续会话中连接到 MySQL 服务器时，更改生效。更改不会应用于所有当前连接的用户。\n数据库级别: 更改在下 USE 一条语句后生效。\n表和列级别: 更改对所有后续查询生效。\n在 MySQL 中，您可以使用 REVOKE 语句撤销授予用户的一个或者多个权限。\n显示授予当前用户的权限 SHOW GRANTS;\nGRANT USAGE 是没有权限的代名词。默认情况下，当新用户创建时，它没有权限。\n在 MySQL 中，您可以使用 SHOW GRANTS 语句显示授予用户或角色的权限。\n在 MySQL 中使用角色来简化权限管理 MySQL 角色语法 如果要将同一组权限授予多个用户，请执行以下步骤：\n首先，创建一个新角色。 其次，为角色授予权限。 第三，将角色授予用户。\n角色名称类似于用户帐户，由两部分组成：名称和主机。如果省略主机部分，则默认为 %，表示任何主机。\n如果需要在一个语句中创建多个角色，请使用逗号分隔不同的角色名。\n设置活跃角色 用户帐户可以通过指定哪个授予的角色处于活动状态来修改当前用户在当前会话中的有效权限。\n以下语句将活动角色设置为 NONE，表示没有活动角色 SET ROLE NONE;\n要将活动角色设置为所有授予的角色，请使用 SET ROLE ALL;\n要将活动角色设置为 SET DEFAULT ROLE 语句设置的默认角色，请使用 SET ROLE DEFAULT;\nSHOW SCHEMAS 是 SHOW DATABASES 的同义词，他们具有相同的返回结果。\n如果运行此命令的用户不是超级用户，则只返回用户具有权限的数据库列表。\n您还可以使用 LIKE 对结果进行过滤\nMySQL 中的几个维护数据库表的语句 定期的维护数据表是一个很好的习惯。对提高数据库的性能很有帮助。\nMySQL 提供了几个维护数据库表的语句：\nANALYZE TABLE: 分析表 在一个表中进行了大量数据插入，更新或者删除操作后，键分布可能是不准确的。如果键分布不准确，查询优化器可能会选择错误的查询执行计划，这可能会导致严重的性能问题。\n如果你感觉实际执行计划并不是预期的执行计划，执行一次分析表可能会解决问题\nOPTIMIZE TABLE: 优化表 典型的，在一个表中进行了大量数据更新或者删除操作后，表的物理存储可能变得碎片化。最总导致数据库服务器的性能下降\nCHECK TABLE: 检查表 数据库服务器可能发生一些错误，例如服务器意外关闭、向硬盘写入数据时出错等。这些情况可能导致数据库运行不正确，最坏的情况可能是崩溃。\nMySQL 允许您使用 CHECK TABLE 语句检查数据库表的完整性\nREPAIR TABLE: 修复表 REPAIR TABLE 语句允许您修复数据库表中发生的一些错误。MySQL 不保证 REPAIR TABLE 语句可以修复表可能存在的所有错误\n使用 mysqldump 工具备份数据库 mysqldump 是一个用于备份 MySQL 数据库的工具，它能将 MySQL 数据库导出为一个 sql 文件。\n作为一个数据库管理员或者运维人员，定期备份线上的 MySQL 数据库是一个很有必要的工作。它可能帮你在数据库遭到损坏的时候保留数据或者恢复备份。\nMySQL 提供了 mysqldump 工具用于从 MySQL 数据库服务器中导出数据库结构和数据\nmysqldump 是一个用于备份 MySQL 数据库的工具。它提供了很多选项以应对不同的备份需求\n使用 MySQL SOURCE 命令恢复数据库 使用 mysql 命令恢复 在 MySQL 中， SOURCE 命令可以帮您将数据库备份文件恢复到数据库中。除此之外，您还可以直接使用 mysql 命令恢复数据库\n在 MySQL 中使用 SHOW PROCESSLIST 语句显示连接列表 MySQL 提供了 SHOW PROCESSLIST 命令用来返回当前数据库服务器的所有的连接的信息，包括连接的 ID，用户，主机，数据库，时间和状态等。\nMySQL 将当前服务器的所有的连接信息保存在 information_schema.processlist 表中，您还可以从此表查询所有的连接的信息。\n实际上， SHOW PROCESSLIST 命令只是查询 information_schema.processlist 表的简写形式。\n有时，您可能会收到 MySQL 服务器返回的“连接过多”错误。要找出原因，您可以使用 SHOW PROCESSLIST 命令获取当前所有的连接，并使用 KILL 语句终止空闲线程\nMySQL 创建视图 MySQL 是一种常用的关系型数据库管理系统，提供了 CREATE VIEW 语法，用于创建视图（View）。视图是一种虚拟的表，实际上并不存储数据，而是从一个或多个表中派生出来的查询结果集，具有与表相似的结构。通过创建视图，可以将复杂的查询操作封装成一个简单的视图，方便用户进行查询和数据访问\nCREATE VIEW 是 MySQL 中用于创建视图的语法，通过创建视图，可以将复杂的查询操作封装成一个简单的视图，方便用户进行查询和数据访问。在使用 CREATE VIEW 时，需要指定视图的名称、包含的列名、基表和查询条件等。视图可以在数据权限管理、应用程序开发等场景中起到很大的作用，提高数据库的灵活性和安全性。\n可以使用 SHOW 命令来列出数据库中的所有视图 SHOW FULL TABLES IN database_name WHERE TABLE_TYPE LIKE \u0026lsquo;VIEW\u0026rsquo;;\nSHOW FULL TABLES IN mydb WHERE TABLE_TYPE LIKE \u0026lsquo;VIEW\u0026rsquo;;\nMySQL 可更新视图 WITH CHECK OPTION 是 MySQL 中 CREATE VIEW 的一个有用的子句，它允许在创建视图时限制对视图的插入和更新操作。通过合理使用 WITH CHECK OPTION，可以确保只有符合特定条件的数据才能被插入或更新到视图中，从而保护数据库中的数据完整性。在设计数据库时，可以考虑使用 WITH CHECK OPTION 来实现细粒度的数据访问权限控制，提高数据库的安全性和可靠性\nMySQL 触发器 MySQL 触发器是一种数据库对象，它可以在特定的数据库表上自动执行一系列的操作，例如插入、更新或删除数据，当特定的事件（例如数据的插入、更新或删除）发生时触发。MySQL 触发器是一种强大的工具，可以用于实现数据库的自动化行为，例如数据验证、数据关联、审计日志等。\nMySQL 触发器通常由 SQL 语句组成，定义了触发器要执行的操作。MySQL 支持三种类型的触发器：\nBEFORE 触发器：在执行实际的数据操作之前触发，例如在插入、更新或删除数据之前执行某些操作，例如数据验证、数据转换等。\nAFTER 触发器：在执行实际的数据操作之后触发，例如在插入、更新或删除数据之后执行某些操作，例如生成审计日志、更新相关数据等。\nINSTEAD OF 触发器：在执行实际的数据操作之前触发，并可以在触发器中替代原始的数据操作，例如在插入、更新或删除数据之前执行自定义的数据操作，而不是执行原始的数据操作。\nMySQL 触发器可以在创建表时定义，也可以在表创建后通过 ALTER TABLE 语句来添加、修改或删除。触发器可以基于特定的表和事件（插入、更新、删除）来触发，并可以包含条件、循环、异常处理等复杂逻辑。\nMySQL CREATE TRIGGER 创建触发器 数据验证和约束：可以通过触发器在数据插入、更新或删除前后进行验证和约束，确保数据库中的数据满足特定的业务规则和限制条件。 数据补全和处理：可以通过触发器在数据插入或更新前后进行自动补全和处理，例如自动生成序列号、计算字段值等。 数据审计和日志记录：可以通过触发器在数据插入、更新或删除时记录审计日志，用于追踪数据变更历史和安全审计。 数据复制和同步：可以通过触发器在数据插入、更新或删除时自动将数据复制到其他表或数据库，实现数据的同步和复制\nMySQL 的触发器是一种强大的数据库特性，可以在数据库表上定义一组操作，自动在特定事件发生时触发执行。通过 CREATE TRIGGER 语法，我们可以创建自定义的触发器，用于实现数据验证、数据处理、数据审计等业务需求。但需要注意，滥用触发器可能导致性能问题和复杂性增加，因此在使用触发器时应慎重考虑，并遵循最佳实践\nBEFORE INSERT 触发器的语法如下： CREATE TRIGGER trigger_name BEFORE INSERT ON table_name FOR EACH ROW BEGIN \u0026ndash; 触发器操作 END;\n其中，trigger_name 是触发器的名称，可以自定义；table_name 是触发器所属的表名；FOR EACH ROW 表示对表中的每一行数据都执行触发器操作；BEGIN 和 END 之间是触发器操作的具体内容。\nBEFORE INSERT 触发器通常用于在插入数据之前自动执行一些辅助性的操作，如数据验证、数据补全、数据处理等。以下是一些常见的使用场景：\n数据验证：在插入数据之前，对数据进行验证，例如检查数据的完整性、合法性、唯一性等。 数据补全：在插入数据之前，对缺失的数据进行补全，例如设置默认值、自动生成字段值等。 数据处理：在插入数据之前，对数据进行处理，例如将数据进行格式化、转换、加密等。\n","date":"2024-04-13T13:35:01+08:00","permalink":"https://example.com/p/mysql/","title":"mysql"},{"content":"推荐 这是我从一个大佬的个人周刊总结出来可能对我现在或以后有用的项目，资料，软件，网站等，涉及cs学习，日常软件使用，建议结合自己个人去看看\n这是大佬的周刊链接，双手奉上 https://weekly.howie6879.com/\n绝大多数需要在全球最大的同性交流平台上查找————github\n项目 DF-Handling-With-Python 最近刚开源的一款PDF编辑工具[基于Python]（这种类型的库比较少见），你可以对PDF： 提取文本 提取图片 提取表格 提取链接 对PDF进行相关编辑操作\nawesome-productivity-cn 这是一份开放的由中文社区共建的绝妙系列精选资源清单，专注于提升个人生产力的知识方法和工具。此项目从书籍、网站、工具、笔记、任务管理等角度推荐怎么提升个人生产力\nReal-CUGAN 🔥 Real-CUGAN🔥 是一个使用百万级动漫数据进行训练的，结构与Waifu2x兼容的通用动漫图像超分辨率模型。它支持2x\\3x\\4x倍超分辨率，其中2倍模型支持4种降噪强度与保守修复，3倍/4倍模型支持2种降噪强度与保守修复。\nReactive-Resume 免费开源的简历生成器，支持包括中文在内的十几种语言，让你可以快速生成漂亮的简历\nlsky-pro 非常优秀的图床开源项目，如果你手头有服务器，那么可以考虑自建图床服务：\nawesome-wechat-weapp 最近在开发一款微信小程序，第一次上手，发现还是很有意思的。这个项目收集了小程序开发的方方面面，如：工具、插件、组件、Demo等。\n基本上只要找一个开源的小程序，找一个示例跟着写，哪怕你没基础，也能很快开发一款自己的小程序出来，推荐。\naliyundrive-webdav 阿里云盘 WebDAV 服务，主要使用场景为配合支持 WebDAV 协议的客户端 App 如 Infuse 等实现在电视上直接观看云盘视频内容。\n如果你的阿里云盘不少视频，每次播放没必要下载下来，用这个构建一个基于阿里云盘的 WebDAV 服务，然后就可以通过 WebDAV 协议在相关视频软件上播放，我这里就利用 Infuse 连接上了，可以直接看阿里云的相关视频：\n500lines 如果工作中用Python比较多的朋友，应该会听过500lines项目，它是aosabook项目（下面网站部分有介绍）的第四本书。\n这个项目由 18 个独立的章节组成，每个章节都是由该领域的大牛完成，每个章节都试图用 500 行或者更少的代码，让大家了解一个功能或需求的简单实现，比如有：\n持续集成系统 分布式系统 异步爬虫 等等\ncomputer_book_list 该项目整理了豆瓣和goodreads的和计算机，互联网有关的几乎所有书籍。根据不同版本，两个平台的总评价人数和评分求出平均分，按从高到低排列，为寻找经典计算机书籍的朋友提供帮助\nReal-ESRGAN Real-ESRGA目标是做一款针对照片、动画图片的分辨率放大工具，其内置了一个预训练模型，可以提升 4 倍分辨率，具体效果大家可以看看下面的截图：\npython-mini-projects 最近在热榜上挺火的一个项目，这个项目是由一个个 Python 小项目构成，可以慢慢练习，增强 Python 技巧，项目还提供了网站访问\nfree-api 作者创建此开源项目的目的如下：\n为了方便广大的开发者，特此统计了网上诸多的免费API，为您收集免费的接口服务，做一个API的搬运工，以后会每月定时更新新的接口。有些接口来自第三方，在第三方注册就可以成为他们的会员，免费使用他们的部分接口。\n包含域名拦截检测、OCR 识别、文本分类、新闻搜索、天气查询、单词翻译、图灵机器人、随机头像获取等接口：\ndocker-wechat 盒装微信，在linux下基于Docker技术使用微信客户端：\npersonal-management-system 该项目可以很方便的管理个人数据，如目标规划/笔记/联系人/密码/附件/图片/文件等等：\nAI-Writer AI 写小说，生成玄幻和言情网文等等。中文预训练生成模型。采用作者的 RWKV 模型，类似 GPT-2 。\nmelody 你的音乐精灵，旨在帮助你更好地管理音乐；目前的主要能力是帮助你将喜欢的歌曲或者音频上传到音乐平台的云盘。\n主要特性为：\n支持在各大音乐和视频网站检索歌曲。目前支持 咪咕、网易云、QQ 音乐、酷狗、bilibili 等站点 用链接搜索歌曲 一键解锁无法播放的歌曲（实验性功能，目前仅支持网易云） 比如搜索周杰伦的青花瓷，可以直接播放且上传到云盘：\nCleanMyWechat 自动删除 PC 端微信缓存数据，包括从所有聊天中自动下载的大量文件、视频、图片等数据内容，解放你的空间：\nawesome-chatgpt-prompts-zh ChatGPT 中文调教指南，各种场景使用指南，学习怎么让它听你的话：\nlaw-cn-ai AI 法律助手:\nmanga-image-translator 一键翻译各类图片内文字，针对群内、各个图站上大量不太可能会有人去翻译的图片设计，让我这种日语小白能够勉强看懂图片，主要支持日语，汉语、英文和韩语，支持图片修补和嵌字:\nbackground-removal-js 在浏览器环境中直接删除图像背景，不需要额外的成本或隐私问题，在线体验\nsigma-file-manager Sigma File Manager 是一个免费、开源、快速发展的现代文件管理器（资源管理器/查找器）应用程序，适用于Windows\u0026amp;Linux，支持智能搜索、自定义主页、文件共享、文件下载、智能拖放、文件保护等功能：\ndraw-a-ui 利用 tldraw + gpt-4-vision api 将绘制的图转换成 html 代码：\ntvapk 收集各大 AndroidTV 的 apk 应用，可免费看各种vip和国外电影电视：\nwebdesk 一键将网站转化为桌面应用程序：\ngitstars Github 作为开发者的第一社交平台，拥有数不胜数的优秀开源项目，给工作和学习带来巨大方便，遇到自己需要或是喜爱的项目只需点击 Star 便可收入囊中。\nStar is easy，可随着 Starred Repositories 增长，在需要使用到某个项目时难免记不清叫什么，而 Github 又只提供简单的搜索，找到目标 Starred Repository 竟也成了件小小的麻烦事。\n所以拥有自己的 Github Stars Repositories Manager 也算是开发者的必备需求。Gitstars 由此诞生 💡\nimsyy/home 简单优雅的个人主页项目：\n载入动画 站点简介 Hitokoto 一言 日期及时间 实时天气 时光进度条 音乐播放器 移动端适配\nfre123-nav 这是老胡上个月做的一个导航网站，不少人想基于这套进行二次开发，所以开源出来，希望能帮到大家：\nfre123-nav：导航页面源码 fre123-info-flow：信息流页面源码 Fre123 导航网站搭建教程\npaper-ai 利用人工智能撰写论文\n人工智能书写功能： 点击 “AI 写作 “进行正常对话互动。人工智能将根据您的输入提供写作建议或回答问题。 Paper2AI功能： 点击 “Paper2AI”，根据输入的关键词在Semantic Scholar或arxiv中搜索论文。系统将把信息整合到您的论文中。 介绍视频：引用真实文献的AI写论文网站\nczkawka 一款简单、快速和免费的开源跨平台应用程序，可以从您的计算机中删除不必要的文件。\n支持扫描计算机上重复、空文件夹、大文件、相似图像/视频/音乐、无效/损坏文件等内容，扫描速度极快。\n12306spy 从12306购票，从A点到B点没有票，但是可以补票或者多买一段票。这个项目可以让你通过这种方式买到票：\nRaptor 使用 Qt 和 C++ 构建的低内存、小而美的第三方阿里云盘 Windows 桌面应用客户端🚀\n🧬 用户 - 持久化登录，多用户登录，多用户切换 📉 文件（夹） - 创建/多级创建文件夹/重命名/搜索 💅 文件（夹） - 移动/复制 ✅ 文件（夹） - 上传/下载/唤起第三方下载器下载 🎪 视频 - MPV/VLC/PotPlayer 💸 分享 - 创建分享/导入分享 🦹🏻‍♀️ 秒传 - 创建秒传/导入秒传 ⭐️ 收藏 - 收藏/取消收藏/搜索 🕵️‍♂️ 回收站 - 清空/删除/恢复 📚 Plus - 跨网盘文件复制 🏅 UI - 可自由修改的字体，图标与主题\n软件 Joplin 我推崇的一个跨平台笔记软件，更新迭代快速，插件生态也还不错，各大平台都有支持，对于数据存储，你可以：\n自建服务端 第三方如坚果云等 也可以基于云商，如腾讯云的COS\nscrcpy 在GNU/Linux, Windows 和 macOS上显示并控制通过 USB (或 TCP/IP) 连接的安卓设备，不需要任何 root 权限。\n它专注于：\n轻量 (原生，仅显示设备屏幕) 性能 (30~60fps) 质量 (分辨率可达 1920×1080 或更高) 低延迟 (35~70ms) 快速启动 (最快 1 秒内即可显示第一帧) 无侵入性 (不会在设备上遗留任何程序)\n全是漫画 全是漫画App，是替代网页浏览器，专门阅读漫画的工具，无需注册完全免费，基本上覆盖了所有的漫画网站\nuPic uPic是原生强大且美观的MacOS图床软件，支持多种图片上传方式：smms, UPYUN USS, qiniu KODO, Aliyun OSS, TencentCloud COS, BaiduCloud BOS, Weibo, Github, Gitee, Amazon S3, Imgur, custom upload api, …\nBob 同样是我的必备软件，Bob 是一款 Mac 端翻译软件，支持划词翻译、截图翻译以及手动输入翻译。\n[x] 划词翻译 [x] 截图翻译 [x] 输入翻译 [x] 翻译多开 [x] 自定义插件 [x] 自动识别语种 [x] 驼峰拆分、蛇形拆分 [x] AppleScript 调用 [x] PopClip 调用\napifox Apifox 是 API 文档、API 调试、API Mock、API 自动化测试一体化协作平台，定位 Postman + Swagger + Mock + JMeter。通过一套系统、一份数据，解决多个系统之间的数据同步问题。只要定义好 API 文档，API 调试、API 数据 Mock、API 自动化测试就可以直接使用，无需再次定义；API 文档和 API 开发调试使用同一个工具，API 调试完成后即可保证和 API 文档定义完全一致。高效、及时、准确！\nSmart-Scientific-Reader Hammer PDF，一款由北京理工大学计算机学院 DataHammer 研究组开发维护的全新科技智能阅读器，能够快速分析 PDF 学术文献，实时提供可靠的学术信息。增进科研生产力就看这里！\nHammer PDF 将论文、作者、报告视频、数据集、代码、博客等学术资源通过数据关联和知识挖掘等手段组成一个有机整体，不仅提供基础的 PDF 阅读功能，还支持信息抽取、语义分析等自然语言处理任务，大大扩展传统 PDF 阅读器的功能，为研究人员提供最新可靠的扩展信息，显著提升学术研究的工作效率。\n支持网页端、桌面端，非常强大。\nCatchMouse 如果你在工作过程中有两个及以上显示器，那么可能在日常会经常移动鼠标到对应屏幕，这个过程是耗时的，可以使用CatchMouse快速解决这个问题，分别为每个显示器设置快捷键即可。\nvnote VNote是免费、开源的，致力于成为一个舒适的笔记平台（平台支持）\nBulk-Crap-Uninstaller Bulk Crap Uninstaller 是一款免费开源的 Windows 卸载软件，它能够快速删除大量不需要的应用程序，甚至是便携或未注册的程序与游戏，并且能自动扫描残留文件、注册表遗留内容\npot-desktop 🌈 一个跨平台的划词翻译软件，对标 Bob：\npho 一个用于查看和上传照片的无服务端应用，该应用的目的是替代手机上的自带相册应用，并且能够将照片同步到网络储存：\nToastFish 这是一个利用 Windows 通知栏背单词的软件，可以让你在上班、上课等环境下安全地背单词：\nLKY_OfficeTools 一键自动化 下载、安装、激活 Office 的利器。绿色、开源、安全、无毒：\n一键快速下载、安装、激活最新版 Microsoft Office 软件。 用户可在安装 Word、PPT、Excel 的同时，根据软件提示，自助安装其它组件，包括： Outlook、OneNote、Access、Visio、Project、Publisher、Teams、OneDrive、Lync/Skype 工具可自动识别不同的操作系统架构，自动下载适配版本的 Office。 本工具激活 Office 的方式为正版激活模式，不会篡改任何系统文件。 当系统中存在多个冗余 Office 版本时，本工具在用户同意的情况下，可实现自动升级。\nVPet 虚拟桌宠模拟器 一个开源的桌宠软件, 可以内置到任何 WPF 应用程序，支持各种互动投喂等. 开源免费并且支持创意工坊：\nAndroid-Touch-Helper 李跳跳下线了，还有开源的出来，开屏跳过-安卓系统的开屏广告自动跳过助手。\n开屏跳过可以帮助用户自动跳过一些应用的开屏广告，基于Android的无障碍服务实现。\n使用广告跳过程序，最大的风险是个人隐私被泄露。因为这种软件都需要开启Accessibility 无障碍服务，可以获取屏幕上的所有内容，从而可以检测广告，帮助用户自动跳过。\n本程序是开源程序，不需要网络权限，不需要存储权限，不会收集或者上传任何信息！绝无隐私问题：\nGeekDesk 小巧、美观的桌面快速启动管理工具，同时集成了 Everything 搜索，仅支持 Windows：\nlyrebird 基于 Python 和 GTK 编写的变声器，专门适用于 Linux 系列：\n干净简洁的UI 内置效果可实现准确的男声和女声 创建\u0026amp;加载自定义预设的能力 创建自己的临时虚拟输入设备\nGitUp 简洁的 Git 客户端：\nPicList PicList 是一款高效的跨平台云存储和图床平台管理工具，在 PicGo 的基础上经过深度的二次开发，不仅完整保留了 PicGo 的所有功能，还增添了许多新的特性：例如：\n相册支持同步云端删除文件 内置图床额外添加了 WebDav、本地图床和 SFTP 增加了完整的云存储管理功能 等等\nwinlator 使用 Wine \u0026amp; Box86/Box64 的安卓应用程序，此项目特点是可以运行 Windows 应用程序。\nTran 简洁, 快速, 划词翻译：\n开箱即用 永久免费使用 谷歌翻译镜像\ngitbutler Git 分支管理工具，从头开始构建，用于现代工作流：\nFluentRead 一个开源油猴脚本，拥有基于上下文语境的人工智能翻译引擎，为网站提供更加友好的翻译，让所有人都能够拥有基于母语般的阅读体验：\ncrow-translate 一个简单而轻巧的翻译器，可以使用 Google、Yandex Bing、LibreTranslate\u0026amp;Lingva 来翻译和朗读文本：\n资料 influential-cs-books 该项目整理了计算机领域最具有影响力的编程\u0026amp;计算机科学书籍，书单的来源是stackoverflow上一个名为What is the single most influential book every programmer should read? 的回答。\npdai Java 全栈知识体系，包含: Java 基础, Java 部分源码, JVM, Spring, Spring Boot, Spring Cloud, 数据库原理, MySQL, ElasticSearch, MongoDB, Docker, k8s, CI\u0026amp;CD, Linux, DevOps, 分布式, 中间件, 开发工具, Git, IDE, 源码阅读，读书笔记, 开源项目…\n穷佐罗的Linux书 emojimix 一个表情融合网站，图一个乐呵，效果如下：\ncoder2gwy 互联网首份程序员考公指南，由3位已经进入体制内的前大厂程序员联合献上。\n网道 前面资料部分有介绍阮一峰老师的c语言教程，其实那个教程属于这个网道项目的一部分，这个项目的目标是，提供高质量的、拥有自主版权的、可以自由使用的中文软件文档。\ncs-self-learning 计算机自学指南，作者目标是让一个刚刚接触计算机的小白，可以完全凭借这些开源社区的优质资源，少走弯路，在2-3年内成长为一个有扎实的数学功底和代码能力，经历过数十个千行代码量的Project的洗礼，掌握至少C/C++/Java/JS/Python/Go/Rust等主流语言，对算法、电路、体系、网络、操统、编译、人工智能、机器学习、计算机视觉、自然语言处理、强化学习、密码学、信息论、博弈论、数值分析、统计学、分布式、数据库、图形学、Web开发、云服务、超算等等方面均有所涉猎的全能程序员。\nmissing-semester-cn 计算机教育中缺失的一课，翻译自麻省理工的《The Missing Semester of Your CS Education》。\n在传统的计算机科学课程中，从操作系统、编程语言到机器学习，这些高大上课程和主题已经非常多了。 然而有一个至关重要的主题却很少被专门讲授，而是留给学生们自己去探索。 这部分内容就是：精通工具。\nLeetCode-Py 算法通关手册，超详细的「算法与数据结构」基础讲解教程，「LeetCode」650+ 道题目 Python 版的详细解析。通过「算法理论学习」和「编程实战练习」相结合的方式，从零基础到彻底掌握算法知识。\nCS-Notes 📚 技术面试必备基础知识、Leetcode、计算机操作系统、计算机网络、系统设计:\nleetcode 本项目包含 LeetCode、《剑指 Offer（第 2 版）》、《剑指 Offer（专项突击版）》、《程序员面试金典（第 6 版）》等题目的相关题解。所有题解均由多种编程语言实现，包括但不限于：Java、Python、C++、JavaScript、C#、Go，日常更新。\nleetcode-master LeetCode 刷题攻略：200道经典题目刷题顺序，共60w字的详细图解，视频难点剖析，50余张思维导图，支持C++，Java，Python，Go，JavaScript等多语言版本，从此算法学习不再迷茫！本项目同样提供了在线访问地址：programmercarl\nwhys-the-design 为什么这么设计（Why’s THE Design）是一系列关于计算机领域中程序设计决策的文章，我们在这个系列的每一篇文章中都会提出一个具体的问题并从不同的角度讨论这种设计的优缺点、对具体实现造成的影响。\n猴子都能懂的GIT入门 一份免费的简单易懂的 Git 入门教程，分为入门篇和高级篇\nlean-side-bussiness 精益副业：程序员如何优雅地做副业:\ndeveloper-roadmap 开发人员学习成长路线图：\nStudent-resources 本文介绍的是利用学生、教职工身份可以享受到的相关学生优惠、教育优惠或教师优惠的权益，但也希望各位享受权利的同时不要忘记自己的义务，不要售卖、转手自己的学生优惠、教育优惠的资格，使得其他同学无法受益。\nmysql-tutorial 从零开始学习MySQL，主要是面向MySQL数据库管理系统初学者：\nlinux-command Linux命令大全搜索工具，内容包含Linux命令手册、详解、学习、搜集\nawesome-mongodb 关于 MongoDB，最全面的免费学习向导：\n学习资源：文档书籍教程等 第三方库：各种编程语言的兼容库 各种工具：比如桌面应用、Web GUI、迁移工具等\nhello-algo Hello 算法是一本动画图解、能运行、可提问的数据结构与算法入门书，本书面向数据结构与算法初学者，致力于达成以下目标：\n开源免费，所有同学都可在网上获取本书； 新手友好，适合算法初学者自主学习入门； 动画讲解，尽可能地保证平滑的学习曲线； 代码导向，提供精简、可运行的算法代码； 讨论学习，提问一般能在三日内得到回复；\n计算机底层的秘密 以图解的方式通俗易懂地讲解计算机系统中各项技术的本质，包括编程语言的本质是什么、操作系统、进程线程协程等的本质是什么、到底什么是内存、什么是堆区栈区、内存分配等是怎么一回事、怎样从晶体管构建出CPU、I/O是如何实现的等等，从根源出发，一步步讲解一项技术到底是怎么来的，同时内容可视化——辅助大量精心设计的插图，几乎做到了平均一页有一图，把对技术的理解门槛尽量降低-在线阅读(需要pdf可联系我私发)：\ntuning_playbook_zh_cn 深度学习调优指南中文版，一本系统地教你将深度学习模型的性能最大化的战术手册：\none-python-craftsman 来自一位 Pythonista 的编程经验分享，内容涵盖编码技巧、最佳实践与思维模式等方面：\nhzpt-inet-club/english-note 从0开始学习英语语法的开源项目：\nsql-mother 免费的闯关式 SQL 自学教程网站，从 0 到 1 带大家掌握常用 SQL 语法，纯前端实现，简单易学\nnote-hack 《打造超人笔记》是一本关于如何有效记录和整理笔记的书籍。\n作者认为，笔记是一个看起来复杂但实际上比学习和阅读更简单的问题。通过拆解笔记的流程，作者发现主要问题的结构变得非常简单。此外，随着科技的发展，许多快速记录工具和笔记整理软件已经被发明出来，使笔记搜寻变得更加容易。\n在本书中，作者探讨了如何通过做笔记和整理笔记来挖掘和整理自己对一个领域的各种答案。通过阅读本书，读者可以学习到如何使用各种工具和方法来提高自己的笔记能力，成为一个笔记超人。\nGolangStudy 《GolangStudy》：从简单到难最全总结，go基础，数据结构，算法，设计模式：\nMySQL\u0026amp;PG 数据库教程 一个专门讲数据库教程的资料网站\nsmartexcel 使用 ChatGPT，在几秒钟内生成您所需的 Excel 公式\nLinux 101 本书由中国科学技术大学 Linux 用户协会的数名优秀成员协力编写，用于配套和延展“Linux 101”校内社团活动。其面向 Linux 零基础读者，从计算机操作系统和 Linux 的起源讲起，深入浅出带领读者一步步逐渐掌握最必要的 Linux 实用知识，并在其中感悟到社区开源文化的魅力：\nv2rayA v2rayA 是一个支持全局透明代理的 V2Ray 客户端，同时兼容 SS、SSR、Trojan(trojan-go)、Tuic \u0026amp; Juicity 协议， 致力于提供最简单的操作，满足绝大部分需求，得益于 Web 客户端的优势，你不仅可以将其用于本地计算机，还可以轻松地将它部署在路由器或 NAS 上。\nPaperlib 一个简单好用的开源论文管理工具，全平台支持：\n为多学科定制元数据搜索器，尤其是 CS 学科，及其精准的会议论文metadata 匹配。 macOS spotlight 一样的快速复制粘贴 bibtex 引用。 支持插件。 干净整洁的 UI。 订阅 RSS 获取最新论文 全文搜索，评价，星标，标签，组，MD 纯文本笔记等 云同步，三平台支持：macOS, Windows, Linux\nSam Altman的创业手册 Sam Altman 的创业手册文本，给YC系创始人们的建议里面最通用的一部分提炼出来变成一个创业手册。\nwaytoagi AI 知识库和工具站\n网站 Connected Papers Connected Papers是一个旨在帮助科研工作者搜索文献的全新工具，除了搜索目标论文外，它还可以在线进行分析文献的引文信息并以图网络的形式展现出来\ncleanup.pictures 百分百免费的一款图片橡皮擦工具，可以擦涂图片上的一些背景和无关图案，获得过producthunt周榜首荣誉，并且也开源在 github 值得尝试，下面是擦除前后对比：\nPython Tutor 这个网站可以将Python代码执行并可视化展示，目前共支持Python、Java、C、C++、JavaScript、Ruby等编程语言，新手教学、教程编写可以引用可视化结果来方便理解：\nQwerty Learner 这也是一个开源项目，作者将英语单词的记忆与英语键盘输入的肌肉记忆的锻炼相结合，可以在背诵单词的同时巩固肌肉记忆。\n网站提供了常用的 CET-4 、CET-6 、GMAT 、GRE 、IELTS 、SAT 、TOEFL 、考研英语、专业四级英语、专业八级英语，也有程序员常见英语单词以及多种编程语言 API 等词库。\ncalmcode 非常适合Python开发者的一个学习网站，里面通过短视频介绍了各种有用的工具，看了几分钟就可以上手，能快速扩充你的知识面。\nYYeTsBot 人人影视bot，完全对接人人影视全部无删减资源，用户除了通过浏览器访问，还可以通知TG访问：\nregexlearn 一个正则表达式学习网站，一步一步带你从新手到高级阶段，值得一试：\n即时工具 该网站提供了视频工具、音频工具、图片工具、PDF 工具、办公辅助、设计工具、文本工具、数字工具、加密工具、单位转换等工具共计 200 多款，无需登录无任何限制免费试用。\nregex101 regex101主要解决的是不同语言开发时怎么快速测试正则表达式的问题，目前网站支持以下语言：\nPHP Python JS Go Java\nlearngitbranching @妙才投稿，在线学习git命令的网站：\nsci-hub 这是科研界女神Alexandra Elbakyan做的论文下载网站，诞生以来就一直受到相关领域的打击，甚至一度即将消亡，但是作者不屈不挠这次甚至做了更新！\nElbakyan 表示：「 Sci-Hub 更新了，现在用户可以实时查看下载统计、每月统计等，并在将来会增加更多内容。」\n用户可通过以下方式访问新版本：\nhttps://sci-hub.se/ https://sci-hub.ru/ https://sci-hub.st/\ndevtool.tech 开发者武器库，作者提供了83个开发者常用的工具：\nwatermarkremover 通过AI技术去除图片水印：\njsonvisio 将你的Json数据进行可视化，该项目也开源在github-jsonvisio：\ncook 一个开源的做菜项目，作者提供了做菜网页版让用户可以很方便地进行交互，比如我选择番茄，下面就会有很多选项：\nmyfirstnft 我的第一个NFT，在这个网站，你可以：\n理解NFT的价值 铸造一个免费的NFT 了解Web3.0\nmusetransfer MuseTransfer 是一款轻便高效的大文件在线传输工具，无需注册登录，打开网页即可免费全速上传或下载超大文件\npixabay Pixabay 是全球知名的图库网站及充满活力的创意社区，拥有上百万张免费正版高清图片素材，涵盖照片、插画、矢量图、视频等分类，你可以在任何地方使用 Pixabay 图库中的素材，无惧版权风险：\nsayhello 面向开发者的搜索引擎。搜索结果可以直接显示出来相关代码片段：\ndevdocs 提供在线快速查找API接口文档的网站：\nmeow.tg TG喵-可能是最懂你的Telegram资源搜索引擎:\njsont.run 一个简洁的在线 JSON 解析器：\nphotoroom 利用人工智能生成背景图片（基于Stable Diffusion license），还提供了智能去除图片背景的功能\nsmalldev.tools 开发者常用工具集：\nwantquotes.net 清华大学计算机系自然语言处理实验室出品的一款根据意思查询名言\u0026amp;佳句\u0026amp;诗词\u0026amp;网络\u0026amp;台词的网站：\ntldraw 小巧强大的在线绘图工具：\ncleverpdf 几十个强大的PDF在线工具，无需注册会员，永久免费：\nextractcss 提取 html 结构里面的 css 代码：\n帮小忙 腾讯出品的小工具合集，轻松办公，工具助你一臂之力，功能一应俱全、简单好用的线上工具宝：\nscribblediffusion.com 随便画一画，生成美观的图片\nchatpdf 和任何 PDF 进行沟通交流：\nchatdoc ChatDOC 让你可以和文档进行聊天沟通，它是一个基于 ChatGPT 的文件读取助手，它可以从 PDF 中快速提取、定位和总结信息：\nifixit 一个免费教授人们如何修理任何物品的网站：\nfusionbrain.ai 文字生成图片网站，效果和速度都还可以：\nonepdf 免费的 PDF 格式转换网站，支持PDF 转 Word 、PDF 转 Excel 、PDF 转 PPT 、PDF 转 JPG 、PDF 转 PNG 、Word 转 PDF 、Excel 转 PDF 、PPT 转 PDF 、JPG 转 PDF 、PNG 转 PDF 、CAD 转 PDF 功能：\ntgscan 免费开源的 Telegram 搜索：让你轻松找到频道、群组和聊天记录：\n纸砚双拼 一个好看的双拼学习网站\n123apps 网站提供了一系列的小工具，包含分类：\n视频工具 音频工具 PDF 工具 转换器 \u0026hellip;\u0026hellip;\nroadmap.sh 这是一个开源免费的项目，主要是提供了各种技术栈的学习路线：\nonemodel 为软件工程师量身定制的绘图工具，网站提供很多软件架构的图标、素材、模板：\ntranshumans 免费可商用的人物插图：\nAnyBT 种子搜索引擎，下载你想要的资源：\nstockai.trade AI 选股分析网站（基于 ChatGPT）完全免费，无需注册:\ntik.fail 国内能直接刷TikTok的在线网站，支持搜索和下载\n最佳平替 同一件商品，不同的搜索词，价格可能会天差地别。这个工具旨在帮助你找到最便宜的搜索词: 输入你想搜索的商品名，AI会给出低价的替代品，结果可能不准，开心就好：）\naiwallpaper AI 生成高清壁纸，项目开源在：all-in-aigc/aiwallpaper。\n开源代码包括：\nnextjs 全栈开发 API 和 Web dalle-3 绘图对接 aws s3 图片上传 postgres 数据读写 谷歌登录 stripe 非常适合参考学习，用来做一些小而美的 AI 应用。\n","date":"2024-03-28T13:28:01+08:00","permalink":"https://example.com/p/%E5%A5%BD%E4%B8%9C%E8%A5%BF%E5%93%A6/","title":"好东西哦！"},{"content":" 在搭建个人博客时，遇到了各种阴间问题，为此我删了起码七个库，都是泪，归根到底就是两个问题，一是主题配置，二是远程连接\nhugo（静态网站生成器） 其实不管什么东西，我都是建议先去看官方文档的，就像我师兄说的，你看别人教程就像别人消化后la给你，就像人体蜈蚣，哈哈哈，但是说实在，我也是过来人，有些东西确实需要别人指点一二，抛砖引玉，我写的博客一是为了自己复盘，二是想成为那个砖，帮助那些像我在学习时一样的朋友引出自己的玉，说多了\n总之，先给官方文档 https://www.gohugo.org/\n看的懂最好，看不懂，那就看看我的或别人的\n这一步可以参照网上很多人的文档，最推荐官方，下载链接如下： https://github.com/gohugoio/hugo/releases\n选择对应的压缩包版本，这里注意一下有extend的区别，我看了一下，extend只是多了一些可以自己操作的东西，新手还是建议老老实实的\n下载好压缩包之后，不论你是解压到哪里，都需要配置路径才能使用，因此一般推荐安装在除C盘之外的盘，例如我放在D盘中，新建一个文件夹Hugo，将解压的内容放进去，你可以看到最主要的其实就是一个.exe的二进制文件(意味着人家已经编译好了，我们直接拿来用就可以)，并将源文件夹的名字修改为bin\n解释一下，为什么要改文件夹名字？ 为了添加环境变量\n为什么文件夹的名字是bin？ “约定俗成”，二进制的英文是 binary ，取前三个字母，其实没有什么特殊的含义，你要高兴，取你自己的名字都行，只要把.exe文件添加进环境变量就行\n什么是环境变量？ emmmn，好问题，详细的无法解释，粗略一点，只有程序被添加到环境变量中后，才能被我们的操作系统识别并调用。\n如何添加环境变量？ 请善用搜索引擎，有很多写得超级详细\n以上信息是别人博主发的，我懒得写，哈哈\n生成站点 使用Hugo快速生成站点，比如希望生成到 /path/to/site 路径：\n在cmd输入哦\n$ hugo new site /path/to/site\n这样就在 /path/to/site 目录里生成了初始站点，进去目录：\n$ cd /path/to/site\n站点目录结构：\n▸ archetypes/ ▸ content/ ▸ layouts/ ▸ static/ config.toml\n在这个目录下，最主要的是对hugo.toml，themes/的配置。创建的所有.md文件都放置在content/文件下，所有文章的图片都放在static/下面\n创建文章 创建一个 about 页面\n$ hugo new about.md\nabout.md 自动生成到了 content/about.md ，打开 about.md 看下\n+++\rdate = \u0026quot;2015-10-25T08:36:54-07:00\u0026quot;\rdraft = true #这个东西是草稿的意思，我建议是你每发一篇博客都改为false，以后你每一篇博客都是每一篇文章\rtitle = \u0026quot;about\u0026quot;\r+++\r正文内容\n创建第一篇文章，放到 post 目录，方便之后生成聚合页面\n$ hugo new post/first.md\n安装皮肤 一个好看的主题是必要的，但是完全自己去写就太麻烦了，hugo中有很多精美的主题，比较方便的操作是在Hugo项目目录里面使用Git命令来克隆themes：你需要提供主题的 Git 仓库 URL。通常，主题的仓库 URL 可以在 Hugo Themes 官方网站或主题的文档中找到。\ngit clone https://github.com/author/theme-name.git themes/theme-name\n或者直接下载主题的压缩包，将其解压到themes/文件夹下，这样的话，就需要你对hugo.toml文件进行一点过的修改。\ngit的介绍可以看看官方文档或者我的博客也有，基本都是我从官方文档中学习的\n配置hugo.toml 好多教程里面直接就说会生成config.yml文件，但事实上新版的都是生成的hugo.toml，这不免让第一次配置的人感到迷惑，这两种的使用都是可以的，只是在语法结构上会有区别(类似于c++和python)，如果你想要完全自己手搓，按照你喜欢的语言就好，如果像我一样，只想点点鼠标，那就主要观察你下载的themes里面它使用的是什么，跟着用就行。\n例如，我下载的主题是PaperMod，其提供的范例里面用config.yml替代了hugo.toml，所以在使用时，可以直接将范例中的文件替代掉你创建的站点下的hugo.toml文件，并在里面进行一定的修改\n使用主题前最好看一下主题相应的配置教程，不同的主题是不一样，主题就是别人写好的网站的模板，而你就是去套用别人的模板。\ntheme = \u0026ldquo;my-theme\u0026rdquo; // my-theme是你下载的theme的主题名，要和你解压的文件名一致\n生成网站 需要注意的是，虽然我们做了这么多，但是在这个结构下(在 my-site这个结构下)，我们网站的页面实际上是还没有生成的，要想生成静态网站页面，必须运行如下命令\nhugo\n命令运行后，在上文提到my-site这个结构下会产生一个public/文件夹，里面保存生成的静态页面，后面将其在GitHub上面布置，实际上就是将public/中的内容远程推送到Github仓库中后进行展示。\nhugo server\n可以在本地预览你生成的网站，点击链接就可以在你本地的电脑看到自己搭建的网页的，但是这只是完成了一半，你需要将其托管到github page上，别人才能通过网址找到你的网站，github page是最简单且免费的方法，当然便宜的东西是有缺陷的，如果以后自己想深入，就需要买个域名和服务器了\n推送到GitHub 首先在GitHub上创建一个仓库，名字最好和你自己的名字一样，其实也无所谓，但是好多人都这么做，但是我不是\n在pubilc文件夹中创建仓库 记得cd 进入对应的文件夹\n其实远程连接在我的git博客上有详细的教程，这里我大概说一下\ngit init 初始化仓库 git add. 增加所有修改的意思 git commit -m \u0026ldquo;备注\u0026rdquo; 提交到远程仓库“备注随便写，你写我是傻逼都行”\n将两个仓库链接起来 这一步是最恶心我的，不知道为什么，不能用http链接，只能用ssh链接 大概就是你需要在你的电脑生成一个ssh链接，然后将其放到GitHub的配置上\n这步是参考别人的\n打开git bash命令窗口 生成ssh key ssh-keygen -t rsa -b 4096 -C \u0026ldquo;your_email@example.com\u0026rdquo;\nyour_email@example.com为github上你注册的email地址。\n然后直接三个enter不管他\n上面默认生成在用户主目录的.ssh目录下，可以自己输入自定义位置\n把ssh key添加到github 复制文件c/Users/Administrator/.ssh/id_rsa.pub内容，把key添加到：github \u0026gt; settings \u0026gt; SSH and GPG keys \u0026gt; New SSH key \u0026gt; 粘贴保存。\n测试SSH连接 $ ssh -T git@github.com\n如果成功的话你就可以通过SSH方式来clone及提交代码了\n// 创建一个分支 git branch -M main //使用 git remote add 命令将远程仓库添加到仓库配置中 git remote add origin https://github.com/your-username/your-repo.git //使用 SSH 连接后，可以使用 SSH URL 推送到 GitHub 仓库 git remote set-url origin git@github.com:your-username/your-repo.git //推送文件 git push -u origin main\n后续提交 //在站点中运行 hugo\n//进入public/文件夹下 cd public/\n//提交文件\ngit add .\ngit commit -m \u0026ldquo;备注\u0026rdquo; //推送到远程：在ssh已连接的情况下\ngit push -u origin main\n","date":"2024-03-27T13:28:01+08:00","permalink":"https://example.com/p/%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA%E5%91%80/","title":"个人博客搭建呀"},{"content":"\nWindow与Linux双系统安装与卸载Linux 如果你事先在window上安装的ubuntu,但是因为种种原因需要重装，那么你需要先卸载装在你电脑上的ubuntu系统才能安装新的Ubuntu\n重装unbuntu记得先保存好ubuntu想保存的文件\nUbuntu卸载 删除ubuntu所在卷 进入windows系统，右键此电脑-管理-磁盘管理-删除ubuntu所在的卷，使这些区域成为“可用空间”\n删除unbuntu EFI分区 Win + R 输入cmd打开终端，输入 diskpart 进入磁盘工具\n输入 list disk 查看磁盘，输入 select disk 1 （我的Ubuntu EFI分区在磁盘1，根据自己的情况选择）\n输入 list partition ，输入 select partition * （*为Ubuntu EFI分区号）\n删除Ubuntu系统启动项 Win + R 输入cmd打开终端，输入 diskpart 进入磁盘工具\n输入 list disk 查看磁盘，输入 select disk 1\n输入 list partition ，输入 select partition * （*为Windows EFI分区，一般为260M）\n输入 assign letter=J（分配盘符）\n管理员模式打开记事本，记事本选择文件-打开-选中磁盘J\n打开 EFI 文件夹，删除Ubuntu文件夹\n返回 Distpart 界面，输入 remove letter=J\n磁盘分区（如果你是第一次装Ubuntu） 1.打开计算机管理 2.找到磁盘管理 3.选择你要压缩的盘，你压缩掉的空间将作为新系统的空间 4.右键打开你要压缩的盘符，点击压缩卷 安装ubuntu系统 强烈建议安装最新lts版本，我写这篇博客时是22.04版 我就是因为第一次装的是18.04版所以才重装的，QAQ\n下载Linux镜像 1.下载 Ubuntu 镜像，这里可以去官方下载，但是官方在国外，默认外网链接可能网速有点小慢。（科技玩家例外） 更好的选择是国内的资源镜像网站，比如说清华大学开源软件镜像站\n清华大学开源软件镜像站 https://mirrors.tuna.tsinghua.edu.cn/\n准备u盘刻盘工具 我用的是UltralSO\n下载后打开，找到你下载的镜像文件，找到后，点击右上角的启动-\u0026gt;写入硬盘映像\n写入时记得插入u盘，这个u盘将作为启动盘 写入时，这个u盘的数据全会被格式化，谨慎操作\n然后点击写入就可以了\n开机引导界面 将写好的映像文件的U盘插入你需要的电脑，在开始时按f12，本人用的是联想，不同电脑可能不同，正常都是f12\n在引导界面可以看到几个选项，选择你的u盘作为启动项，反正不是window和network就是了\n启动后你会进入系统选择界面，使用方向键选择 ubuntu 后回车就进入了 Ubuntu 的安装引导界面。在侧边栏中选择系统语言，English、Chinese都可，看自己喜好，然后点击 Install Ubuntu 进入安装，选择安装方式，选择正常安装就行，会默认安装火狐浏览器等软件。或者选择最小安装的话可以在安装完成后自行安装需要的软件，两种方式影响不大。下面的安装第三方软件选项也可以选上，也可以不选，后面再根据需要手动安装。我这里就只选择了正常安装，然后点击继续，在安装类型选择时，建议自己手动分区，说一下分区情况吧，我找了大部分教程都是分为四个区：\n分区方案 /boot : 1G（最好） 主分区。系统的boot启动引导项安装位置\n/ : 随意（尽量大） 主分区。根目录，所有目录的根节点，其下包含很多子目录，如/usr /tmp等\n/home : 自定义（尽量大，一般最后分） 逻辑分区。一般放置自己的数据\nswap : 16G 逻辑分区。交换空间，一般是物理内存的1~2倍就行了\n具体操作，首先找到 free space 空间，如下，选中该空间，点击左下角的加号+，进行内存分配\n安装后-\u0026gt;选择地区（上海或香港都可以，我选的是上海）-\u0026gt;设置账户密码-\u0026gt;重启-\u0026gt;输入密码，ok\n我和同学在重启时都出现，黑屏跳一堆数据的情况，我们当时都很慌，但是我们最后强制关机重启后，发现没有大问题，起码我们没发现问题\n以后你每次开机时都可以选择windo和Linux之一的系统进行启动\n","date":"2024-03-26T18:28:01+08:00","permalink":"https://example.com/p/linux%E9%87%8D%E8%A3%85/","title":"Linux重装"},{"content":"\nroots.txt协议： 君子协议：规定了网站中的哪些数据可以被爬虫爬取，哪些不能碰\nhttp协议： 概念：就是服务器和客户端进行数据交互的一种形式\r常用请求头信息 user-agent:请求载体的身份标识\rconnection：请求完毕后，是断开连接还是保持连接\r常用响应头信息： content-type：服务器响应回客户端的数据类型\rhttps协议： 安全的超文本传输协议\r加密方式： 对称密钥加密\r非对称密钥加密\r证书密钥加密\rreques模块 python中原生的一款基于网络请求的模块，功能强大，简单便携，效率极高\r作用：模拟浏览器发请求\r如何使用： 指定URL\r发起请求\r获取响应数据\r数据解析\r持久化存储\r有些数据可能是动态请求加载出来的，不能通过url直接请求出来\n数据解析 ： 解析的局部的文本内容都会在标签之间或标签对应的属性中进行存储 1.进行指定标签的定位\r2.标签或者标签对应的属性中存储的数据值进行提取（解析）\r聚焦爬虫：爬取页面中指定的页面内容 正则 bs4 xpath\ntext(字符串) content(二进制) json()(对象)\nbs4进行数据解析 1.实例化一个BeautifulSoup对象，并将页面源码数据加载到该对象中\r2.通过调用BeautifulSoup对象中相关的属性或方法进行标签定位和数据提取\rxpath解析:最常用且便携高效的一种解析方式，通用性 -xpath解析原理：\r1.实例化一个etree的对象，且需要将被解析的页面源码数据加载到该对象中\r2.调用etree对象中的xpath方法结合着xpath表达式实现标签的定位和内容的捕获\r-环境安装\r-如何实例化一个etree对象：from lxml import etree\r1.将本地的html文档的源码数据加载到etree对象中：\retree.parse(filePath)\r2.可以将从互联网上获取的源码数据加载到该对象中：\retree.HTML('page_text')\r- xpath('xpath表达式')\r1./表示的是从根节点开始定位。表示的是一个层级\r2.//表示的是多个层级。可以表示从任意位置开始定位\r3.属性定位：//div[@class='song'] tag[@attrName=\u0026quot;attrValue\u0026quot;]\r4.索引定位：//div[@class='song']/p[3] 索引是从1开始的\r5.取文本：\r/text()获取的是标签中直系的文本内容\r//text()标签中非直系的文本内容\r6.取属性：\r/@attrName ==\u0026gt;img/src\r验证码识别 反爬机制：验证码。识别验证码图片中的数据，用于模拟登录操作\n识别验证码的操作： 人工肉眼识别 第三方自动识别\ncookie:用来让服务器端记录客户端的相关状态 1.手动处理：通过抓包工具获取cookie值，将值封装到headers中\r2.自动处理：\rcookie值来自登录post请求后，由服务器端创建\rsession会话对象：\r作用：\r1.可以进行请求的发送\r2.如果请求过程中产生了cookie，则该cookie会被自动存储/携带在该session对象中\r创建一个session对象：session=requests.Session()\r使用session对象进行模拟登录post请求的发送（cookie就会被存储在session中）\rsession对象对个人主页对应的get请求进行发送（携带了cookie）\r代理：破解封ip这种反爬机制 什么是代理：代理服务器\r代理的作用：\r突破自身ip访问的限制\r隐藏自身真实ip\r代理相关的网站：\r快代理\r西si代理\rwww.goubanjia.com\r代理ip的类型：\rhttp:应用到http协议对应的url中\rhttps：应用到https协议对应的url中\r代理ip的匿名度：\r透明：服务器知道该次请求使用了代理，也知道请求对应的真实ip\r匿名：服务器知道该次请求使用了代理，不知道请求对应的真实ip\r高匿：服务器不知道该次请求使用了代理，不知道请求对应的真实ip\r高性能异步爬虫 目的：在爬虫中使用异步实现高性能的数据爬取操作 异步爬虫的方式： 1.多线程，多进程（不推荐）\r好处：可以认为相关阻塞的操作单独开启线程或者进程，阻塞操作就可以异步执行\r弊端：无法无限制的开启多线程或者多进程\r2.线程池，进程池（适当的使用）\r好处：我们可以降低系统对进程或者线程创建和销毁的一个频率，从而很好的降低系统的开销\r弊端：池中线程或者进程的数量是有上限的\r3.单线程+异步协程（推荐）\revent_loop：事件循环：相当于一个无限循环，我们可以把一个函数注册到这个事件循环上，当满足某些条件时，函数就会被循环执行\rcoroutine:协程对象，我们可以将协程对象注册到事件循环中，它会被事件循环调用。我们可以使用async关键字来定义一个方法。这个方法在调用时不会被立即执行，而是返回一个协程对象。\rtask：任务，它是对协程对象的进一步封装，包含了任务的各个状态\rfuture：代表将来执行或还没被执行的任务，实际上和task没有本质区别\rasync:定义一个协程\rawait：用来挂起阻塞方法的执行\r在异步协程中如果出现了同步模块相关的代码，就无法实现异步 当在asyncio中遇到阻塞操作时必须进行手动挂起 异步模块中 text()文本 read()二进制 json()json对象 获取响应数据操作之前一定要使用await进行手动挂起\nselenium模块的基本使用 问题：selenium模块和爬虫之间具有怎样的关联 便携的获取网站中动态加载的数据 便携实现模拟登录\n什么是selenium模块 基于浏览器自动化的一个模块\nselenium使用流程： 环境安装 下载一个浏览器的驱动程序 实例化一个浏览器的映射关系 便携基于浏览器自动化的操作代码 发起请求:get(url) 标签定位:find系列方法 标签交互:send_keys(\u0026lsquo;xxx\u0026rsquo;) 执行js程序:excute_script(\u0026lsquo;jsCode\u0026rsquo;) 前进，后退:back(),forward() 关闭浏览器:quit()\nselenium处理iframe\r如果定位的标签存在于iframe标签之中的则必须进行标签定位，使用switch_to.frame(id)\r动作链(拖动)：from selenium.webdriver import ActionChains\r实例化一个动作链对象：action = ActionChains(bro)\rclick_and_hold(div):长按且点击操作\rmove_by_offset(x,y)\rperform()让动作链立即执行\raction.release()释放动作链对象\r无头浏览器 12306模拟登录 超级鹰：http://www..chaojiying.com/about.html\r注册：普通用户\r登录：普通用户\r提分查询：充值\r创建一个软件（id）\r下载示例代码\r12306模拟登录编码流程：\r使用selenium打开登录页面\r对当前selenium打开的这张页面进行截图\r对当前图片局部区域（验证码图片）进行裁剪\r好处：将验证吗图片和模拟登录进行一一对应\r使用超级鹰识别验证码图片（坐标）\rscrapy框架 什么是框架 就是一个集成了很多功能并且具有很强通用性的一个项目模板\n如何学习框架 专门学习框架封装的各种功能的详细用法\n什么是scrapy 爬虫中封装好的一个明星框架。功能：高性能的持久化存储，异步的数据下载，高性能的数据解析，分布式\n基本使用 环境的安装\r测试：在终端里录入scrapy指令，没有报错就是成功\r创建一个工程：scrapy startproject xxPro\rcd xxxPro\r在spiders子目录中创建一个爬虫文件\rscrapy genspider spiderName www.xxx.com\r执行工程\rscrapy crawl spiderName\rscrapy数据解析 基于终端指令：\r要求：只可以将prase方法的返回值存储到本地的文本文件中\r注意：持久化存储对应的文本文件的类型只可以是：\u0026quot;json,jsonlines,jl,csv,xml\r指令：scrapy crawl xxx -o filePath\r好处：简介高效便携\r缺点：局限性比较强（数据只可以存储到指定后缀的文本文件中）\r基于管道：\r编码流程：\r数据解析\r在item类中定义相关的属性\r将解析的数据封装存储到item类型的对象\r将item类型的对象提交给管道进行持久化存的操作\r在管道类的process_item中要将其接受到的item对象中存储的数据进行持久化存储操作\r在配置文件中开启管道\r好处：\r通用性强\rxpath返回的是列表，但是列表元素一定是Selector类型的对象 extract可以将Selector对象中data参数存储的字符串提取出来 列表调用了extract之后，则表示将列表中的每一个Selector对象中data对应的字符串提取出来\nprocess_item方法 专门用来出来item类型对象 该方法可以接收爬虫文件提交过来的item对象 该方法每接收到一个item就会被调用一次\nparse方法 用作于数据解析:response参数表示的就是请求成功后对应的响应对象\nyield item 将item提交给了管道\n管道文件中一个管道类对应将一组数据存储到一个平台或者载体中\n显示指定类型的日志信息 LOG_LEVEL = \u0026ldquo;ERROR\u0026rdquo;\n面试题：将爬取的数据一份存储到本地，一份存储到数据库，如何实现？ 管道文件中一个管道类对应的是将数据存储到一种平台 爬虫文件提交的item之后给管道文件中第一个别执行的管道类接收 process_item中的return item 表示将item传递给下一个即将被执行的管道类\n手动请求发送:callback回调函数是专门用作于数据解析\n基于Spider的全站数据爬取 就是将网站中某板块下的全部页码对应的页面数据进行爬取\r需求\r实现方式：\r将所有页面的url添加到start_urls列表（不建议）\r自动手动进行请求发送（推荐）\r手动请求发送:\ryield scrapy.Request(url,callback):callback专门用做于数据解析\r五大核心组件 引擎（Scrapy）\r用来处理整个系统的数据流处理，触发事务（框架核心）\r调度器（Scheduler）\r用来接受引擎发过来的请求，压入队列中，并在引擎再次请求的时候返回，可以想象为一个URL（抓取网页的网址或者说是链接）的优先队列，由他来决定下一个要抓取的网址是什么，同时去除重复的网址\r下载器（Downloader） 用于下载网页的内容，并将网页内容返回给蜘蛛(Scrapy下载器是建立在twisted这个高效的异步模型上的)\r爬虫（Spiders）\r爬虫是主要干活的，用于从特定的网页中提取自己需要的信息，即所谓的实体（Item）。用户也可以从中提取出链接，让Scrapy继续爬取下一个页面\r项目管道（Pipeline）\r负责处理爬虫从网页中抽取的实体，主要的功能是持久化实体，验证实体的有效性，清除不需要的信息，当页面被爬虫解析后，将被发送到项目管道，并经过几个特定的次序处理数据\r请求传参 使用场景：如果爬取解析的数据不在同一张页面上（深度爬取）\r需求\r图片数据爬取之ImagesPipeline 基于scrapy爬取字符串类型的数据和爬取图片类型的区别？\r字符串：只需要基于xpath进行解析且提交管道进行持久化存储\r图片：xpath解析出图片src的属性值，单独的对图片地址发起请求获取图片二进制类型的数据\rImagesPipeline:\r只需将img的src属性值进行解析，提交到管道，管道就会对图片的src进行请求发送获取图片的二进制\r需求\r使用流程:\r数据解析(图片的地址)\r将存储图片地址的item提交到制定的管道类\r在管道文件中自定制一个基于ImagePipeLine的一个管道类\rget_media_request\rfile_path\ritem_completed\r在配置文件中：\r指定图片存储的目录：IMAGES_STORE = './imgs_bobo'\r指定开启的管道：自定制的管道类\r中间件 下载中间件\r位置：引擎和下载器之间\r作用：批量拦截到整个工程中所有的请求和响应\r拦截请求：\rUA伪装:process_request\r代理IP:process_exception:return request\r拦截响应：\r篡改响应数据，响应对象\r需求：爬取网易新闻中的新闻数据（标题和内容）\r1.通过网页新闻的首页解析出五大板块对应的详情页的url（没有动态加载）\r2.每一个板块对应的新闻标题都是动态加载出来的（动态加载）\r3.通过解析出每一条新闻详情页的url获取详情页的页面源码，解析出新闻内容\rprocess_response 该方法拦截五大板块对应的响应对象，进行篡改\n链接提取器：根据制定规则（allow=\u0026ldquo;正则\u0026rdquo;）进行指定链接的提取 规则解析器：将链接提取器提取到的链接进行指定规则（callback）的解析的操作 follow=True :可以将链接提取器继续作用到连接提取器提取到的链接所对应的页面中\nCrawlSpider类：Spider的一个子类 全站数据爬取的方式 基于Spider：手动请求 基于CrawlSpider CrawlSpider的使用： 创建一个工程 cd xxx 创建爬虫文件（CrawlSpider）： scrapy genspider -t crawl xxx www.xxxx.com 链接提取器： 作用：根据指定的规则（allow）进行指定连接的提取 规则解析器 作用：将连接提取器提取到的连接进行指定规则（callback）的解析 需求：爬取sun网址中的编号，新闻标题，新闻内容，标号 分析:爬取的数据没有在同一张页面中 1.可以使用链接提取器提取所有的页码链接 2.让链接提取器提取所有的新闻详情页的链接\n分布式爬虫 概念：我们需要搭建一个分布式的机群，让其对一组资源进行分布联合爬取。\n作用：提升爬取数据的效率\n如何实现分布式? 安装一个scrapy-redis的组件 原生的scarapy是不可以实现分布式爬虫，必须要让scrapy结合着scrapy-redis组件一起实现分布式\n为什么原生的scrapy不可以实现分布式？ 调度器不可以被分布式机群共享 管道不可以被分布式机群共享\nscrapy-redis组件作用： 可以给原生的scrapy框架提供可以被共享的管道和调度器\n实现流程\n创建一个工程\r创建一个基于CrawlSpider的爬虫文件\r修改当前的爬虫文件：\r导包：from scrapy_redis.spiders importRedisCrawlSpiden\r将start_urls和allowed domains进行注释\r添加一个新属性：redis_key ='sun’可以被共享的调度器队列的名称\r编写数据解析相关的操作\r类的父类修改成RedjsCrawISpider\r修改配置文件settings\r指定使用可以被共享的管道：\rITEM_PIPELINES = {\r'scrapy_redis.pipelines.RedisPipeline'：400\r}\r指定调度器：\r增加了一个去重容器类的配置，作用使用Redis的set集合来存储请求的指纹数据。\rDUPEFILTER_CLASS=\u0026quot;scrapy_redis.dupefilter.RFPDupeFilter\u0026quot;\r使用scrapy-redis组件自己的调度器\rSCHEDULER =\u0026quot;scrapy redis.scheduler.Scheduler\u0026quot;\r配置调度器是否要持久化，也就是当爬虫结束了，要不要清空Redis中请求队列和去\rSCHEDULER_PERSIST =True\rredis相关操作配置：\r配置redis的配置文件：\rlinux或者mac:redis.conf\rwindows:redis.windows.conf\r代开配置文件修改：\r将bind 127.0.0.1进行删除\r关闭保护模式：protected-mode yes改为no\r结合着配置文件开启redis服务\rredis-server 配置文件\r启动客户端：\rredis-cli\r执行工程：\rscrapy runspiderXxx.py\r向调度器的队列中放入一个起始的url：\r调度器的队列在redis的客户端中\rlpushxxx www.xxx.com\r爬取到的数据存储在了redis的proName：item这个数据结构中\r增量式爬虫 概念：监测网站数据更新的情况，只会爬取网站最新更新出来的数据。\r分析：\r指定一个起始url\r基于CrawlSpider获取其他页码链接\r基于Rule将其他页码链接进行请求\r从每一个页码对应的页面源码中解析出每一个电影详情页的URL\r核心：检测电影详情页的url之前有没有请求过\r将爬取过的电影详情页的url存储\r存储到redis的set数据结构\r对详情页的url发起请求，然后解析出电影的名称和简介\r进行持久化存储\r","date":"2024-03-26T13:28:01+08:00","permalink":"https://example.com/p/%E7%88%AC%E8%99%AB%E5%AD%A6%E4%B9%A0plus/","title":"爬虫学习plus"},{"content":"爬虫基础 “可见即可爬~”\n爬虫概念 如果互联网是一张大的蜘蛛网，那一台计算机上的数据便是蜘蛛网上的一个猎物，而爬虫程序就是一只小蜘蛛，沿着蜘蛛网抓取自己想要的猎物/数据\n网络爬虫也叫网络蜘蛛，特指一类自动批量下载网络资源的程序 网络爬虫是伪装成客户端与服务端进行数据交互的程序\n爬虫的应用 1.数据采集 2.搜索引擎 3.模拟操作 4.软件测试 5.网络安全\n爬虫的分类（略） 爬虫的一般开发流程： 1.最简单的单一页面数据的爬取：\nurl-\u0026gt;发送请求，获取响应-\u0026gt;提取数据-\u0026gt;保存数据\n2.多页面数据的爬取\n发送请求，获取响应——\u0026gt;提取url地址，继续请求\n爬虫开发的重难点 1.数据的获取（反爬） 2.采集的速度\nHTTP和HTTPS 大多数商业应用采用的架构： 1.c/s client server 2.b/s broser(浏览器) server 3.m/s mobile server\n以上统称为客户端与服务端\nHTTP协议（超文本传输协议） 爬取想要的数据前，一定要明确其使用的是什么协议\nHTTP是基于TCP/IP通信协议来传输数据的\nTCP/IP通信的三次握手与四次挥手 三次握手建立连接 client:嘿，服务端girl！我想和你建立连接 server：好呀，嘻嘻 client：真好，那我们开始（数据）交互吧！\n（进行数据交互ing）\n四次挥手断开连接 client：我已经和你交互（数据）完了，我们断开连接吧! server：你确定要断开连接吗？ server：那你断开连接吧 client：欧克，那我断开连接了\nHTTP请求流程： 我们日常用浏览器搜索东西，输入的是URL,浏览器会将其自动转换为HTTP协议\n一次http请求的基本流程，有客户端向服务端发起一次请求（request），而服务器在接收到以后返回给客户端一个响应（response）.所以一次完成的http请求包含请求和响应两部分\n浏览器发送http请求的过程：\n1.域名解析\r2.发起TCP的3次握手\r3.建立TCP连接后发起HTTP请求\r4.服务器响应http请求，浏览器得到html代码\r5.浏览器解析html代码，并请求html代码中的资源（js，css，图片等）\r6.浏览器对页面进行渲染呈现给用户\rtip： 在网页的右键检查network-\u0026gt;name-\u0026gt;request headers view parsed下的connection:keep-alive保持常连接，就不用频繁三次握手和四次挥手了\n浏览器获取的内容（elements的内容）包含：url地址对应的响应+js+css+picture 爬虫会获取：url地址对应的响应\nurl（浏览器搜索框里的内容） 发送http请求时，通过url对网络资源进行定位\nurl：统一资源定位符。用来标识某一处资源的地址，也叫网址\n组成：协议+域名（端口默认80）+路径+参数 http协议的端口号默认为80可以不写，http协议的端口号默认为443可以不行，（域名可以确定时哪一台电脑，而端口号是为了确定是哪台电脑的哪一个应用）\n域名通常是IP地址的映射\nhttp请求格式 客户端发送一个HTTP请求到服务器的请求消息包括一下部分：请求行,请求头，空行和请求数据 请求方法 分类：\nOPTIONS\rPUT\rDELETE\rTRACE\rCONNECT\r常用方法是GET 和 POST\nGET:负责从服务器获取数据 POST:负责向服务器提交数据\n请求头 http请求正文 请求正文通常是使用POST请求中表单数据，而对于GET请求，请求体则为空\n在爬虫中，如果构造POST，需要正确的content-type，并了解各种请求库的各个参数设置时使用的是哪种content-type，不然可能会导致post提交后无法正常响应\nHTTP响应格式 由四个部分组成，分别是： 状态行（响应行） 消息报头 空行 响应正文\nhttp协议的特点 HTTP是无连接的 HTTP是媒体独立的 HTTP是无状态的\n保持http连接状态的技术是会话和Cookies\nhttps协议，安全版的HTTP http是基于tcp/ip协议的，而https是在http协议的基础之上，再加一层SSL/TLS协议，数据在传输过程中是加密的\nhttp是明文传输的而https是密文传输，所以较安全但性能低\n会话技术 会话在服务端，就是网站的服务器，用来保存用户的会话信息；cookies在客户端，也可以理解为浏览器端\nCookie 指某些网站为了辨别用户身份，进行session跟踪而存储在用户本地终端上的数据（通常经过加密）\nCookie可以理解为一个凭证 1.实际是由服务器发给客户端的特殊信息 2.这些信息以文本文件的方式存放在客户端 3.客户端每次向服务器发送请求的时候都会带上这些特殊信息 4.服务器在接收到Cookie以后，会验证cookie的信息，以此来辨别用户的身份\n爬虫为什么要使用cookie 好处： 能够访问登陆页面\r有一定的反爬作用\r坏处： 请求太频繁有可能被识别为爬虫\r一般使用多账号解决\rSession 一个浏览器窗口从打开到关闭这个期间\n在一个客户从打开浏览器到关闭浏览器这个期间，发起的所以请求都可以被识别为同一个用户，session是基于cookie的\n以上资料来自https://blog.csdn.net/qq_44907926/article/details/118585030\n作者大大真的牛逼，写的真好\n","date":"2024-03-21T13:28:01+08:00","permalink":"https://example.com/p/%E7%88%AC%E8%99%AB/","title":"爬虫"},{"content":"git 啊能镇楼\ngit配置 $ git config --global user.name \u0026quot;runoob\u0026quot;\r$ git config --global user.email test@runoob.com\r查看配置信息 $ git config --list\rgit工作流程 克隆git资源作为工作目录 在克隆的资源上添加或修改文件 如果其他人修改，你可以更新资源 在提交前查看修改 提交修改 在修改完成后，如果发现有错误，可以撤回提交并再次修改并提交 基本概念 工作区：就是你在电脑里能看到的目录 暂存区：英文叫stage或index，一般存放在 .git 目录下的index文件，所以我们把暂存区有时也叫作索引（index） 版本库：工作区有一个隐藏目录 .git，这个不算工作区，而是Git的版本库 图中左侧为工作区，右侧为版本库。在版本库中标记为“index”的区域是暂存区（stage/index）,标记为“master”的是master分支所代表的目录树 图中我们可以看出此时“HEAD”实际是指向master分支的一个“游标”。所以图示的命令中出现HEAD的地方是可以用master来替换的 图中的object标识的区域为git的对象库，实际位于“.git/objects”目录下，里面包含了创建的各种对象及内容 当对工作区修改（或新增）的文件执行git add命令时，暂存区的目录树被更新，同时工作区修改（或新增）的文件内容被写入到对象库中的一个新的对象中，而该对象的ID被记录在暂存区的文件索引中 当执行提交（git commit）时，暂存区的目录树写到版本库（对象库）中，master分支会相应的更新。即master指向的目录树就是提交时暂存区的目录树 当执行 git reset HEAD 操作时，暂存区的目录树会被重写，被master分支指向的目录树所替换，但是工作区不受影响 当执行 git rm \u0026ndash;cached 命令时，会直接从暂存区删除文件，工作区则不做出改变。 当执行 git checkout . 或者 git checkout \u0026ndash; 命令时，会用暂存区全部或指定的文件替换工作区的文件。这个操作很危险，会清除工作区中未添加到暂存区中的改动。 当执行 git checkout HEAD . 或者 git checkout HEAD 命令时，会用 HEAD 指向的 master 分支中的全部或者部分文件替换暂存区和以及工作区中的文件。这个命令也是极具危险性的，因为不但会清除工作区中未提交的改动，也会清除暂存区中未提交的改动 git 创建仓库 git init初始化一个仓库 Git 的很多命令都需要在 Git 的仓库中运行，所以 git init 是使用 Git 的第一个命令。 在执行完成 git init 命令后，Git 仓库会生成一个 .git 目录，该目录包含了资源的所有元数据，其他的项目目录保持不变。\ngit init newrepo使用我们指定目录作为Git仓库\n初始化后，会在 newrepo 目录下会出现一个名为 .git 的目录，所有 Git 需要的数据和资源都存放在这个目录中。\n如果当前目录下有几个文件想要纳入版本控制，需要先用 git add 命令告诉 Git 开始对这些文件进行跟踪，然后提交\n1 2 3 $ git add *.c $ git add README $ git commit -m \u0026#39;初始化项目版本\u0026#39; 以上命令将目录下以 .c 结尾及 README 文件提交到仓库中。\n注： 在 Linux 系统中，commit 信息使用单引号 \u0026lsquo;，Windows 系统，commit 信息使用双引号 \u0026ldquo;。所以在 git bash 中 git commit -m \u0026lsquo;提交说明\u0026rsquo; 这样是可以的，在 Windows 命令行中就要使用双引号 git commit -m \u0026ldquo;提交说明\u0026rdquo;\ngit clone 我们使用 git clone 从现有 Git 仓库中拷贝项目\n1 git clone \u0026lt;repo\u0026gt; 如果我们需要克隆到指定的目录，可以使用以下命令格式\n1 git clone \u0026lt;repo\u0026gt; \u0026lt;directory\u0026gt; 参数说明\nrepo：git仓库 directory：本地目录 比如，要克隆 Ruby 语言的 Git 代码仓库 Grit，可以用下面的命令：\n1 $ git clone git://github.com/schacon/grit.git 执行该命令后，会在当前目录下创建一个名为grit的目录，其中包含一个 .git 的目录，用于保存下载下来的所有版本记录。\n如果要自己定义要新建的项目目录名称，可以在上面的命令末尾指定新的名字：\n1 $ git clone git://github.com/schacon/grit.git mygrit git init 初始化仓库 git add . 添加文件到暂存区 git commit 将暂存区内容添加到仓库中 创建仓库命令 git 初始化仓库 git clone 拷贝一份远程仓库，也就是下载一个项目 提交与修改 git add 添加文件到暂存区 git status 查看仓库当前的状态，显示有变更的文件 git diff 比较文件的不同，即暂存区和工作区的差异 git commit 提交暂存区到本地仓库 git reset 回退版本 git rm 将文件从暂存区和工作区删除 git mv 移动或重命名工作区文件 git checkout 分支切换 git switch 更清晰地切换分支（2.3版本引入） git restore 恢复或撤销文件的更改 提交日志 git log 查看历史提交记录 git blame 以列表形式查看指定文件的历史修改记录 远程操作 git remote 远程仓库操作 git fetch 从远程获取代码库 git pull 下载远程代码并合并 git push 上传远程代码并合并 git分支管理 创建分支命令： git branch (branchname)\n切换分支命令 git checkout (branchname)\n当你切换分支的时候，git会用该分支的最后提交的快照替换你的工作目录的内容，以多个分支不需要多个目录。\n合并分支命令 git merge\n你可以多次合并到统一分支， 也可以选择在合并之后直接删除被并入的分支。\ngit 分支管理 列出分支 git branch 没有参数时，git branch 会列出你在本地的分支\n$ git branch\r* master\r此例的意思就是，我们有一个叫做 master 的分支，并且该分支是当前分支。\n当你执行 git init 的时候，默认情况下 Git 就会为你创建 master 分支。\n如果我们要手动创建一个分支。执行 git branch (branchname) 即可\n$ git branch testing\r$ git branch\r* master\rtesting\r现在我们可以看到，有了一个新分支 testing。\n当你以此方式在上次提交更新之后创建了新分支，如果后来又有更新提交， 然后又切换到了 testing 分支，Git 将还原你的工作目录到你创建分支时候的样子。\n接下来我们将演示如何切换分支，我们用 git checkout (branch) 切换到我们要修改的分支\n$ ls\rREADME\r$ echo 'runoob.com' \u0026gt; test.txt\r$ git add .\r$ git commit -m 'add test.txt'\r[master 3e92c19] add test.txt\r1 file changed, 1 insertion(+)\rcreate mode 100644 test.txt\r$ ls\rREADME test.txt\r$ git checkout testing\rSwitched to branch 'testing'\r$ ls\rREADME\r当我们切换到 testing 分支的时候，我们添加的新文件 test.txt 被移除了。切换回 master 分支的时候，它们又重新出现了。\n$ git checkout master\rSwitched to branch 'master'\r$ ls\rREADME test.txt\r我们也可以使用 git checkout -b (branchname) 命令来创建新分支并立即切换到该分支下，从而在该分支中操作。\n$ git checkout -b newtest\rSwitched to a new branch 'newtest'\r$ git rm test.txt rm 'test.txt'\r$ ls\rREADME\r$ touch runoob.php\r$ git add .\r$ git commit -am 'removed test.txt、add runoob.php'\r[newtest c1501a2] removed test.txt、add runoob.php\r2 files changed, 1 deletion(-)\rcreate mode 100644 runoob.php\rdelete mode 100644 test.txt\r$ ls\rREADME runoob.php\r$ git checkout master\rSwitched to branch 'master'\r$ ls\rREADME test.txt\r如你所见，我们创建了一个分支，在该分支上移除了一些文件 test.txt，并添加了 runoob.php 文件，然后切换回我们的主分支，删除的 test.txt 文件又回来了，且新增加的 runoob.php 不存在主分支中。\n使用分支将工作切分开来，从而让我们能够在不同开发环境中做事，并来回切换\n删除分支 git branch -d (branchname)\n例如我们要删除 testing 分支： $ git branch * master testing $ git branch -d testing Deleted branch testing (was 85fc7e7). $ git branch * master\n分支合并 一旦某分支有了独立内容，你终究会希望将它合并回到你的主分支。 你可以使用以下命令将任何分支合并到当前分支中去\ngit merge\n$ git branch\r* master\rnewtest\r$ ls\rREADME test.txt\r$ git merge newtest\rUpdating 3e92c19..c1501a2\rFast-forward\rrunoob.php | 0\rtest.txt | 1 -\r2 files changed, 1 deletion(-)\rcreate mode 100644 runoob.php\rdelete mode 100644 test.txt\r$ ls\rREADME runoob.php\r以上实例中我们将 newtest 分支合并到主分支去，test.txt 文件被删除。\n合并完后就可以删除分支\n$ git branch -d newtest\rDeleted branch newtest (was c1501a2).\r删除后， 就只剩下 master 分支了：\n$ git branch\r* master\r合并冲突 合并并不仅仅是简单的文件添加、移除的操作，Git 也会合并修改\n$ git branch\r* master\r$ cat runoob.php\r首先，我们创建一个叫做 change_site 的分支，切换过去，我们将 runoob.php 内容改为\n\u0026lt;?php\recho 'runoob';\r?\u0026gt;\r创建 change_site 分支：\n$ git checkout -b change_site\rSwitched to a new branch 'change_site'\r$ vim runoob.php\r$ head -3 runoob.php\r\u0026lt;?php\recho 'runoob';\r?\u0026gt;\r$ git commit -am 'changed the runoob.php'\r[change_site 7774248] changed the runoob.php\r1 file changed, 3 insertions(+)\r将修改的内容提交到 change_site 分支中。 现在，假如切换回 master 分支我们可以看内容恢复到我们修改前的(空文件，没有代码)，我们再次修改 runoob.php 文件。\n$ git checkout master\rSwitched to branch 'master'\r$ cat runoob.php\r$ vim runoob.php # 修改内容如下\r$ cat runoob.php\r\u0026lt;?php\recho 1;\r?\u0026gt;\r$ git diff\rdiff --git a/runoob.php b/runoob.php\rindex e69de29..ac60739 100644\r--- a/runoob.php\r+++ b/runoob.php\r@@ -0,0 +1,3 @@\r+\u0026lt;?php\r+echo 1;\r+?\u0026gt;\r$ git commit -am '修改代码'\r[master c68142b] 修改代码\r1 file changed, 3 insertions(+)\r现在这些改变已经记录到我的 \u0026ldquo;master\u0026rdquo; 分支了。接下来我们将 \u0026ldquo;change_site\u0026rdquo; 分支合并过来\n$ git merge change_site\rAuto-merging runoob.php\rCONFLICT (content): Merge conflict in runoob.php\rAutomatic merge failed; fix conflicts and then commit the result.\r$ cat runoob.php # 打开文件，看到冲突内容\r\u0026lt;?php\r\u0026lt;\u0026lt;\u0026lt;\u0026lt;\u0026lt;\u0026lt;\u0026lt; HEAD\recho 1;\r=======\recho 'runoob';\r\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt; change_site\r?\u0026gt;\r我们将前一个分支合并到 master 分支，一个合并冲突就出现了，接下来我们需要手动去修改它\n$ vim runoob.php $ cat runoob.php\r\u0026lt;?php\recho 1;\recho 'runoob';\r?\u0026gt;\r$ git diff\rdiff --cc runoob.php\rindex ac60739,b63d7d7..0000000\r--- a/runoob.php\r+++ b/runoob.php\r@@@ -1,3 -1,3 +1,4 @@@\r\u0026lt;?php\r+echo 1;\r+ echo 'runoob';\r?\u0026gt;\r在 Git 中，我们可以用 git add 要告诉 Git 文件冲突已经解决 $ git status -s UU runoob.php $ git add runoob.php $ git status -s M runoob.php $ git commit [master 88afe0e] Merge branch \u0026lsquo;change_site\u0026rsquo;\ngit查看提交历史 我们还可以用 \u0026ndash;graph 选项，查看历史中什么时候出现了分支、合并。以下为相同的命令，开启了拓扑图选项\nd5e9fc2 (HEAD -\u0026gt; master) Merge branch \u0026lsquo;change_site\u0026rsquo; |\\\n| * 7774248 (change_site) changed the runoob.php | c68142b 修改代码 |/ c1501a2 removed test.txt、add runoob.php 3e92c19 add test.txt 3b58100 第一次版本提交 现在我们可以更清楚明了地看到何时工作分叉、又何时归并。\n你也可以用 \u0026ndash;reverse 参数来逆向显示所有日志。\n$ git log --reverse --oneline\r3b58100 第一次版本提交\r3e92c19 add test.txt\rc1501a2 removed test.txt、add runoob.php\r7774248 (change_site) changed the runoob.php\rc68142b 修改代码\rd5e9fc2 (HEAD -\u0026gt; master) Merge branch 'change_site'\r如果只想查找指定用户的提交日志可以使用命令：git log \u0026ndash;author , 例如，比方说我们要找 Git 源码中 Linus 提交的部分\n$ git log --author=Linus --oneline -5\r81b50f3 Move 'builtin-*' into a 'builtin/' subdirectory\r3bb7256 make \u0026quot;index-pack\u0026quot; a built-in\r377d027 make \u0026quot;git pack-redundant\u0026quot; a built-in\rb532581 make \u0026quot;git unpack-file\u0026quot; a built-in\r112dd51 make \u0026quot;mktag\u0026quot; a built-in\r如果你要指定日期，可以执行几个选项：\u0026ndash;since 和 \u0026ndash;before，但是你也可以用 \u0026ndash;until 和 \u0026ndash;after。\n例如，如果我要看 Git 项目中三周前且在四月十八日之后的所有提交，我可以执行这个（我还用了 \u0026ndash;no-merges 选项以隐藏合并提交）\n$ git log --oneline --before={3.weeks.ago} --after={2010-04-18} --no-merges\r5469e2d Git 1.7.1-rc2\rd43427d Documentation/remote-helpers: Fix typos and improve language\r272a36b Fixup: Second argument may be any arbitrary string\rb6c8d2d Documentation/remote-helpers: Add invocation section\r5ce4f4e Documentation/urls: Rewrite to accomodate transport::address\r00b84e9 Documentation/remote-helpers: Rewrite description\r03aa87e Documentation: Describe other situations where -z affects git diff\r77bc694 rebase-interactive: silence warning when no commits rewritten\r636db2c t3301: add tests to use --format=\u0026quot;%N\u0026quot;\r更多 git log 命令可查看 http://git-scm.com/docs/git-log 或使用 git log \u0026ndash;help 命令查看帮助信息。\ngit blame git blame 命令用于逐行显示指定文件的每一行代码是由谁在什么时候引入或修改的。\nstrong\u0026gt;git blame 可以追踪文件中每一行的变更历史，包括作者、提交哈希、提交日期和提交消息等信息。\n如果要查看指定文件的修改记录可以使用 git blame 命令，格式如下\ngit blame [选项] \u0026lt;文件路径\u0026gt;\ngit标签 如果你达到一个重要的阶段，并希望永远记住那个特别的提交快照，你可以使用 git tag 给它打上标签。\n比如说，我们想为我们的 runoob 项目发布一个\u0026quot;1.0\u0026quot;版本。 我们可以用 git tag -a v1.0 命令给最新一次提交打上（HEAD）\u0026ldquo;v1.0\u0026quot;的标签。\n-a 选项意为\u0026quot;创建一个带注解的标签\u0026rdquo;。 不用 -a 选项也可以执行的，但它不会记录这标签是啥时候打的，谁打的，也不会让你添加个标签的注解。 我推荐一直创建带注解的标签。\n$ git tag -a v1.0\n当你执行 git tag -a 命令时，Git 会打开你的编辑器，让你写一句标签注解，就像你给提交写注解一样。\n现在，注意当我们执行 git log \u0026ndash;decorate 时，我们可以看到我们的标签了\nd5e9fc2 (HEAD -\u0026gt; master) Merge branch \u0026lsquo;change_site\u0026rsquo; |\\\n| * 7774248 (change_site) changed the runoob.php | c68142b 修改代码 |/ c1501a2 removed test.txt、add runoob.php 3e92c19 add test.txt 3b58100 第一次版本提交 如果我们忘了给某个提交打标签，又将它发布了，我们可以给它追加标签。\n例如，假设我们发布了提交 85fc7e7(上面实例最后一行)，但是那时候忘了给它打标签。 我们现在也可以\n$ git tag -a v0.9 85fc7e7\r$ git log --oneline --decorate --graph\r* d5e9fc2 (HEAD -\u0026gt; master) Merge branch 'change_site'\r|\\ | * 7774248 (change_site) changed the runoob.php\r* | c68142b 修改代码\r|/ * c1501a2 removed test.txt、add runoob.php\r* 3e92c19 add test.txt\r* 3b58100 (tag: v0.9) 第一次版本提交\r如果我们要查看所有标签可以使用以下命令\n$ git tag\rv0.9\rv1.0\r指定标签信息命令： git tag -a -m \u0026ldquo;runoob.com标签\u0026rdquo;\nPGP签名标签命令 git tag -s -m \u0026ldquo;runoob.com标签\u0026rdquo;\ngit远程仓库（github） 添加远程库 要添加一个新的远程仓库，可以指定一个简单的名字，以便将来引用,命令格式如下\ngit remote add [shortname] [url]\n本例以 Github 为例作为远程仓库，如果你没有 Github 可以在官网 https://github.com/注册。\n由于你的本地 Git 仓库和 GitHub 仓库之间的传输是通过SSH加密的，所以我们需要配置验证信息：\n使用以下命令生成 SSH Key：\n后面的 your_email@youremail.com 改为你在 Github 上注册的邮箱，之后会要求确认路径和输入密码，我们这使用默认的一路回车就行。\n成功的话会在 ~/ 下生成 .ssh 文件夹，进去，打开 id_rsa.pub，复制里面的 key。\n$ ssh-keygen -t rsa -C \u0026quot;429240967@qq.com\u0026quot;\rGenerating public/private rsa key pair.\rEnter file in which to save the key (/Users/tianqixin/.ssh/id_rsa): Enter passphrase (empty for no passphrase): # 直接回车\rEnter same passphrase again: # 直接回车\rYour identification has been saved in /Users/tianqixin/.ssh/id_rsa.\rYour public key has been saved in /Users/tianqixin/.ssh/id_rsa.pub.\rThe key fingerprint is:\rSHA256:MDKVidPTDXIQoJwoqUmI4LBAsg5XByBlrOEzkxrwARI 429240967@qq.com\rThe key's randomart image is:\r+---[RSA 3072]----+\r|E*+.+=**oo |\r|%Oo+oo=o. . |\r|%**.o.o. |\r|OO. o o |\r|+o+ S |\r|. |\r| |\r| |\r| |\r+----[SHA256]-----+\r回到 github 上，进入 Account =\u0026gt; Settings（账户配置）\n左边选择 SSH and GPG keys，然后点击 New SSH key 按钮,title 设置标题，可以随便填，粘贴在你电脑上生成的 key。\n为了验证是否成功，输入以下命令：\n$ ssh -T git@github.com\rThe authenticity of host 'github.com (52.74.223.119)' can't be established.\rRSA key fingerprint is SHA256:nThbg6kXUpJWGl7E1IGOCspRomTxdCARLviKw6E5SY8.\rAre you sure you want to continue connecting (yes/no/[fingerprint])? yes # 输入 yes\rWarning: Permanently added 'github.com,52.74.223.119' (RSA) to the list of known hosts.\rHi tianqixin! You've successfully authenticated, but GitHub does not provide shell access. # 成功信息\r以下命令说明我们已成功连上 Github。\n之后登录后点击\u0026rdquo; New repository \u0026quot;\n之后在在Repository name 填入 runoob-git-test(远程仓库名) ，其他保持默认设置，点击\u0026quot;Create repository\u0026quot;按钮，就成功地创建了一个新的Git仓库\n查看当前的远程库 git remote\n$ git remote\rorigin\r$ git remote -v\rorigin git@github.com:tianqixin/runoob-git-test.git (fetch)\rorigin git@github.com:tianqixin/runoob-git-test.git (push)\r提取远程仓库 Git 有两个命令用来提取远程仓库的更新。\n1、从远程仓库下载新分支与数据\ngit fetch\n该命令执行完后需要执行 git merge 远程分支到你所在的分支。\n2、从远端仓库提取数据并尝试合并到当前分支：\ngit merge\n该命令就是在执行 git fetch 之后紧接着执行 git merge 远程分支到你所在的任意分支\n推送到远程仓库 推送你的新分支与数据到某个远端仓库命令:\ngit push [alias] [branch]\n以上命令将你的 [branch] 分支推送成为 [alias] 远程仓库上的 [branch] 分支，实例如下。\n$ touch runoob-test.txt # 添加文件 $ git add runoob-test.txt $ git commit -m \u0026ldquo;添加到远程\u0026rdquo; master 69e702d] 添加到远程 1 file changed, 0 insertions(+), 0 deletions(-) create mode 100644 runoob-test.txt\n$ git push origin master # 推送到 Github\n删除远程仓库 git remote rm [别名]\ngit服务其搭建（暂时不搞） 以上文档资料来自菜鸟教程，本人只是学习并总结借鉴\n最后,德狗镇楼 ","date":"2024-03-19T13:35:01+08:00","permalink":"https://example.com/p/git/","title":"git"},{"content":"这是我在学习蛇书时的学习笔记，写这篇博客一是为了自己以后复盘，二是顺便分享一下，本人写这篇文章时才大二，写的不是很好，但是我就是不改，嘿嘿~~ 白金镇楼 Python和markdown使用方法 markdown基础使用方法 标题前面加井号\n回车不能换行，只是将文字加个空格，想要换行需要在上一行后面加两个空格再回车\n想要在新起一段，则打两个回车\nctrl+i ：斜体 ctrl+b ：加粗\n列表:\n鸡翅 1.汉堡 2.可乐\n插入图片： ctrl+alt+v\n数学公式：以“\\”起始 行内展示数学公式：ctrl+m 另起一段展示数学公式，上面连按两下\n表格：第一行是表头以“|”分列，第二行是对齐方式，“-”表示默认即左对齐，在“—”左侧加“：”为左对齐，两边加为居中对齐,冒号一定要用英文 alt+shift+f可格式话文本编排\n链接：复制链接直接cv 直接黏贴则直接生成可点击的链接 选中文字黏贴则生成可点击的文字按钮链接，选中文字黏贴则生成可点击的文字按钮链接\n代码块:\n1 2 int a a = 100 指定语言可高亮\n1 2 int a a = 100 分割线 在所需添加分割线的文本下新起一行输入三个减号“\u0026mdash;” 阿巴阿巴阿巴阿巴\n引用 在引用的2文字前加上大于号“\u0026gt;”\n聪明的愚者\n流程图（略）\nmd文件导出为其他文件\n##Python编程：从入门到实践\n###字符串 name.title() name.upper() name.lower()\nf字符串\n1 2 3 4 first_name = \u0026#34;ada\u0026#34; last_name = \u0026#34;lovelace\u0026#34; fulll_name = f\u0026#34;{first_name} {last_name}\u0026#34; message = f\u0026#34;Hello,{full_name.title()}!\u0026#34; 删除空白 ❶ \u0026raquo;\u0026gt; favorite_language = \u0026rsquo; python \u0026rsquo; ❷ \u0026raquo;\u0026gt; favorite_language.rstrip() \u0026rsquo; python\u0026rsquo; ❸ \u0026raquo;\u0026gt; favorite_language.lstrip() \u0026lsquo;python \u0026rsquo; ❹ \u0026raquo;\u0026gt; favorite_language.strip() \u0026lsquo;python\u0026rsquo;\n删除前缀\nnostarch_url = \u0026lsquo;https://nostarch.com\u0026rsquo; nostarch_url.removeprefix(\u0026lsquo;https://\u0026rsquo;) \u0026rsquo;nostarch.com\u0026rsquo;\n常量 常量（constant）是在程序的整个⽣命周期内都保持不变的变量。Python 没 有内置的常量类型，但 Python 程序员会使⽤全⼤写字⺟来指出应将某个变 量视为常量，其值应始终不变\n列表 append追加 insert插入 del pop()弹栈，可加索引 remove()根据值删除元素 sort()对列表永久排序 car.sort(reverse=True) sorted()临时排序 reverse() len()\n使用range()创建数值列表 numbers = list(range(1,6))\n列表推导式 squares = [value**2 for value in range(1,11)]\n切片 players[0:3]\n复制列表 players[:]\n元组 列表⾮常适合⽤于存储在程序运⾏期间可能变化的数据集。列表是可以修 改的，这对于处理⽹站的⽤户列表或游戏中的⾓⾊列表⾄关重要。然⽽， 你有时候需要创建⼀系列不可修改的元素，元组可满⾜这种需求。Python 将不能修改的值称为不可变的，⽽不可变的列表称为元组（tuple）。\n1 2 3 4 5 6 7 requested_toppings = [] if requested_toppings: for requested_topping in requested_toppings: print(f\u0026#34;Adding {requested_topping}.\u0026#34;) print(\u0026#34;\\nFinished making your pizza!\u0026#34;) else: print(\u0026#34;Are you sure you want a plain pizza?\u0026#34;) 使用多个列表\n1 2 3 4 5 6 7 8 available_toppings = [\u0026#39;mushrooms\u0026#39;, \u0026#39;olives\u0026#39;, \u0026#39;green peppers\u0026#39;,\u0026#39;pepperoni\u0026#39;, \u0026#39;pineapple\u0026#39;, \u0026#39;extra cheese\u0026#39;] requested_toppings = [\u0026#39;mushrooms\u0026#39;, \u0026#39;french fries\u0026#39;, \u0026#39;extra cheese\u0026#39;] for requested_topping in requested_toppings: if requested_topping in available_toppings: print(f\u0026#34;Adding {requested_topping}.\u0026#34;) else: print(f\u0026#34;Sorry, we don\u0026#39;t have {requested_topping}.\u0026#34;) print(\u0026#34;\\nFinished making your pizza!\u0026#34;) 一个简单的字典\n1 2 3 4 5 6 7 8 alien_0 = {\u0026#39;color\u0026#39;：\u0026#39;green\u0026#39;,\u0026#39;point\u0026#39;:5} print(alien_0[\u0026#39;color\u0026#39;]) print(alien_0[\u0026#39;points\u0026#39;]) #添加键值对 alien_0[\u0026#39;x_position\u0026#39;] = 0 alien_0[\u0026#39;y_position\u0026#39;] = 25 #删除键值对 del 由类似的对象组成的字典\n1 2 3 4 5 6 favorite_languages = { \u0026#39;jen\u0026#39;: \u0026#39;python\u0026#39;, \u0026#39;sarah\u0026#39;: \u0026#39;c\u0026#39;, \u0026#39;edward\u0026#39;: \u0026#39;rust\u0026#39;, \u0026#39;phil\u0026#39;: \u0026#39;python\u0026#39;, } 可使⽤ get() ⽅法在指定的键不存在时返回⼀个默认值。get() ⽅ 法的第⼀个参数⽤于指定键，是必不可少的；第⼆个参数为当指定的键不 存在时要返回的值，是可选的：\n遍历字典的所有键值对\n1 2 3 4 5 6 7 8 9 user_0 = { \u0026#39;username\u0026#39;: \u0026#39;efermi\u0026#39;, \u0026#39;first\u0026#39;: \u0026#39;enrico\u0026#39;, \u0026#39;last\u0026#39;: \u0026#39;fermi\u0026#39;, } for key,value in user_0.items(): print(f\u0026#34;\\nKey:{key}) print(f\u0026#34;value:{value}\u0026#34;) 遍历字典中的所有键 keys()\n1 2 3 4 5 6 7 8 favorite_languages = { \u0026#39;jen\u0026#39;: \u0026#39;python\u0026#39;, \u0026#39;sarah\u0026#39;: \u0026#39;c\u0026#39;, \u0026#39;edward\u0026#39;: \u0026#39;rust\u0026#39;, \u0026#39;phil\u0026#39;: \u0026#39;python\u0026#39;, } for name in favorite_languages.keys(): print(name.title()) 遍历字典时，默认遍历所有的键\n遍历字典中的所有值，values()\n1 for language in set(favorite_languages.values()): 用set剔除重复项\n嵌套\n1 2 3 4 5 6 alien_0 = {\u0026#39;color\u0026#39;: \u0026#39;green\u0026#39;, \u0026#39;points\u0026#39;: 5} alien_1 = {\u0026#39;color\u0026#39;: \u0026#39;yellow\u0026#39;, \u0026#39;points\u0026#39;: 10} alien_2 = {\u0026#39;color\u0026#39;: \u0026#39;red\u0026#39;, \u0026#39;points\u0026#39;: 15} aliens = [alien_0, alien_1, alien_2] for alien in aliens: print(alien) 字典列表\n1 2 3 4 5 6 7 8 9 10 11 12 # 创建⼀个⽤于存储外星⼈的空列表 aliens = [] # 创建 30 个绿⾊的外星⼈ for alien_number in range(30): new_alien = {\u0026#39;color\u0026#39;: \u0026#39;green\u0026#39;, \u0026#39;points\u0026#39;: 5, \u0026#39;speed\u0026#39;: \u0026#39;slow\u0026#39;} aliens.append(new_alien) # 显⽰前 5 个外星⼈ for alien in aliens[:5]: print(alien) print(\u0026#34;...\u0026#34;) # 显⽰创建了多少个外星⼈ print(f\u0026#34;Total number of aliens: {len(aliens)}\u0026#34;) 在字典中存储列表\n1 2 3 4 5 6 7 8 9 # 存储顾客所点⽐萨的信息 pizza = { \u0026#39;crust\u0026#39;: \u0026#39;thick\u0026#39;, \u0026#39;toppings\u0026#39;: [\u0026#39;mushrooms\u0026#39;, \u0026#39;extra cheese\u0026#39;], } # 概述顾客点的⽐萨 print(f\u0026#34;You ordered a {pizza[\u0026#39;crust\u0026#39;]}-crust pizza \u0026#34; \u0026#34;with the following toppings:\u0026#34;) for topping in pizza[\u0026#39;toppings\u0026#39;]: print(f\u0026#34;\\t{topping}\u0026#34;) 在字典中存储字典\ninput()解读为字符串 int()获取数值输入\nfor 循环是⼀种遍历列表的有效⽅式，但不应该在 for 循环中修改列表， 否则将导致 Python 难以跟踪其中的元素。要在遍历列表的同时修改它，可 使⽤ while 循环。通过将 while 循环与列表和字典结合起来使⽤，可收 集、存储并组织⼤量的输⼊，供以后查看和使⽤。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 # ⾸先，创建⼀个待验证⽤户列表 # 和⼀个⽤于存储已验证⽤户的空列表 unconfirmed_users = [\u0026#39;alice\u0026#39;, \u0026#39;brian\u0026#39;, \u0026#39;candace\u0026#39;] confirmed_users = [] # 验证每个⽤户，直到没有未验证⽤户为⽌ # 将每个经过验证的⽤户都移到已验证⽤户列表中 while unconfirmed_users: current_user = unconfirmed_users.pop() print(f\u0026#34;Verifying user: {current_user.title()}\u0026#34;) confirmed_users.append(current_user) # 显⽰所有的已验证⽤户 print(\u0026#34;\\nThe following users have been confirmed:\u0026#34;) for confirmed_user in confirmed_users: print(confirmed_user.title()) 删除为特定值的所有列表元素\n1 2 3 4 5 pets = [\u0026#39;dog\u0026#39;, \u0026#39;cat\u0026#39;, \u0026#39;dog\u0026#39;, \u0026#39;goldfish\u0026#39;, \u0026#39;cat\u0026#39;, \u0026#39;rabbit\u0026#39;, \u0026#39;cat\u0026#39;] print(pets) while \u0026#39;cat\u0026#39; in pets: pets.remove(\u0026#39;cat\u0026#39;) print(pets) 使用用户输入填充字典\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 responses = {} # 设置⼀个标志，指出调查是否继续 polling_active = True while polling_active: # 提⽰输⼊被调查者的名字和回答 name = input(\u0026#34;\\nWhat is your name? \u0026#34;) response = input(\u0026#34;Which mountain would you like to climb someday?\u0026#34;) # 将回答存储在字典中 responses[name] = response # 看看是否还有⼈要参与调查 repeat = input(\u0026#34;Would you like to let another person respond?(yes/no) \u0026#34;) if repeat == \u0026#39;no\u0026#39;: polling_active = False # 调查结束，显⽰结果 print(\u0026#34;\\n--- Poll Results ---\u0026#34;) for name, response in responses.items(): print(f\u0026#34;{name} would like to climb {response}.\u0026#34;) 函数 \u0026ldquo;\u0026ldquo;\u0026ldquo;文档字符串\u0026rdquo;\u0026rdquo;\u0026rdquo; 位置实参\n关键字实参\n1 2 3 4 5 6 def describe_pet(animal_type, pet_name): \u0026#34;\u0026#34;\u0026#34;显⽰宠物的信息\u0026#34;\u0026#34;\u0026#34; print(f\u0026#34;\\nI have a {animal_type}.\u0026#34;) print(f\u0026#34;My {animal_type}\u0026#39;s name is {pet_name.title()}.\u0026#34;) describe_pet(animal_type=\u0026#39;hamster\u0026#39;, pet_name=\u0026#39;harry\u0026#39;) 默认值\n让实参变成可选的 为让中间名变成可选的，可给形参 middle_name 指 定默认值（空字符串），在⽤户不提供中间名时不使⽤这个形参。为了让 get_formatted_name() 在没有提供中间名时依然正确运⾏，可给形参 middle_name 指定默认值（空字符串），并将其移到形参列表的末尾 middle_name=\u0026rsquo;\u0026rsquo;\n返回字典\n传递列表\n1 2 3 4 5 6 7 8 def greet_users(names): \u0026#34;\u0026#34;\u0026#34;向列表中的每个⽤户发出简单的问候\u0026#34;\u0026#34;\u0026#34; for name in names: msg = f\u0026#34;Hello, {name.title()}!\u0026#34; print(msg) usernames = [\u0026#39;hannah\u0026#39;, \u0026#39;ty\u0026#39;, \u0026#39;margot\u0026#39;] greet_users(usernames) 传递任意数量的实参\n1 2 3 4 5 6 def make_pizza(*toppings): \u0026#34;\u0026#34;\u0026#34;打印顾客点的所有配料\u0026#34;\u0026#34;\u0026#34; print(toppings) make_pizza(\u0026#39;pepperoni\u0026#39;) make_pizza(\u0026#39;mushrooms\u0026#39;, \u0026#39;green peppers\u0026#39;, \u0026#39;extra cheese\u0026#39;) 形参名 *toppings 中的星号让 Python 创建⼀个名为 toppings 的元组， 该元组包含函数收到的所有值。函数体内的函数调⽤ print() ⽣成的输出 证明，Python 既能处理使⽤⼀个值调⽤函数的情形，也能处理使⽤三个值 调⽤函数的情形。它以类似的⽅式处理不同的调⽤。注意，Python 会将实 参封装到⼀个元组中，即便函数只收到⼀个值也是如此\n使⽤任意数量的关键字实参\n1 2 3 4 5 6 7 def build_profile(first, last, **user_info): \u0026#34;\u0026#34;\u0026#34;创建⼀个字典，其中包含我们知道的有关⽤户的⼀切\u0026#34;\u0026#34;\u0026#34; user_info[\u0026#39;first_name\u0026#39;] = first user_info[\u0026#39;last_name\u0026#39;] = last return user_info user_profile = build_profile(\u0026#39;albert\u0026#39;, \u0026#39;einstein\u0026#39;,location=\u0026#39;princeton\u0026#39;,field=\u0026#39;physics\u0026#39;) print(user_profile) build_profile() 函数的定义要求提供名和姓，同时允许根据需要提供 任意数量的名值对。形参 **user_info 中的两个星号让 Python 创建⼀个 名为 user_info 的字典，该字典包含函数收到的其他所有名值对。在这 个函数中，可以像访问其他字典那样访问 user_info 中的名值对。\n将函数存储在模块中 使⽤函数的优点之⼀是可将代码块与主程序分离。通过给函数指定描述性 名称，能让程序容易理解得多。你还可以更进⼀步，将函数存储在称为模 块的独⽴⽂件中，再将模块导⼊（import）主程序。import 语句可让你在 当前运⾏的程序⽂件中使⽤模块中的代码。\n导⼊特定的函数\n使⽤ as 给函数指定别名\n函数编写指南 在编写函数时，需要牢记⼏个细节。应给函数指定描述性名称，且只使⽤ ⼩写字⺟和下划线。描述性名称可帮助你和别⼈明⽩代码想要做什么。在 给模块命名时也应遵循上述约定。 在给形参指定默认值时，等号两边不要有空格\n面向对象编程：类\n创建Dog类\n1 2 3 4 5 6 7 8 9 10 11 12 class Dog: \u0026#34;\u0026#34;\u0026#34;⼀次模拟⼩狗的简单尝试\u0026#34;\u0026#34;\u0026#34; def __init__(self, name, age): \u0026#34;\u0026#34;\u0026#34;初始化属性 name 和 age\u0026#34;\u0026#34;\u0026#34; self.name = name self.age = age def sit(self): \u0026#34;\u0026#34;\u0026#34;模拟⼩狗收到命令时坐下\u0026#34;\u0026#34;\u0026#34; print(f\u0026#34;{self.name} is now sitting.\u0026#34;) def roll_over(self): \u0026#34;\u0026#34;\u0026#34;模拟⼩狗收到命令时打滚\u0026#34;\u0026#34;\u0026#34; print(f\u0026#34;{self.name} rolled over!\u0026#34;) init() ⽅法:是⼀个特殊⽅法，每当你根据 Dog 类创建新实例时，Python 都会⾃动运⾏ 它。在这个⽅法的名称中，开头和末尾各有两个下划线，这是⼀种约定， 旨在避免 Python 默认⽅法与普通⽅法发⽣名称冲突。务必确保 init() 的两边都有两个下划线，否则当你使⽤类来创建实例时，将 不会⾃动调⽤这个⽅法，进⽽引发难以发现的错误。 我们将 init() ⽅法定义成包含三个形参：self、name 和 age。在 这个⽅法的定义中，形参 self 必不可少，⽽且必须位于其他形参的前 ⾯。为何必须在⽅法定义中包含形参 self 呢？因为当 Python 调⽤这个⽅ 法来创建 Dog 实例时，将⾃动传⼊实参 self。每个与实例相关联的⽅法 调⽤都会⾃动传递实参 self，该实参是⼀个指向实例本⾝的引⽤，让实例 能够访问类中的属性和⽅法。 在 init() ⽅法内定义的两个变量都有前缀 self（⻅❸）。以self 为前缀的变量可供类中的所有⽅法使⽤，可以通过类的任意实例来访问。 self.name = name 获取与形参 name 相关联的值，并将其赋给变量 name，然后该变量被关联到当前创建的实例。self.age = age 的作⽤ 与此类似。像这样可通过实例访问的变量称为属性（attribute）。\n根据类创建实例\n1 2 3 my_dog = Dog(\u0026#39;Willie\u0026#39;, 6) print(f\u0026#34;My dog\u0026#39;s name is {my_dog.name}.\u0026#34;) print(f\u0026#34;My dog is {my_dog.age} years old.\u0026#34;) 给属性指定默认值 有些属性⽆须通过形参来定义，可以在 init() ⽅法中为其指定默认 值。 下⾯来添加⼀个名为 odometer_reading 的属性，其初始值总是为 0。我 们还添加了⼀个名为 read_odometer() 的⽅法，⽤于读取汽⻋的⾥程 表\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 class Car: def __init__(self, make, model, year): \u0026#34;\u0026#34;\u0026#34;初始化描述汽⻋的属性\u0026#34;\u0026#34;\u0026#34; self.make = make self.model = model self.year = year self.odometer_reading = 0 def get_descriptive_name(self): --snip-- ❷ def read_odometer(self): \u0026#34;\u0026#34;\u0026#34;打印⼀条指出汽⻋⾏驶⾥程的消息\u0026#34;\u0026#34;\u0026#34; print(f\u0026#34;This car has {self.odometer_reading} miles on it.\u0026#34;) my_new_car = Car(\u0026#39;audi\u0026#39;, \u0026#39;a4\u0026#39;, 2024) print(my_new_car.get_descriptive_name()) my_new_car.read_odometer() 修改属性的值\n1.直接修改属性的值 2.通过方法修改属性的值 3.通过方法让属性的值递增\n继承 当⼀个类继承另⼀个类时，将⾃动获 得后者的所有属性和⽅法。原有的类称为⽗类（parent class），⽽新类称为 ⼦类（child class）。⼦类不仅继承了⽗类的所有属性和⽅法，还可定义⾃ ⼰的属性和⽅法\n子类的_init_()方法 在既有的类的基础上编写新类，通常要调⽤⽗类的 init() ⽅法。这 将初始化在⽗类的 init() ⽅法中定义的所有属性，从⽽让⼦类也可 以使⽤这些属性。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 class Car: \u0026#34;\u0026#34;\u0026#34;⼀次模拟汽⻋的简单尝试\u0026#34;\u0026#34;\u0026#34; def __init__(self, make, model, year): \u0026#34;\u0026#34;\u0026#34;初始化描述汽⻋的属性\u0026#34;\u0026#34;\u0026#34; self.make = make self.model = model self.year = year self.odometer_reading = 0 def get_descriptive_name(self): \u0026#34;\u0026#34;\u0026#34;返回格式规范的描述性名称\u0026#34;\u0026#34;\u0026#34; long_name = f\u0026#34;{self.year} {self.make} {self.model}\u0026#34; return long_name.title() def read_odometer(self): \u0026#34;\u0026#34;\u0026#34;打印⼀个句⼦，指出汽⻋的⾏驶⾥程\u0026#34;\u0026#34;\u0026#34; print(f\u0026#34;This car has {self.odometer_reading} miles on it.\u0026#34;) def update_odometer(self, mileage): \u0026#34;\u0026#34;\u0026#34;将⾥程表读数设置为给定的值\u0026#34;\u0026#34;\u0026#34; if mileage \u0026gt;= self.odometer_reading: self.odometer_reading = mileage else: print(\u0026#34;You can\u0026#39;t roll back an odometer!\u0026#34;) def increment_odometer(self, miles): \u0026#34;\u0026#34;\u0026#34;让⾥程表读数增加给定的量\u0026#34;\u0026#34;\u0026#34; self.odometer_reading += miles class ElectricCar(Car): \u0026#34;\u0026#34;\u0026#34;电动汽⻋的独特之处\u0026#34;\u0026#34;\u0026#34; def __init__(self, make, model, year): \u0026#34;\u0026#34;\u0026#34;初始化⽗类的属性\u0026#34;\u0026#34;\u0026#34; super().__init__(make, model, year) my_leaf = ElectricCar(\u0026#39;nissan\u0026#39;, \u0026#39;leaf\u0026#39;, 2024) print(my_leaf.get_descriptive_name()) ⾸先是 Car 类的代码（⻅❶）。在创建⼦类时，⽗类必须包含在当前⽂件 中，且位于⼦类前⾯。接下来，定义⼦类 ElectricCar（⻅❷）。在定义 ⼦类时，必须在括号内指定⽗类的名称。init() ⽅法接受创建 Car 实例所需的信息（⻅❸）。 super() 是⼀个特殊的函数，让你能够调⽤⽗类的⽅法（⻅❹）。这⾏代 码让 Python 调⽤ Car 类的 init() ⽅法，从⽽让 ElectricCar 实 例包含这个⽅法定义的所有属性。⽗类也称为超类（superclass），函数名 super 由此得名。 为了测试继承能够正确地发挥作⽤，我们尝试创建⼀辆电动汽⻋，但提供 的信息与创建燃油汽⻋时相同。在❺处，创建 ElectricCar 类的⼀个实 例，并将其赋给变量 my_leaf。这⾏代码调⽤ ElectricCar 类中定义的 init() ⽅法，后者让 Python 调⽤⽗类 Car 中定义的 init() ⽅法。我们提供了实参 \u0026rsquo;nissan\u0026rsquo;、\u0026rsquo;leaf\u0026rsquo; 和 2024\n给子类定义属性和方法 让⼀个类继承另⼀个类后，就可以添加区分⼦类和⽗类所需的新属性和新 ⽅法了。 下⾯添加⼀个电动汽⻋特有的属性（电池），以及⼀个描述该属性的⽅ 法。我们将存储电池容量，并编写⼀个⽅法打印对电池的描述\n重写父类中的方法\n将实例用作属性 在使⽤代码模拟实物时，你可能会发现⾃⼰给类添加了太多细节：属性和 ⽅法越来越多，⽂件越来越⻓。在这种情况下，可能需要将类的⼀部分提 取出来，作为⼀个独⽴的类。将⼤型类拆分成多个协同⼯作的⼩类，这种 ⽅法称为组合（composition）。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 class Car: --snip-- class Battery: \u0026#34;\u0026#34;\u0026#34;⼀次模拟电动汽⻋电池的简单尝试\u0026#34;\u0026#34;\u0026#34; def __init__(self, battery_size=40): \u0026#34;\u0026#34;\u0026#34;初始化电池的属性\u0026#34;\u0026#34;\u0026#34; self.battery_size = battery_size def describe_battery(self): \u0026#34;\u0026#34;\u0026#34;打印⼀条描述电池容量的消息\u0026#34;\u0026#34;\u0026#34; print(f\u0026#34;This car has a {self.battery_size}-kWh battery.\u0026#34;) class ElectricCar(Car): \u0026#34;\u0026#34;\u0026#34;电动汽⻋的独特之处\u0026#34;\u0026#34;\u0026#34; def __init__(self, make, model, year): \u0026#34;\u0026#34;\u0026#34; 先初始化⽗类的属性，再初始化电动汽⻋特有的属性 \u0026#34;\u0026#34;\u0026#34; super().__init__(make, model, year) self.battery = Battery() my_leaf = ElectricCar(\u0026#39;nissan\u0026#39;, \u0026#39;leaf\u0026#39;, 2024) print(my_leaf.get_descriptive_name()) my_leaf.battery.describe_battery() 模拟实物 这让你进⼊了程序员的另⼀个境界：在解决上述问题时，从较⾼的逻辑层 ⾯（⽽不是语法层⾯）思考。你考虑的不是 Python，⽽是如何使⽤代码来 表⽰实际事物。达到这种境界后，你会经常发现，对现实世界的建模⽅法 没有对错之分。有些⽅法的效率更⾼，但要找出效率最⾼的表⽰法，需要 ⼀定的实践。只要代码能够像你希望的那样运⾏，就说明你已经做得很好 了！即便发现⾃⼰不得不多次尝试使⽤不同的⽅法来重写类，也不必⽓ 馁。要编写出⾼效、准确的代码，这是必经之路\n导入类 模块级⽂档字符串，对该模块的内容做了简要的描述。你应该 为⾃⼰创建的每个模块编写⽂档字符串。\n导⼊类是⼀种⾼效的编程⽅式。如果这个程序包含整个 Class 类，它该有 多⻓啊！通过将这个类移到⼀个模块中并导⼊该模块，依然可使⽤其所有 功能，但主程序⽂件变得整洁易读了。这还让你能够将⼤部分逻辑存储在 独⽴的⽂件中。在确定类能像你希望的那样⼯作后，就可以不管这些⽂ 件，专注于主程序的⾼级逻辑了\n在一个模块中存储多个类\n从一个模块中导入多个类\n导入整个模块 先导⼊整个模块，再使⽤点号访问需要的类\n导入模块中的所有类\n使用别名\n找到合适的工作流程 ⼀开始应让代码结构尽量简单。⾸先尝试在⼀个⽂件中完成所有的⼯作， 确定⼀切都能正确运⾏后，再将类移到独⽴的模块中。如果你喜欢模块和 ⽂件的交互⽅式，可在项⽬开始时就尝试将类存储到模块中。先找出让你 能够编写出可⾏代码的⽅式，再尝试让代码更加整洁\npython标准库 randint()它将两个整数作为参数， 并随机返回⼀个位于这两个整数之间（含）的整数。下⾯演⽰了如何⽣成 ⼀个位于 1 和 6 之间的随机整数\n1 2 3 from random import randint randint(1, 6) 3 choice()它将⼀个列表或 元组作为参数，并随机返回其中的⼀个元素：\n1 2 3 4 5 from random import choice players = [\u0026#39;charles\u0026#39;, \u0026#39;martina\u0026#39;, \u0026#39;michael\u0026#39;, \u0026#39;florence\u0026#39;, \u0026#39;eli\u0026#39;] first_up = choice(players) first_up \u0026#39;florence 在创建与安全相关的应⽤程序时，不要使⽤模块 random，但它能⽤来创建 众多有趣的项⽬。\n类的编程风格 类名应采⽤驼峰命名法，即将类名中的每个单词的⾸字⺟都⼤写，并且不 使⽤下划线。实例名和模块名都采⽤全⼩写格式，并在单词之间加上下划 线。\n可以使⽤空⾏来组织代码，但不宜过多。在类中，可以使⽤⼀个空⾏来分 隔⽅法；⽽在模块中，可以使⽤两个空⾏来分隔类。 当需要同时导⼊标准库中的模块和你编写的模块时，先编写导⼊标准库模 块的 import 语句，再添加⼀个空⾏，然后编写导⼊你⾃⼰编写的模块的 import 语句。在包含多条 import 语句的程序中，这种做法让⼈更容易 明⽩程序使⽤的各个模块来⾃哪⾥。\n文件和异常\n要使⽤⽂件的内容，需要将其路径告知 Python。路径（path）指的是⽂件或 ⽂件夹在系统中的准确位置。Python 提供了 pathlib 模块，让你能够更轻 松地在各种操作系统中处理⽂件和⽬录。提供特定功能的模块通常称为库 （library）。这就是这个模块被命名为 pathlib 的原因所在 这⾥⾸先从 pathlib 模块导⼊ Path 类。Path 对象指向⼀个⽂件，可⽤ 来做很多事情。例如，让你在使⽤⽂件前核实它是否存在，读取⽂件的内 容，以及将新数据写⼊⽂件。这⾥创建了⼀个表⽰⽂件 pi_digits.txt 的 Path 对象，并将其赋给了变量 path（⻅❶）。由于这个⽂件与当前编写 的 .py ⽂件位于同⼀个⽬录中，因此 Path 只需要知道其⽂件名就能访问 它。\n1 2 3 4 5 from pathlib import Path path = Path(\u0026#39;pi_digits.txt\u0026#39;) contents = path.read_text() print(contents) read_text() 将该⽂件的全部内容作为⼀个字符串返回,read_text() 在到达⽂件末尾时会返回⼀个空字符串，⽽这个空字符串会被显⽰为⼀个空⾏。\n方法链式调用 这⾏代码先让 Python 对当前处理的⽂件调⽤ read_text() ⽅法，再对 read_text() 返回的字符串调⽤ rstrip() ⽅法，然后将整理好的字符 串赋给变量 contents。\n1 contents = path.read_text().rstrip() 相对文件路径和绝对文件路径\n访问文件中的各行 使⽤ splitlines() ⽅法将冗⻓的字符串转换为⼀系列⾏，再使⽤ for 循环以每次⼀⾏的⽅式检查⽂件中的各⾏：\n1 2 3 4 5 6 7 from pathlib import Path path = Path(\u0026#39;pi_digits.txt\u0026#39;) contents = path.read_text() lines = contents.splitlines() for line in lines: print(line) splitlines() ⽅法返回⼀个列 表，其中包含⽂件中所有的⾏，⽽我们将这个列表赋给了变量 lines\n使用文件的内容 注意：在读取⽂本⽂件时，Python 将其中的所有⽂本都解释为字符 串。如果读取的是数，并且要将其作为数值使⽤，就必须使⽤ int() 函数将其转换为整数，或者使⽤ float() 函数将其转换为浮点数。\n写入文件\n写入一行 定义⼀个⽂件的路径后，就可使⽤ write_text() 将数据写⼊该⽂件了\n注意：Python 只能将字符串写⼊⽂本⽂件。如果要将数值数据存储到 ⽂本⽂件中，必须先使⽤函数 str() 将其转换为字符串格式。\n写入多行 write_text() ⽅法会在幕后完成⼏项⼯作。⾸先，如果 path 变量对应 的路径指向的⽂件不存在，就创建它。其次，将字符串写⼊⽂件后，它会 确保⽂件得以妥善地关闭。如果没有妥善地关闭⽂件，可能会导致数据丢 失或受损。\n1 2 3 4 5 6 7 from pathlib import Path contents = \u0026#34;I love programming.\\n\u0026#34; contents += \u0026#34;I love creating new games.\\n\u0026#34; contents += \u0026#34;I also love working with data.\\n\u0026#34; path = Path(\u0026#39;programming.txt\u0026#39;) path.write_text(contents) 注意：在对 path 对象调⽤ write_text() ⽅法时，务必谨慎。如果 指定的⽂件已存在， write_text() 将删除其内容，并将指定的内容 写⼊其中。\n异常 Python 使⽤称为异常（exception）的特殊对象来管理程序执⾏期间发⽣的 错误。每当发⽣让 Python 不知所措的错误时，它都会创建⼀个异常对象。 如果你编写了处理该异常的代码，程序将继续运⾏；如果你未对异常进⾏ 处理，程序将停⽌，并显⽰⼀个 traceback，其中包含有关异常的报告。\n使用try-except代码块\n1 2 3 4 try: print(5/0) except ZeroDivisionError: print(\u0026#34;You can\u0026#39;t divide by zero!\u0026#34;) else代码块 这个⽰例还包含⼀个 else 代码块，只有 try 代码块成功执⾏才需要继续执⾏的代码，都应放到 else 代码块中\n1 2 3 4 5 6 7 8 9 10 11 --snip-- while True: --snip-- if second_number == \u0026#39;q\u0026#39;: break try: answer = int(first_number) / int(second_number) except ZeroDivisionError: print(\u0026#34;You can\u0026#39;t divide by 0!\u0026#34;) else: print(answer) 依赖 try 代码块成功执⾏的代码都被放在else 代码块中\n只有可能引发异常的代码才需要放在 try 语句中。有时候，有⼀些仅在 try 代码块成功执⾏时才需要运⾏的代码，这些代码应放在 else 代码块 中。except 代码块告诉 Python，如果在尝试运⾏ try 代码块中的代码时 引发了指定的异常该怎么办\n分析文本 使⽤ split() ⽅法，它默认以空⽩为分隔符将字符串分拆成多个部分\n1 2 3 4 5 6 7 8 9 10 11 from pathlib import Path path = Path(\u0026#39;alice.txt\u0026#39;) try: contents = path.read_text(encoding=\u0026#39;utf-8\u0026#39;) except FileNotFoundError: print(f\u0026#34;Sorry, the file {path} does not exist.\u0026#34;) else: #计算⽂件⼤致包含多少个单词 words = contents.split() num_words = len(words) print(f\u0026#34;The file {path} has about {num_words} words.\u0026#34;) 使用多个文件\n1 2 3 4 5 6 7 8 from pathlib import Path def count_words(filename): --snip-- filenames = [\u0026#39;alice.txt\u0026#39;, \u0026#39;siddhartha.txt\u0026#39;, \u0026#39;moby_dick.txt\u0026#39;, \u0026#39;little_women.txt\u0026#39;] for filename in filenames: path = Path(filename) count_words(path) 静默失败 但并⾮每次捕获异常都需要告诉⽤户，你有时候希望程序在发⽣异常时保持静默，就像什么都 没有发⽣⼀样继续运⾏。\n1 2 3 4 5 6 7 8 def count_words(path): \u0026#34;\u0026#34;\u0026#34;计算⼀个⽂件⼤致包含多少个单词\u0026#34;\u0026#34;\u0026#34; try: --snip-- except FileNotFoundError: pass else: --snip-- 存储数据 json.dumps() 函数接受⼀个实参，即要转换为 JSON 格式的数据。这个函数返回⼀个字符串\n1 2 3 4 5 6 7 from pathlib import Path import json numbers = [2,3,5,7,11,13] path = Path(\u0026#39;numbers.json\u0026#39;) contents = json.dumps(numbers) path.write_text(contents) 使⽤ json.loads() 将这个列表读取到内存中\n1 2 3 4 5 6 7 8 from pathlib import Path import json path = Path(\u0026#39;numbers.json\u0026#39;) contents = path.read_text() numbers = json.loads(contents) print(numbers) Path 类提供了很多很有⽤的⽅法。如果指定的⽂件或⽂件夹存在， exists() ⽅法返回 True，否则返回 False。这⾥使⽤ path.exists() 来确定是否存储了⽤户名（⻅❶）。如果⽂件 username.json 存在，就加载其中的⽤户名，并向⽤户发出个性化问候。\n测试代码 学习如何使⽤ pytest 来测试代码。pytest 库是⼀组⼯ 具，不仅能帮助你快速⽽轻松地编写测试，⽽且能持续⽀持随项⽬增⼤⽽ 变得复杂的测试。Python 默认不包含 pytest，因此你将学习如何安装外 部库\n测试函数 所幸 pytest 提供了⼀种⾃动测试函数输出的⾼效⽅式\n单元测试和测试用例 断言\n1 2 3 4 5 6 from name_function import get_formatted_name def test_first_last_name(): \u0026#34;\u0026#34;\u0026#34;能够正确地处理像 Janis Joplin 这样的姓名吗？\u0026#34;\u0026#34;\u0026#34; formatted_name = get_formatted_name(\u0026#39;janis\u0026#39;, \u0026#39;joplin\u0026#39;) assert formatted_name == \u0026#39;Janis Joplin\u0026#39; 测试⽂件的名称很重要，必须以test_打头。当你让 pytest 运⾏测试时，它将查找以 test_打头的⽂件，并运⾏其中的所有测试\n运行测试 如果直接运⾏⽂件 test_name_function.py，将不会有任何输出，因为我们没 有调⽤这个测试函数。相反，应该让 pytest 替我们运⾏这个测试⽂件。 为此，打开⼀个终端窗⼝，并切换到这个测试⽂件所在的⽂件夹。如果你 使⽤的是 VS Code，可打开测试⽂件所在的⽂件夹，并使⽤该编辑器内嵌 的终端。在终端窗⼝中执⾏命令 pytest\n通过\n$ pytest\r========================= test session starts\r=========================\r❶ platform darwin -- Python 3.x.x, pytest-7.x.x, pluggy-1.x.x\r❷ rootdir: /.../python_work/chapter_11\r❸ collected 1 item\r❹ test_name_function.py . [100%]\r========================== 1 passed in 0.00s\r==========================\r不通过\n$ pytest\r========================= test session starts\r=========================\r--snip--\r❶ test_name_function.py F [100%]\r❷ ============================== FAILURES\r===============================\r❸ ________________________ test_first_last_name\r_________________________\rdef test_first_last_name():\r\u0026quot;\u0026quot;\u0026quot;能够正确地处理像 Janis Joplin 这样的姓名吗?\u0026quot;\u0026quot;\u0026quot;\r❹ \u0026gt; formatted_name = get_formatted_name('janis', 'joplin')\r❺ E TypeError: get_formatted_name() missing 1 required positional\rargument: 'last'\rtest_name_function.py:5: TypeError\r======================= short test summary info\r=======================\rFAILED test_name_function.py::test_first_last_name - TypeError:\rget_formatted_name() missing 1 required positional argument:\r'last'\r========================== 1 failed in 0.04s\r==========================\r测试类 断言 使用夹具 在测试中，夹具（fixture）可帮助我们搭建测试环境。这通常意味着创建供 多个测试使⽤的资源。在 pytest 中，要创建夹具，可编写⼀个使⽤装饰 器 @pytest.fixture 装饰的函数。装饰器（decorator）是放在函数定义 前⾯的指令。在运⾏函数前，Python 将该指令应⽤于函数，以修改函数代 码的⾏为。这听起来很复杂，但是不⽤担⼼：即便没有学习如何编写装饰 器，也可使⽤第三⽅包中的装饰器\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 import pytest from survey import AnonymousSurvey @pytest.fixture def language_survey(): \u0026#34;\u0026#34;\u0026#34;⼀个可供所有测试函数使⽤的 AnonymousSurvey 实例\u0026#34;\u0026#34;\u0026#34; question = \u0026#34;What language did you first learn to speak?\u0026#34; language_survey = AnonymousSurvey(question) return language_survey def test_store_single_response(language_survey): \u0026#34;\u0026#34;\u0026#34;测试单个答案会被妥善地存储\u0026#34;\u0026#34;\u0026#34; language_survey.store_response(\u0026#39;English\u0026#39;) assert \u0026#39;English\u0026#39; in language_survey.responses def test_store_three_responses(language_survey): \u0026#34;\u0026#34;\u0026#34;测试三个答案会被妥善地存储\u0026#34;\u0026#34;\u0026#34; responses = [\u0026#39;English\u0026#39;, \u0026#39;Spanish\u0026#39;, \u0026#39;Mandarin\u0026#39;] for response in responses: language_survey.store_response(response) for response in responses: assert response in language_survey.responses 现在需要导⼊ pytest，因为我们使⽤了其中定义的⼀个装饰器。我们将装 饰器 @pytest.fixture（⻅❶）应⽤于新函数language_survey() （⻅❷）。这个函数创建并返回⼀个AnonymousSurvey 对象 请注意，两个测试函数的定义都变了（⻅❸和❺）：都有⼀个名为 language_survey 的形参。当测试函数的⼀个形参与应⽤了装饰器 @pytest.fixture 的函数（夹具）同名时，将⾃动运⾏夹具，并将夹具 返回的值传递给测试函数。在这个⽰例中，language_survey() 函数向 test_store_single_response() 和test_store_three_responses() 提供了⼀个 language_survey 实例。\n##使用Git进行版本控制\n安装Git\n配置Git\n创建项目 我们来创建⼀个要进⾏版本控制的项⽬。在系统中创建⼀个⽂件夹，并将 其命名为 git_practice。\n忽略文件 扩展名为 .pyc 的⽂件是根据 .py ⽂件⾃动⽣成的，因此⽆须让 Git 跟踪它 们。这些⽂件存储在⽬录 pycache 中。为了让 Git 忽略这个⽬录，创建 ⼀个名为 .gitignore 的特殊⽂件（这个⽂件名以句点打头，且没有扩展 名），并在其中添加如下⼀⾏内容 这会让 Git 忽略⽬录 pycache 中的所有⽂件。使⽤⽂件 .gitignore 可避 免混乱，让项⽬开发起来更容易。 你可能需要修改⽂件浏览器的设置，使其显⽰隐藏的⽂件（名称以句点打 头的⽂件）：在 Windows 资源管理器中，选择菜单“查看”中的复选框“隐藏 的项⽬”；在 macOS 系统中，按组合键 Command + Shift + .（句点）；在 Linux 系统中，查找并选择设置 Show Hidden Files（显⽰隐藏的⽂件）\n初始化仓库 前⾯创建了⼀个⽬录，其中包含⼀个 Python ⽂件和⼀个 .gitignore ⽂件，现 在可以初始化⼀个 Git 仓库了。为此，打开⼀个终端窗⼝，切换到⽂件夹 git_practice，并执⾏如下命令：\ngit_practice$ git init\rInitialized empty Git repository in git_practice/.git/\rgit_practice$\r输出表明 Git 在 git_practice 中初始化了⼀个空仓库。仓库（repository）是 程序中被 Git 主动跟踪的⼀组⽂件。Git ⽤来管理仓库的⽂件都存储在隐藏 的⽬录 .git 中。虽然你根本不需要与这个⽬录打交道，但千万不要删除它， 否则将丢失项⽬的所有历史记录。\n检查状态\ngit_practice$ git status\r❶ On branch main\rNo commits yet\r❷ Untracked files:\r(use \u0026quot;git add \u0026lt;file\u0026gt;...\u0026quot; to include in what will be committed)\r.gitignore\rhello_git.py\r❸ nothing added to commit but untracked files present (use \u0026quot;git add\u0026quot; to\rtrack)\rgit_practice$\r在 Git 中，分⽀（branch）是项⽬的⼀个版本。从这⾥的输出可知，我们位 于分⽀ main 上（⻅❶）。每当查看项⽬的状态时，输出都将指出位于分⽀ main 上。接下来的输出表明，还未执⾏任何提交。提交（commit）是项⽬ 在特定时间点的快照 Git 指出了项⽬中未被跟踪的⽂件（⻅❷），因为还没有告诉它要跟踪哪些 ⽂件。接下来，Git 告诉我们没有将任何东⻄添加到当前的提交中，并且指 出了可能需要加⼊仓库的未跟踪⽂件（⻅❸）\n将文件加入仓库\n❶ git_practice$ git add .\r❷ git_practice$ git status\rOn branch main\rNo commits yet\rChanges to be committed:\r(use \u0026quot;git rm --cached \u0026lt;file\u0026gt;...\u0026quot; to unstage)\r❸ new file: .gitignore\rnew file: hello_git.py\rgit_practice$\r命令 git add . 将项⽬中未被跟踪的所有⽂件（条件是没有在 .gitignore 中列出）都加⼊仓库（⻅❶）。它不提交这些⽂件，只是让 Git 关注它们。 现在检查项⽬的状态，会发现 Git 找出了⼀些需要提交的修改（⻅❷）。 new file 意味着这些⽂件是新添加到仓库中的（⻅❸）。\n执行提交\n❶ git_practice$ git commit -m \u0026quot;Started project.\u0026quot;\r❷ [main (root-commit) cea13dd] Started project.\r❸ 2 files changed, 5 insertions(+)\rcreate mode 100644 .gitignore\rcreate mode 100644 hello_git.py\r❹ git_practice$ git status\rOn branch main\rnothing to commit, working tree clean\rgit_practice$\r我们执⾏命令 git commit -m \u0026ldquo;message\u0026rdquo;（⻅❶）创建项⽬的快照。 标志 -m 让 Git 将接下来的消息（Started project.）记录到项⽬的历 史记录中。输出表明我们位于分⽀ main 上（⻅❷）且有两个⽂件被修改了 （⻅❸）。 现在检查状态，将发现我们位于分⽀ main 上且⼯作树是⼲净的（⻅❹）。 这是在每次提交项⽬的可⾏状态时都应该看到的消息。如果显⽰的消息不 是这样的，请仔细阅读，很可能是你在提交前忘记了添加⽂件\n查看提交历史 git log\n每次提交时，Git 都会⽣成⼀个独⼀⽆⼆的引⽤ ID，⻓度为 40 个字符。它 记录提交是谁执⾏的，提交的时间，以及提交时指定的消息。并⾮在任何 情况下都需要所有这些信息，因此 Git 提供了⼀个选项，让你能够打印提交 历史条⽬的简单版本\ngit log \u0026ndash;pretty=oneline 标志 \u0026ndash;pretty=oneline 指定显⽰两项最重要的信息：提交的引⽤ ID， 以及为提交记录的消息\n放弃修改 下⾯来看看如何放弃所做的修改，恢复到上⼀个可⾏状态 Git 注意到我们修改了 hello_git.py（⻅❶）。如果愿意，可以提交所做的修 改，但这次我们不提交所做的修改，⽽是恢复到最后⼀个提交（我们知 道，那次提交时项⽬能够正常地运⾏）。为此，我们不对 hello_git.py 执⾏ 任何操作（既不删除刚添加的代码⾏，也不使⽤⽂本编辑器的撤销功 能），⽽是在终端会话中执⾏如下命令 git_practice$ git restore git_practice$ git status\n在这个简单的项⽬中，恢复到之前某个状态的能⼒看似微不⾜道，但如果 开发的是⼤型项⽬，其中数⼗个⽂件都被修改了，那么通过恢复到上⼀个 状态，将撤销最后⼀次提交后对这些⽂件所做的所有修改。这个功能很有 ⽤：在实现新功能时，可根据需要做任意数量的修改；如果这些修改不可 ⾏，可撤销它们，⽽不会影响项⽬。你⽆须记住做了哪些修改并⼿动撤销 所做的修改，Git 会替你完成所有这些⼯作\n检出以前的提交 要检出提交历史中的任何提交，可使⽤命令 checkout，并指定该提交的 引⽤ ID 的前 6 个字符。检出并检查以前的提交后，既可以返回最后⼀次提 交，也可以放弃最近所做的⼯作并选择以前的提交 检出以前的提交后，将离开分⽀ main，并进⼊ Git 所说的分离头指针 （detached HEAD）状态（⻅❶）。HEAD 表⽰当前提交的项⽬状态。之所 以说处于分离状态（detached），是因为离开了⼀个具名分⽀（这⾥是 main）。 要回到分⽀ main，可按建议（⻅❷）所说的那样撤销上⼀个操作 这样就回到分⽀ main 了。除⾮要使⽤ Git 的⾼级功能，否则在检出以前的 提交后，最好不要对项⽬做任何修改。然⽽，如果参与项⽬开发的⼈只有 你⾃⼰，⽽你⼜想放弃最近的所有提交并恢复到以前的状态，也可将项⽬ 重置到以前的提交。\n删除仓库 有时候，仓库的历史记录被弄乱了，⽽你⼜不知道如何恢复。在这种情况 下，⾸先应考虑使⽤附录 C 介绍的⽅法寻求帮助。如果⽆法恢复且参与项 ⽬开发的只有你⼀个⼈，可继续使⽤这些⽂件，但将项⽬的历史记录删除 ——删除⽬录 .git。这不会影响任何⽂件的当前状态，只会删除所有的提 交，因此将⽆法检出项⽬的其他任何状态。 为此，既可以打开⼀个⽂件浏览器并将⽬录 .git 删除，也可以通过命令⾏将 其删除。之后，需要重新创建⼀个仓库，以便重新对修改进⾏跟踪。\n##项目 外星人入侵 规划项⽬ 这个游戏由 run_game() ⽅法控制。该⽅法包含⼀个不断运⾏的 while 循环（⻅❸），⽽这个循环包含⼀个事件循环以及管理屏幕更新的代码。 事件是⽤户玩游戏时执⾏的操作，如按键或移动⿏标。为了让程序能够响 应事件，可编写⼀个事件循环，以侦听事件并根据发⽣的事件类型执⾏适 当的任务\n我们使⽤ pygame.event.get() 函数来访问 Pygame 检测到的事件。这 个函数返回⼀个列表，其中包含它在上⼀次调⽤后发⽣的所有事件。所有 键盘和⿏标事件都将导致这个 for 循环运⾏。在这个循环中，我们将编写 ⼀系列 if 语句来检测并响应特定的事件。例如，当玩家单击游戏窗⼝的关 闭按钮时，将检测到 pygame.QUIT 事件，进⽽调⽤ sys.exit() 来退出 游戏\n处调⽤了pygame.display.flip()，命令 Pygame 让最近绘制的屏幕 可⻅。这⾥，它在每次执⾏ while 循环时都绘制⼀个空屏幕，并擦去旧屏 幕，使得只有新的空屏幕可⻅。我们在移动游戏元素时， pygame.display.flip() 将不断更新屏幕，以显⽰新位置上的元素并隐 藏原来位置上的元素，从⽽营造平滑移动的效果\n在这个⽂件末尾，创建⼀个游戏实例并调⽤ run_game()。这些代码被放 在⼀个 if 代码块中，仅当直接运⾏该⽂件时，它们才会执⾏。如果此时运 ⾏ alien_invasion.py，将看到⼀个空的 Pygame 窗⼝\n理想情况下，游戏在所有的系统中都应以相同的速度（帧率）运⾏。对于 可在多种系统中运⾏的游戏，控制帧率是个复杂的问题，好在 Pygame 提供 了⼀种相对简单的⽅式来达成这个⽬标。我们将创建⼀个时钟（clock）， 并确保它在主循环每次通过后都进⾏计时（tick）。当这个循环的通过速度 超过我们定义的帧率时，Pygame 会计算需要暂停多⻓时间，以便游戏的运 ⾏速度保持⼀致\ntick() ⽅法接受⼀个参数：游戏的帧率。这⾥使⽤的值为 60， Pygame 将 尽可能确保这个循环每秒恰好运⾏ 60 次。\n需要先加载⼀幅图像，再使⽤ Pygame blit() ⽅法绘制它。 最安全、成本最低的⽅式是使⽤ OpenGameArt 等⽹站提供的免费图形，这些素材⽆须授权许可即可使⽤和修改\n在游戏中，可以使⽤⼏乎任意类型的图像⽂件，但使⽤位图（.bmp）⽂件 最为简单，因为 Pygame 默认加载位图。虽然可配置 Pygame 以使⽤其他⽂ 件类型，但有些⽂件类型要求你在计算机上安装相应的图像库。⽹上的⼤ 多数图像是 .jpg 和 .png 格式的，不过可以使⽤ Photoshop、GIMP 和 Paint等⼯具将其转换为位图。\npygame 之所以⾼效，是因为它让你能够把所有的游戏元素当作矩形（rect 对象）来处理，即便它们的形状并⾮矩形也⼀样。⽽把游戏元素当作矩形 来处理之所以⾼效，是因为矩形是简单的⼏何形状。例如，通过将游戏元 素视为矩形，Pygame 能够更快地判断出它们是否发⽣了碰撞。这种做法的 效果通常很好，游戏玩家⼏乎注意不到我们处理的不是游戏元素的实际形 状。在这个类中，我们将把⻜船和屏幕作为矩形进⾏处理\n在处理 rect 对象时，可使⽤矩形的四个⾓及中⼼的 x 坐标和 y 坐标，通过 设置这些值来指定矩形的位置。如果要将游戏元素居中，可设置相应 rect 对象的属性 center、centerx 或 centery；要让游戏元素与屏幕边缘对 ⻬，可设置属性 top、bottom、left 或 right。除此之外，还有⼀些组 合属性，如 midbottom、midtop、midleft 和 midright。要调整游戏 元素的⽔平或垂直位置，可使⽤属性 x 和 y，它们分别是相应矩形左上⾓ 的 x 坐标和 y 坐标。这些属性让你⽆须去做游戏开发⼈员原本需要⼿动完 成的计算，因此很常⽤\n在 Pygame 中，原点(0, 0)位于屏幕的左上⾓，当⼀个点向右下 ⽅移动时，它的坐标值将增⼤。在 1200×800 的屏幕上，原点位于左上 ⾓，右下⾓的坐标为(1200, 800)。这些坐标对应的是游戏窗⼝，⽽不是 物理屏幕。\n##重构：_check_events() ⽅法和_update_screen() ⽅法 在⼤型项⽬中，经常需要在添加新代码前重构既有的代码。重构旨在简化 既有代码的结构，使其更容易扩展。本节将把越来越⻓的 run_game() ⽅ 法拆分成两个辅助⽅法。辅助⽅法（helper method）⼀般只在类中调⽤，不 会在类外调⽤。在 Python 中，辅助⽅法的名称以单下划线打头\n","date":"2024-03-17T13:35:01+08:00","permalink":"https://example.com/p/python/","title":"python"},{"content":"\n我打开圣经，上面第一句话就是就是\u0026quot;Hello World\u0026quot;\n其实，好多东西你自己用心去学，去看官方文档，效果比看网上那些猫猫狗狗的博客效果更好，我能做的就是抛块砖引个玉\n","date":"2024-03-17T13:28:01+08:00","permalink":"https://example.com/p/my-first-post/","title":"My First Post"}]