<!DOCTYPE html>
<html lang="zh-cn" dir="ltr">
    <head><meta charset='utf-8'>
<meta name='viewport' content='width=device-width, initial-scale=1'><meta name='description' content="图解HTTP 了解Web及网络基础 使用HTTP协议访问Web HTTP的诞生 网络基础TCP/IP TCP/IP协议族 协议:计算机与网络设备要相互通信，双方就必须基于相同的方法。比如，如何探测到通信目标、由哪一边先发起通信、使用哪种语言进行通信、怎样结束通信等规则都需要事先确定。不同的硬件、操作系统之 间的通信，所有的这一切都需要一种规则。而我们就把这种规则称为协议（protocol）。\nTCP/IP的分层管理 TCP/IP 协议族里重要的一点就是分层。TCP/IP 协议族按层次分别分为以下 4 层：应用层、传输层、网络层和数据链路层。\n把 TCP/IP 层次化是有好处的。比如，如果互联网只由一个协议统筹，某个地方需要改变设计时，就必须把所有部分整体替换掉。而分层之后只需把变动的层替换掉即可。把各层之间的接口部分规划好之后，每个层次内部的设计就能够自由改动了\n应用层：应用层决定了向用户提供应用服务时通信的活动，TCP/IP 协议族内预存了各类通用的应用服务。比如，FTP（FileTransfer Protocol，文件传输协议）和 DNS（Domain Name System，域名系统）服务就是其中两类。 HTTP 协议也处于该层。\n传输层：传输层对上层应用层，提供处于网络连接中的两台计算机之间的数据传输，在传输层有两个性质不同的协议：TCP（Transmission ControlProtocol，传输控制协议）和 UDP（User Data Protocol，用户数据报协议）。\n网络层（网络互连层）：网络层用来处理在网络上流动的数据包。数据包是网络传输的最小数据单位。该层规定了通过怎样的路径（所谓的传输路线）到达对方计算机，并把数据包传送给对方。与对方计算机之间通过多台计算机或网络设备进行传输时，网络层所起的作用就是在众多的选项内选择一条传输路线\n链路层（数据链路层，网络接口层）：用来处理连接网络的硬件部分。包括控制操作系统、硬件的设备驱动、NIC（Network Interface Card，网络适配器，即网卡），及光纤等物理可见部分（还包括连接器等一切传输媒介）。硬件上的范畴均在链路层的作用范围之内\nTCP/IP通信传输流 利用 TCP/IP 协议族进行网络通信时，会通过分层顺序与对方进行通信。发送端从应用层往下走，接收端则往应用层往上走。\n发送端在层与层之间传输数据时，每经过一层时必定会被打上一个该层所属的首部信息。反之，接收端在层与层传输数据时，每经过一层时会把对应的首部消去。\n这种把数据信息包装起来的做法称为封装（encapsulate）。\n与HTTP关系密切的协议：IP,TCP和DNS 负责传输的IP协议 “IP”其实是一种协议的名称\nIP 协议的作用是把各种数据包传送给对方。而要保证确实传送到对方那里，则需要满足各类条件。其中两个重要的条件是 IP 地址和 MAC地址（Media Access Control Address）。\nIP 地址指明了节点被分配到的地址，MAC 地址是指网卡所属的固定地址。IP 地址可以和 MAC 地址进行配对。IP 地址可变换，但 MAC地址基本上不会更改。\n使用 ARP 协议凭借 MAC 地址进行通信，ARP 是一种用以解析地址的协议，根据通信方的 IP 地址就可以反查出对应的 MAC 地址。">
<title>图解HTTP</title>

<link rel='canonical' href='https://example.com/p/%E5%9B%BE%E8%A7%A3http/'>

<link rel="stylesheet" href="/scss/style.min.a98711dd77f882bba6c64662ae7c3515ce1792919805694d18301cf79deae512.css"><meta property='og:title' content="图解HTTP">
<meta property='og:description' content="图解HTTP 了解Web及网络基础 使用HTTP协议访问Web HTTP的诞生 网络基础TCP/IP TCP/IP协议族 协议:计算机与网络设备要相互通信，双方就必须基于相同的方法。比如，如何探测到通信目标、由哪一边先发起通信、使用哪种语言进行通信、怎样结束通信等规则都需要事先确定。不同的硬件、操作系统之 间的通信，所有的这一切都需要一种规则。而我们就把这种规则称为协议（protocol）。\nTCP/IP的分层管理 TCP/IP 协议族里重要的一点就是分层。TCP/IP 协议族按层次分别分为以下 4 层：应用层、传输层、网络层和数据链路层。\n把 TCP/IP 层次化是有好处的。比如，如果互联网只由一个协议统筹，某个地方需要改变设计时，就必须把所有部分整体替换掉。而分层之后只需把变动的层替换掉即可。把各层之间的接口部分规划好之后，每个层次内部的设计就能够自由改动了\n应用层：应用层决定了向用户提供应用服务时通信的活动，TCP/IP 协议族内预存了各类通用的应用服务。比如，FTP（FileTransfer Protocol，文件传输协议）和 DNS（Domain Name System，域名系统）服务就是其中两类。 HTTP 协议也处于该层。\n传输层：传输层对上层应用层，提供处于网络连接中的两台计算机之间的数据传输，在传输层有两个性质不同的协议：TCP（Transmission ControlProtocol，传输控制协议）和 UDP（User Data Protocol，用户数据报协议）。\n网络层（网络互连层）：网络层用来处理在网络上流动的数据包。数据包是网络传输的最小数据单位。该层规定了通过怎样的路径（所谓的传输路线）到达对方计算机，并把数据包传送给对方。与对方计算机之间通过多台计算机或网络设备进行传输时，网络层所起的作用就是在众多的选项内选择一条传输路线\n链路层（数据链路层，网络接口层）：用来处理连接网络的硬件部分。包括控制操作系统、硬件的设备驱动、NIC（Network Interface Card，网络适配器，即网卡），及光纤等物理可见部分（还包括连接器等一切传输媒介）。硬件上的范畴均在链路层的作用范围之内\nTCP/IP通信传输流 利用 TCP/IP 协议族进行网络通信时，会通过分层顺序与对方进行通信。发送端从应用层往下走，接收端则往应用层往上走。\n发送端在层与层之间传输数据时，每经过一层时必定会被打上一个该层所属的首部信息。反之，接收端在层与层传输数据时，每经过一层时会把对应的首部消去。\n这种把数据信息包装起来的做法称为封装（encapsulate）。\n与HTTP关系密切的协议：IP,TCP和DNS 负责传输的IP协议 “IP”其实是一种协议的名称\nIP 协议的作用是把各种数据包传送给对方。而要保证确实传送到对方那里，则需要满足各类条件。其中两个重要的条件是 IP 地址和 MAC地址（Media Access Control Address）。\nIP 地址指明了节点被分配到的地址，MAC 地址是指网卡所属的固定地址。IP 地址可以和 MAC 地址进行配对。IP 地址可变换，但 MAC地址基本上不会更改。\n使用 ARP 协议凭借 MAC 地址进行通信，ARP 是一种用以解析地址的协议，根据通信方的 IP 地址就可以反查出对应的 MAC 地址。">
<meta property='og:url' content='https://example.com/p/%E5%9B%BE%E8%A7%A3http/'>
<meta property='og:site_name' content='乌鸦的个人博客'>
<meta property='og:type' content='article'><meta property='article:section' content='Post' /><meta property='article:published_time' content='2024-05-08T13:28:01&#43;08:00'/><meta property='article:modified_time' content='2024-05-14T23:00:09&#43;08:00'/>
<meta name="twitter:title" content="图解HTTP">
<meta name="twitter:description" content="图解HTTP 了解Web及网络基础 使用HTTP协议访问Web HTTP的诞生 网络基础TCP/IP TCP/IP协议族 协议:计算机与网络设备要相互通信，双方就必须基于相同的方法。比如，如何探测到通信目标、由哪一边先发起通信、使用哪种语言进行通信、怎样结束通信等规则都需要事先确定。不同的硬件、操作系统之 间的通信，所有的这一切都需要一种规则。而我们就把这种规则称为协议（protocol）。\nTCP/IP的分层管理 TCP/IP 协议族里重要的一点就是分层。TCP/IP 协议族按层次分别分为以下 4 层：应用层、传输层、网络层和数据链路层。\n把 TCP/IP 层次化是有好处的。比如，如果互联网只由一个协议统筹，某个地方需要改变设计时，就必须把所有部分整体替换掉。而分层之后只需把变动的层替换掉即可。把各层之间的接口部分规划好之后，每个层次内部的设计就能够自由改动了\n应用层：应用层决定了向用户提供应用服务时通信的活动，TCP/IP 协议族内预存了各类通用的应用服务。比如，FTP（FileTransfer Protocol，文件传输协议）和 DNS（Domain Name System，域名系统）服务就是其中两类。 HTTP 协议也处于该层。\n传输层：传输层对上层应用层，提供处于网络连接中的两台计算机之间的数据传输，在传输层有两个性质不同的协议：TCP（Transmission ControlProtocol，传输控制协议）和 UDP（User Data Protocol，用户数据报协议）。\n网络层（网络互连层）：网络层用来处理在网络上流动的数据包。数据包是网络传输的最小数据单位。该层规定了通过怎样的路径（所谓的传输路线）到达对方计算机，并把数据包传送给对方。与对方计算机之间通过多台计算机或网络设备进行传输时，网络层所起的作用就是在众多的选项内选择一条传输路线\n链路层（数据链路层，网络接口层）：用来处理连接网络的硬件部分。包括控制操作系统、硬件的设备驱动、NIC（Network Interface Card，网络适配器，即网卡），及光纤等物理可见部分（还包括连接器等一切传输媒介）。硬件上的范畴均在链路层的作用范围之内\nTCP/IP通信传输流 利用 TCP/IP 协议族进行网络通信时，会通过分层顺序与对方进行通信。发送端从应用层往下走，接收端则往应用层往上走。\n发送端在层与层之间传输数据时，每经过一层时必定会被打上一个该层所属的首部信息。反之，接收端在层与层传输数据时，每经过一层时会把对应的首部消去。\n这种把数据信息包装起来的做法称为封装（encapsulate）。\n与HTTP关系密切的协议：IP,TCP和DNS 负责传输的IP协议 “IP”其实是一种协议的名称\nIP 协议的作用是把各种数据包传送给对方。而要保证确实传送到对方那里，则需要满足各类条件。其中两个重要的条件是 IP 地址和 MAC地址（Media Access Control Address）。\nIP 地址指明了节点被分配到的地址，MAC 地址是指网卡所属的固定地址。IP 地址可以和 MAC 地址进行配对。IP 地址可变换，但 MAC地址基本上不会更改。\n使用 ARP 协议凭借 MAC 地址进行通信，ARP 是一种用以解析地址的协议，根据通信方的 IP 地址就可以反查出对应的 MAC 地址。">
    <link rel="shortcut icon" href="/NotoV1Hamburger.png" />

    </head>
    <body class="
    article-page
    ">
    <script>
        (function() {
            const colorSchemeKey = 'StackColorScheme';
            if(!localStorage.getItem(colorSchemeKey)){
                localStorage.setItem(colorSchemeKey, "auto");
            }
        })();
    </script><script>
    (function() {
        const colorSchemeKey = 'StackColorScheme';
        const colorSchemeItem = localStorage.getItem(colorSchemeKey);
        const supportDarkMode = window.matchMedia('(prefers-color-scheme: dark)').matches === true;

        if (colorSchemeItem == 'dark' || colorSchemeItem === 'auto' && supportDarkMode) {
            

            document.documentElement.dataset.scheme = 'dark';
        } else {
            document.documentElement.dataset.scheme = 'light';
        }
    })();
</script>
<div class="container main-container flex on-phone--column extended"><aside class="sidebar left-sidebar sticky ">
    <button class="hamburger hamburger--spin" type="button" id="toggle-menu" aria-label="切换菜单">
        <span class="hamburger-box">
            <span class="hamburger-inner"></span>
        </span>
    </button>

    <header>
        
            
            <figure class="site-avatar">
                <a href="/">
                
                    
                    
                    
                        
                        <img src="/img/avatar_hua7c6426d55aaa478c31955be28d7bc27_584920_300x0_resize_q75_box.jpg" width="300"
                            height="363" class="site-logo" loading="lazy" alt="Avatar">
                    
                
                </a>
                
                    <span class="emoji">🍔</span>
                
            </figure>
            
        
        
        <div class="site-meta">
            <h1 class="site-name"><a href="/">乌鸦的个人博客</a></h1>
            <h2 class="site-description">所行皆坦途,所愿皆如期</h2>
        </div>
    </header><ol class="social-menu">
            
                <li>
                    <a 
                        href='https://github.com/CaiJimmy/hugo-theme-stack'
                        target="_blank"
                        title="GitHub"
                        rel="me"
                    >
                        
                        
                            <svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-brand-github" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z" fill="none"/>
  <path d="M9 19c-4.3 1.4 -4.3 -2.5 -6 -3m12 5v-3.5c0 -1 .1 -1.4 -.5 -2c2.8 -.3 5.5 -1.4 5.5 -6a4.6 4.6 0 0 0 -1.3 -3.2a4.2 4.2 0 0 0 -.1 -3.2s-1.1 -.3 -3.5 1.3a12.3 12.3 0 0 0 -6.2 0c-2.4 -1.6 -3.5 -1.3 -3.5 -1.3a4.2 4.2 0 0 0 -.1 3.2a4.6 4.6 0 0 0 -1.3 3.2c0 4.6 2.7 5.7 5.5 6c-.6 .6 -.6 1.2 -.5 2v3.5" />
</svg>



                        
                    </a>
                </li>
            
                <li>
                    <a 
                        href='https://twitter.com'
                        target="_blank"
                        title="Twitter"
                        rel="me"
                    >
                        
                        
                            <svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-brand-twitter" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z" fill="none"/>
  <path d="M22 4.01c-1 .49 -1.98 .689 -3 .99c-1.121 -1.265 -2.783 -1.335 -4.38 -.737s-2.643 2.06 -2.62 3.737v1c-3.245 .083 -6.135 -1.395 -8 -4c0 0 -4.182 7.433 4 11c-1.872 1.247 -3.739 2.088 -6 2c3.308 1.803 6.913 2.423 10.034 1.517c3.58 -1.04 6.522 -3.723 7.651 -7.742a13.84 13.84 0 0 0 .497 -3.753c-.002 -.249 1.51 -2.772 1.818 -4.013z" />
</svg>



                        
                    </a>
                </li>
            
        </ol><ol class="menu" id="main-menu">
        
        
        
        <li >
            <a href='/' >
                
                
                
                    <svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-home" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z"/>
  <polyline points="5 12 3 12 12 3 21 12 19 12" />
  <path d="M5 12v7a2 2 0 0 0 2 2h10a2 2 0 0 0 2 -2v-7" />
  <path d="M9 21v-6a2 2 0 0 1 2 -2h2a2 2 0 0 1 2 2v6" />
</svg>



                
                <span>主页</span>
            </a>
        </li>
        
        
        <li >
            <a href='/%E5%85%B3%E4%BA%8E/' >
                
                
                
                    <svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-user" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z"/>
  <circle cx="12" cy="7" r="4" />
  <path d="M6 21v-2a4 4 0 0 1 4 -4h4a4 4 0 0 1 4 4v2" />
</svg>



                
                <span>关于</span>
            </a>
        </li>
        
        
        <li >
            <a href='/archives/' >
                
                
                
                    <svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-archive" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z"/>
  <rect x="3" y="4" width="18" height="4" rx="2" />
  <path d="M5 8v10a2 2 0 0 0 2 2h10a2 2 0 0 0 2 -2v-10" />
  <line x1="10" y1="12" x2="14" y2="12" />
</svg>



                
                <span>Archives</span>
            </a>
        </li>
        
        
        <li >
            <a href='/search/' >
                
                
                
                    <svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-search" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z"/>
  <circle cx="10" cy="10" r="7" />
  <line x1="21" y1="21" x2="15" y2="15" />
</svg>



                
                <span>Search</span>
            </a>
        </li>
        
        
        <li >
            <a href='/links/' >
                
                
                
                    <svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-link" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z"/>
  <path d="M10 14a3.5 3.5 0 0 0 5 0l4 -4a3.5 3.5 0 0 0 -5 -5l-.5 .5" />
  <path d="M14 10a3.5 3.5 0 0 0 -5 0l-4 4a3.5 3.5 0 0 0 5 5l.5 -.5" />
</svg>



                
                <span>Links</span>
            </a>
        </li>
        
        <li class="menu-bottom-section">
            <ol class="menu">

                
                    <li id="dark-mode-toggle">
                        <svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-toggle-left" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z"/>
  <circle cx="8" cy="12" r="2" />
  <rect x="2" y="6" width="20" height="12" rx="6" />
</svg>



                        <svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-toggle-right" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z"/>
  <circle cx="16" cy="12" r="2" />
  <rect x="2" y="6" width="20" height="12" rx="6" />
</svg>



                        <span>暗色模式</span>
                    </li>
                
            </ol>
        </li>
    </ol>
</aside>

    <aside class="sidebar right-sidebar sticky">
        
            
                
    <section class="widget archives">
        <div class="widget-icon">
            <svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-hash" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z"/>
  <line x1="5" y1="9" x2="19" y2="9" />
  <line x1="5" y1="15" x2="19" y2="15" />
  <line x1="11" y1="4" x2="7" y2="20" />
  <line x1="17" y1="4" x2="13" y2="20" />
</svg>



        </div>
        <h2 class="widget-title section-title">目录</h2>
        
        <div class="widget--toc">
            <nav id="TableOfContents">
  <ol>
    <li><a href="#使用http协议访问web">使用HTTP协议访问Web</a></li>
    <li><a href="#http的诞生">HTTP的诞生</a></li>
    <li><a href="#网络基础tcpip">网络基础TCP/IP</a>
      <ol>
        <li><a href="#tcpip协议族">TCP/IP协议族</a></li>
        <li><a href="#tcpip的分层管理">TCP/IP的分层管理</a></li>
        <li><a href="#tcpip通信传输流">TCP/IP通信传输流</a></li>
      </ol>
    </li>
    <li><a href="#与http关系密切的协议iptcp和dns">与HTTP关系密切的协议：IP,TCP和DNS</a>
      <ol>
        <li><a href="#负责传输的ip协议">负责传输的IP协议</a></li>
        <li><a href="#确保可靠性的tcp协议">确保可靠性的TCP协议</a></li>
        <li><a href="#负责域名解析的dns服务">负责域名解析的DNS服务</a></li>
        <li><a href="#各种协议与http协议的关系">各种协议与HTTP协议的关系</a></li>
      </ol>
    </li>
    <li><a href="#uri和url">URI和URL</a>
      <ol>
        <li><a href="#统一资源标识符uri">统一资源标识符URI</a></li>
        <li><a href="#uri格式">URI格式</a></li>
      </ol>
    </li>
  </ol>

  <ol>
    <li><a href="#http协议用于客户端和服务端之间的通信">HTTP协议用于客户端和服务端之间的通信</a></li>
    <li><a href="#通过请求和响应的交换达成通信">通过请求和响应的交换达成通信</a></li>
    <li><a href="#http是不保存状态的协议">HTTP是不保存状态的协议</a></li>
    <li><a href="#请求uri定位资源">请求URI定位资源</a></li>
    <li><a href="#告知服务器意图的http方法">告知服务器意图的HTTP方法</a></li>
    <li><a href="#使用方法下达命令">使用方法下达命令</a></li>
    <li><a href="#持久连接节省通信量">持久连接节省通信量</a>
      <ol>
        <li><a href="#持久连接">持久连接</a></li>
        <li><a href="#管线化">管线化</a></li>
      </ol>
    </li>
    <li><a href="#使用cookie的状态管理">使用Cookie的状态管理</a></li>
  </ol>

  <ol>
    <li><a href="#http报文">HTTP报文</a></li>
    <li><a href="#编码提升传输速率">编码提升传输速率</a>
      <ol>
        <li><a href="#报文主体和实体主体的差异">报文主体和实体主体的差异</a></li>
        <li><a href="#压缩传输的内容编码">压缩传输的内容编码</a></li>
        <li><a href="#分割发送的分块传输编码">分割发送的分块传输编码</a></li>
      </ol>
    </li>
    <li><a href="#发送多种数据的多部分对象集合">发送多种数据的多部分对象集合</a></li>
    <li><a href="#获取部分内容的范围请求">获取部分内容的范围请求</a></li>
    <li><a href="#内容协商返回最合适的内容">内容协商返回最合适的内容</a></li>
  </ol>

  <ol>
    <li><a href="#状态码告知从服务器端返回的请求结果">状态码告知从服务器端返回的请求结果</a></li>
    <li><a href="#2xx成功">2xx成功</a>
      <ol>
        <li><a href="#200-ok">200 ok</a></li>
        <li><a href="#204-no-content">204 no content</a></li>
        <li><a href="#206-partial-content">206 partial content</a></li>
      </ol>
    </li>
    <li><a href="#3xx重定向">3xx重定向</a>
      <ol>
        <li><a href="#301-moved-permanently">301 moved permanently</a></li>
        <li><a href="#302-found">302 found</a></li>
        <li><a href="#303-see-other">303 see other</a></li>
        <li><a href="#304-not-modified">304 not modified</a></li>
        <li><a href="#307-temporary-redirect">307 temporary redirect</a></li>
      </ol>
    </li>
    <li><a href="#4xx客户端错误">4xx客户端错误</a>
      <ol>
        <li><a href="#400-bad-request">400 bad request</a></li>
        <li><a href="#401-unauthorized">401 unauthorized</a></li>
        <li><a href="#403-forbidden">403 forbidden</a></li>
        <li><a href="#404-not-found">404 not found</a></li>
      </ol>
    </li>
    <li><a href="#5xx服务器错误">5xx服务器错误</a>
      <ol>
        <li><a href="#500-internal-server-error">500 internal server error</a></li>
        <li><a href="#503-servicre-unavailable">503 servicre unavailable</a></li>
      </ol>
    </li>
    <li><a href="#与http协作的web服务器">与HTTP协作的Web服务器</a></li>
    <li><a href="#用单台虚拟主机实现多个域名">用单台虚拟主机实现多个域名</a></li>
    <li><a href="#通信数据转发程序代理网关隧道">通信数据转发程序：代理，网关，隧道</a>
      <ol>
        <li><a href="#代理">代理</a></li>
        <li><a href="#网关">网关</a></li>
        <li><a href="#隧道">隧道</a></li>
      </ol>
    </li>
    <li><a href="#保存资源的缓存">保存资源的缓存</a>
      <ol>
        <li><a href="#缓存的有效期限">缓存的有效期限</a></li>
        <li><a href="#客户端的缓存">客户端的缓存</a></li>
      </ol>
    </li>
  </ol>

  <ol>
    <li><a href="#http报文首部">HTTP报文首部</a></li>
    <li><a href="#http首部字段">HTTP首部字段</a>
      <ol>
        <li><a href="#http首部字段传递重要信息">HTTP首部字段传递重要信息</a></li>
        <li><a href="#http首部字段结构">HTTP首部字段结构</a></li>
        <li><a href="#4种http首部字段类型">4种HTTP首部字段类型</a></li>
        <li><a href="#http11首部一览">HTTP/1.1首部一览</a></li>
        <li><a href="#非http11首部字段">非HTTP/1.1首部字段</a></li>
        <li><a href="#end-to-end首部和hop-by-hop首部">end-to-end首部和hop-by-hop首部</a></li>
      </ol>
    </li>
    <li><a href="#http11通用首部字段">HTTP/1.1通用首部字段</a>
      <ol>
        <li><a href="#cache-control">cache-control</a></li>
        <li><a href="#connection">Connection</a></li>
        <li><a href="#date">Date</a></li>
        <li><a href="#pragma">Pragma</a></li>
        <li><a href="#trailer">Trailer</a></li>
        <li><a href="#transfer-encoding">Transfer-Encoding</a></li>
        <li><a href="#upgrade">Upgrade</a></li>
        <li><a href="#via">Via</a></li>
        <li><a href="#warning">Warning</a></li>
      </ol>
    </li>
    <li><a href="#请求首部字段">请求首部字段</a>
      <ol>
        <li><a href="#accept">Accept</a></li>
        <li><a href="#accept-charset">Accept-Charset</a></li>
        <li><a href="#accept-encoding">Accept-Encoding</a></li>
        <li><a href="#accept-language">Accept-Language</a></li>
        <li><a href="#authorization">Authorization</a></li>
        <li><a href="#expect">Expect</a></li>
        <li><a href="#from">From</a></li>
        <li><a href="#host">Host</a></li>
        <li><a href="#if-match">If-Match</a></li>
        <li><a href="#if-none-match">If-None-Match</a></li>
        <li><a href="#if-range">If-Range</a></li>
        <li><a href="#if-unmodified-since">If-Unmodified-Since</a></li>
        <li><a href="#max-forwards">Max-Forwards</a></li>
        <li><a href="#proxy-authorization">Proxy-Authorization</a></li>
        <li><a href="#range">Range</a></li>
        <li><a href="#referer">Referer</a></li>
        <li><a href="#te">TE</a></li>
        <li><a href="#user-agent">User-Agent</a></li>
      </ol>
    </li>
    <li><a href="#响应首部字段">响应首部字段</a>
      <ol>
        <li><a href="#accpet-range">Accpet-Range</a></li>
        <li><a href="#age">Age</a></li>
        <li><a href="#etag">ETag</a></li>
        <li><a href="#location">Location</a></li>
        <li><a href="#proxy-authenticate">Proxy-Authenticate</a></li>
        <li><a href="#retry-after">Retry-After</a></li>
        <li><a href="#server">Server</a></li>
        <li><a href="#vary">Vary</a></li>
        <li><a href="#www-authenticate">WWW-Authenticate</a></li>
      </ol>
    </li>
    <li><a href="#实体首部字段">实体首部字段</a>
      <ol>
        <li><a href="#allow">Allow</a></li>
        <li><a href="#content-encodeing">Content-Encodeing</a></li>
        <li><a href="#content-languange">Content-Languange</a></li>
        <li><a href="#content-length">Content-Length</a></li>
        <li><a href="#content-location">Content-Location</a></li>
        <li><a href="#content-md5">Content-MD5</a></li>
        <li><a href="#content-range">Content-Range</a></li>
        <li><a href="#content-type">Content-Type</a></li>
        <li><a href="#expires">Expires</a></li>
        <li><a href="#last-modified">Last-Modified</a></li>
      </ol>
    </li>
    <li><a href="#为cookie服务的首部字段">为Cookie服务的首部字段</a>
      <ol>
        <li><a href="#set-cookie">Set-Cookie</a></li>
        <li><a href="#cookie">Cookie</a></li>
      </ol>
    </li>
    <li><a href="#其他首部字段">其他首部字段</a>
      <ol>
        <li><a href="#x-frame-options">X-Frame-Options</a></li>
        <li><a href="#dnt">DNT</a></li>
        <li><a href="#x-xss-protection">X-XSS-Protection</a></li>
        <li><a href="#p3p">P3P</a></li>
      </ol>
    </li>
  </ol>

  <ol>
    <li><a href="#http的缺点">HTTP的缺点</a>
      <ol>
        <li><a href="#通信使用明文可能会被窃听">通信使用明文可能会被窃听</a></li>
        <li><a href="#不验证通信方的身份就可能遭遇伪装">不验证通信方的身份就可能遭遇伪装</a></li>
        <li><a href="#无法证明报文完整性可能已遭篡改">无法证明报文完整性，可能已遭篡改</a></li>
      </ol>
    </li>
    <li><a href="#http加密认证完整性保护--https">HTTP+加密+认证+完整性保护 = HTTPS</a>
      <ol>
        <li><a href="#https是身披ssl外壳的http">HTTPS是身披SSL外壳的HTTP</a></li>
        <li><a href="#相互交换密钥的公开密钥加密技术">相互交换密钥的公开密钥加密技术</a></li>
        <li><a href="#证明公开密钥正确性的证书">证明公开密钥正确性的证书</a></li>
        <li><a href="#可证明组织真实性的ev-ssl证书">可证明组织真实性的EV SSL证书</a></li>
        <li><a href="#https的安全通信机制">HTTPS的安全通信机制</a></li>
      </ol>
    </li>
  </ol>

  <ol>
    <li><a href="#何为认证">何为认证</a></li>
    <li><a href="#basic认证">BASIC认证</a></li>
    <li><a href="#digest认证">DIGEST认证</a></li>
    <li><a href="#ssl客户端认证">SSL客户端认证</a>
      <ol>
        <li><a href="#ssl客户端认证采用双因素认证">SSL客户端认证采用双因素认证</a></li>
        <li><a href="#ssl客户端认证必要的费用">SSL客户端认证必要的费用</a></li>
      </ol>
    </li>
    <li><a href="#基于表单认证">基于表单认证</a>
      <ol>
        <li><a href="#认证多半为基于表单认证">认证多半为基于表单认证</a></li>
        <li><a href="#session管理及cookie应用">Session管理及Cookie应用</a></li>
      </ol>
    </li>
  </ol>

  <ol>
    <li><a href="#基于http协议">基于HTTP协议</a></li>
    <li><a href="#消除http瓶颈的spdy">消除HTTP瓶颈的SPDY</a>
      <ol>
        <li><a href="#http的瓶颈">HTTP的瓶颈</a></li>
        <li><a href="#spdy的设计与功能">SPDY的设计与功能</a></li>
      </ol>
    </li>
    <li><a href="#使用浏览器进行全双工通信的websocket">使用浏览器进行全双工通信的WebSocket</a>
      <ol>
        <li><a href="#websocket-的设计与功能">WebSocket 的设计与功能</a></li>
        <li><a href="#websocket协议">WebSocket协议</a></li>
      </ol>
    </li>
    <li><a href="#期盼已久的http20">期盼已久的HTTP/2.0</a></li>
    <li><a href="#web服务器管理文件的webdav">Web服务器管理文件的WebDAV</a>
      <ol>
        <li><a href="#扩展http11d的webdav">扩展HTTP/1.1D的WebDAV</a></li>
        <li><a href="#webdav内新增的方法及状态码">WebDAV内新增的方法及状态码</a></li>
      </ol>
    </li>
  </ol>

  <ol>
    <li><a href="#html">HTML</a>
      <ol>
        <li><a href="#web-页面几乎全由-html-构建">Web 页面几乎全由 HTML 构建</a></li>
        <li><a href="#设计应用css">设计应用CSS</a></li>
      </ol>
    </li>
    <li><a href="#动态html">动态HTML</a>
      <ol>
        <li><a href="#让-web-页面动起来的动态-html">让 Web 页面动起来的动态 HTML</a></li>
        <li><a href="#更易控制html的dom">更易控制HTML的DOM</a></li>
      </ol>
    </li>
    <li><a href="#web应用">Web应用</a>
      <ol>
        <li><a href="#通过web提供功能的web应用">通过Web提供功能的Web应用</a></li>
        <li><a href="#与服务器及程序协作的cgi">与服务器及程序协作的CGI</a></li>
        <li><a href="#因java而普及的servlet">因Java而普及的Servlet</a></li>
      </ol>
    </li>
    <li><a href="#数据发布的格式及语言">数据发布的格式及语言</a>
      <ol>
        <li><a href="#可扩展标记语言">可扩展标记语言</a></li>
        <li><a href="#发布更新信息的rssatom">发布更新信息的RSS/Atom</a></li>
        <li><a href="#javascript衍生的轻量级易用api">JavaScript衍生的轻量级易用API</a></li>
      </ol>
    </li>
  </ol>

  <ol>
    <li><a href="#针对-web-的攻击技术">针对 Web 的攻击技术</a>
      <ol>
        <li><a href="#http-不具备必要的安全功能">HTTP 不具备必要的安全功能</a></li>
        <li><a href="#在客户端即可篡改请求">在客户端即可篡改请求</a></li>
        <li><a href="#针对-web-应用的攻击模式">针对 Web 应用的攻击模式</a></li>
        <li><a href="#因输出值转义不完全引发的安全漏洞">因输出值转义不完全引发的安全漏洞</a></li>
      </ol>
    </li>
    <li><a href="#跨站脚本攻击">跨站脚本攻击</a>
      <ol>
        <li><a href="#sql-注入攻击">SQL 注入攻击</a></li>
        <li><a href="#os-命令注入攻击">OS 命令注入攻击</a></li>
        <li><a href="#http-首部注入攻击">HTTP 首部注入攻击</a></li>
        <li><a href="#邮件首部注入攻击">邮件首部注入攻击</a></li>
        <li><a href="#目录遍历攻击">目录遍历攻击</a></li>
        <li><a href="#远程文件包含漏洞">远程文件包含漏洞</a></li>
      </ol>
    </li>
    <li><a href="#因设置或设计上的缺陷引发的安全漏洞">因设置或设计上的缺陷引发的安全漏洞</a>
      <ol>
        <li><a href="#强制浏览">强制浏览</a></li>
        <li><a href="#不正确的错误消息处理">不正确的错误消息处理</a></li>
        <li><a href="#开放重定向">开放重定向</a></li>
      </ol>
    </li>
    <li><a href="#因会话管理疏忽引发的安全漏洞">因会话管理疏忽引发的安全漏洞</a>
      <ol>
        <li><a href="#会话劫持">会话劫持</a></li>
        <li><a href="#会话固定攻击">会话固定攻击</a></li>
        <li><a href="#跨站点请求伪造">跨站点请求伪造</a></li>
      </ol>
    </li>
    <li><a href="#其他安全漏洞">其他安全漏洞</a>
      <ol>
        <li><a href="#密码破解">密码破解</a></li>
        <li><a href="#点击劫持">点击劫持</a></li>
        <li><a href="#dos-攻击">DoS 攻击</a></li>
        <li><a href="#后门程序">后门程序</a></li>
      </ol>
    </li>
  </ol>
</nav>
        </div>
    </section>

            
        
    </aside>


            <main class="main full-width">
    <article class="main-article">
    <header class="article-header">

    <div class="article-details">
    

    <div class="article-title-wrapper">
        <h2 class="article-title">
            <a href="/p/%E5%9B%BE%E8%A7%A3http/">图解HTTP</a>
        </h2>
    
        
    </div>

    
    
    
    
    <footer class="article-time">
        
            <div>
                <svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-calendar-time" width="56" height="56" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z"/>
  <path d="M11.795 21h-6.795a2 2 0 0 1 -2 -2v-12a2 2 0 0 1 2 -2h12a2 2 0 0 1 2 2v4" />
  <circle cx="18" cy="18" r="4" />
  <path d="M15 3v4" />
  <path d="M7 3v4" />
  <path d="M3 11h16" />
  <path d="M18 16.496v1.504l1 1" />
</svg>
                <time class="article-time--published">May 08, 2024</time>
            </div>
        

        <div class="article-lastmod">
                <svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-clock" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z"/>
  <circle cx="12" cy="12" r="9" />
  <polyline points="12 7 12 12 15 15" />
</svg>



                <time>
                    May 14, 2024 23:00 CST
                </time>
            </div>
            <div>
                <svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-clock" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z"/>
  <circle cx="12" cy="12" r="9" />
  <polyline points="12 7 12 12 15 15" />
</svg>



                <time class="article-time--reading">
                    阅读时长: 9 分钟
                </time>
            </div>
        
    </footer>
    

    
</div>

</header>

    <section class="article-content">
    
    
    <p><img src="https://raw.githubusercontent.com/a-b-ab/picture/main/Picgo202405142259587.jpg"
	
	
	
	loading="lazy"
	
	
></p>
<h1 id="图解http">图解HTTP</h1>
<h1 id="了解web及网络基础">了解Web及网络基础</h1>
<h2 id="使用http协议访问web">使用HTTP协议访问Web</h2>
<h2 id="http的诞生">HTTP的诞生</h2>
<h2 id="网络基础tcpip">网络基础TCP/IP</h2>
<h3 id="tcpip协议族">TCP/IP协议族</h3>
<p>协议:计算机与网络设备要相互通信，双方就必须基于相同的方法。比如，如何探测到通信目标、由哪一边先发起通信、使用哪种语言进行通信、怎样结束通信等规则都需要事先确定。不同的硬件、操作系统之
间的通信，所有的这一切都需要一种规则。而我们就把这种规则称为协议（protocol）。</p>
<h3 id="tcpip的分层管理">TCP/IP的分层管理</h3>
<p>TCP/IP 协议族里重要的一点就是分层。TCP/IP 协议族按层次分别分为以下 4 层：<strong>应用层</strong>、<strong>传输层</strong>、<strong>网络层</strong>和<strong>数据链路层</strong>。</p>
<p>把 TCP/IP 层次化是有好处的。比如，如果互联网只由一个协议统筹，某个地方需要改变设计时，就必须把所有部分整体替换掉。而分层之后只需把变动的层替换掉即可。把各层之间的接口部分规划好之后，每个层次内部的设计就能够自由改动了</p>
<ul>
<li>
<p>应用层：应用层决定了向用户提供应用服务时通信的活动，TCP/IP 协议族内预存了各类通用的应用服务。比如，FTP（FileTransfer Protocol，文件传输协议）和 DNS（Domain Name System，域名系统）服务就是其中两类。 HTTP 协议也处于该层。</p>
</li>
<li>
<p>传输层：传输层对上层应用层，提供处于网络连接中的两台计算机之间的数据传输，在传输层有两个性质不同的协议：TCP（Transmission ControlProtocol，传输控制协议）和 UDP（User Data Protocol，用户数据报协议）。</p>
</li>
<li>
<p>网络层（网络互连层）：网络层用来处理在网络上流动的数据包。数据包是网络传输的最小数据单位。该层规定了通过怎样的路径（所谓的传输路线）到达对方计算机，并把数据包传送给对方。与对方计算机之间通过多台计算机或网络设备进行传输时，网络层所起的作用就是在众多的选项内选择一条传输路线</p>
</li>
<li>
<p>链路层（数据链路层，网络接口层）：用来处理连接网络的硬件部分。包括控制操作系统、硬件的设备驱动、NIC（Network Interface Card，网络适配器，即网卡），及光纤等物理可见部分（还包括连接器等一切传输媒介）。硬件上的范畴均在链路层的作用范围之内</p>
</li>
</ul>
<h3 id="tcpip通信传输流">TCP/IP通信传输流</h3>
<p>利用 TCP/IP 协议族进行网络通信时，会通过分层顺序与对方进行通信。发送端从应用层往下走，接收端则往应用层往上走。</p>
<p>发送端在层与层之间传输数据时，每经过一层时必定会被打上一个该层所属的首部信息。反之，接收端在层与层传输数据时，每经过一层时会把对应的首部消去。</p>
<p><em>这种把数据信息包装起来的做法称为封装（encapsulate）。</em></p>
<h2 id="与http关系密切的协议iptcp和dns">与HTTP关系密切的协议：IP,TCP和DNS</h2>
<h3 id="负责传输的ip协议">负责传输的IP协议</h3>
<p>“IP”其实是一种协议的名称</p>
<p>IP 协议的作用是把各种数据包传送给对方。而要保证确实传送到对方那里，则需要满足各类条件。其中两个重要的条件是 IP 地址和 MAC地址（Media Access Control Address）。</p>
<p>IP 地址指明了节点被分配到的地址，MAC 地址是指网卡所属的固定地址。IP 地址可以和 MAC 地址进行配对。IP 地址可变换，但 MAC地址基本上不会更改。</p>
<p>使用 ARP 协议凭借 MAC 地址进行通信，ARP 是一种用以解析地址的协议，根据通信方的 IP 地址就可以反查出对应的 MAC 地址。</p>
<h3 id="确保可靠性的tcp协议">确保可靠性的TCP协议</h3>
<p>TCP 位于传输层，提供可靠的字节流服务。</p>
<p>所谓的字节流服务（Byte Stream Service）是指，为了方便传输，将大块数据分割成以报文段（segment）为单位的数据包进行管理。而可靠的传输服务是指，能够把数据准确可靠地传给对方。一言以蔽之，TCP 协议为了更容易传送大数据才把数据分割，而且 TCP 协议能够确认数据最终是否送达到对方。</p>
<p>为了准确无误地将数据送达目标处，TCP 协议采用了三次握手（three-way handshaking）策略</p>
<p>握手过程中使用了 TCP 的标志（flag） —— SYN（synchronize） 和 ACK（acknowledgement）。</p>
<p>发送端首先发送一个带 SYN 标志的数据包给对方。接收端收到后，回传一个带有 SYN/ACK 标志的数据包以示传达确认信息。最后，发送端再回传一个带 ACK 标志的数据包，代表“握手”结束</p>
<p>若在握手过程中某个阶段莫名中断，TCP 协议会再次以相同的顺序发送相同的数据包。</p>
<h3 id="负责域名解析的dns服务">负责域名解析的DNS服务</h3>
<p>DNS（Domain Name System）服务是和 HTTP 协议一样位于应用层的协议。它提供域名到 IP 地址之间的解析服务。</p>
<p>计算机既可以被赋予 IP 地址，也可以被赋予主机名和域名。</p>
<p>用户通常使用主机名或域名来访问对方的计算机，而不是直接通过 IP地址访问。因为与 IP 地址的一组纯数字相比，用字母配合数字的表示形式来指定计算机名更符合人类的记忆习惯</p>
<p>但要让计算机去理解名称，相对而言就变得困难了。因为计算机更擅长处理一长串数字</p>
<p>为了解决上述的问题，DNS 服务应运而生。DNS 协议提供通过域名查找 IP 地址，或逆向从 IP 地址反查域名的服务
<img src="https://raw.githubusercontent.com/a-b-ab/picture/main/Picgo202405012253520.png"
	
	
	
	loading="lazy"
	
	
></p>
<h3 id="各种协议与http协议的关系">各种协议与HTTP协议的关系</h3>
<p><img src="https://raw.githubusercontent.com/a-b-ab/picture/main/Picgo202405012251747.png"
	
	
	
	loading="lazy"
	
	
></p>
<h2 id="uri和url">URI和URL</h2>
<h3 id="统一资源标识符uri">统一资源标识符URI</h3>
<h3 id="uri格式">URI格式</h3>
<p>表示指定的 URI，要使用涵盖全部必要信息的绝对 URI、绝对 URL以及相对 URL。相对 URL，是指从浏览器中基本 URI 处指定的 URL，形如 /image/logo.gif。</p>
<p><img src="https://raw.githubusercontent.com/a-b-ab/picture/main/Picgo202405012359410.png"
	
	
	
	loading="lazy"
	
	
></p>
<p>让我们先来了解一下绝对 URI 的格式</p>
<ul>
<li>
<p>使用 http: 或 https: 等协议方案名获取访问资源时要指定协议类型。不区分字母大小写，最后附一个冒号（:）。
也可使用 data: 或 javascript: 这类指定数据或脚本程序的方案名。</p>
</li>
<li>
<p>登录信息（认证）
指定用户名和密码作为从服务器端获取资源时必要的登录信息（身份认证）。此项是可选项。</p>
</li>
<li>
<p>服务器地址
使用绝对 URI 必须指定待访问的服务器地址。地址可以是类似hackr.jp 这种 DNS 可解析的名称，或是 192.168.1.1 这类 IPv4 地址名，还可以是 [0:0:0:0:0:0:0:1] 这样用方括号括起来的 IPv6 地址名。</p>
</li>
<li>
<p>服务器端口号
指定服务器连接的网络端口号。此项也是可选项，若用户省略则自动使用默认端口号。</p>
</li>
<li>
<p>带层次的文件路径
指定服务器上的文件路径来定位特指的资源。这与 UNIX 系统的文件目录结构相似</p>
</li>
<li>
<p>查询字符串
针对已指定的文件路径内的资源，可以使用查询字符串传入任意参数。此项可选。</p>
</li>
<li>
<p>片段标识符
使用片段标识符通常可标记出已获取资源中的子资源（文档内的某个位置）。但在 RFC 中并没有明确规定其使用方法。该项也为可选项。</p>
</li>
</ul>
<p>并不是所有的应用程序都符合 RFC</p>
<p>有一些用来制定 HTTP 协议技术标准的文档，它们被称为RFC（Request for Comments，征求修正意见书）。</p>
<p>通常，应用程序会遵照由 RFC 确定的标准实现。可以说，RFC 是互联网的设计文档，要是不按照 RFC 标准执行，就有可能导致无法通信的状况。比如，有一台 Web 服务器内的应用服务没有遵照RFC 的标准实现，那 Web 浏览器就很可能无法访问这台服务器了。</p>
<h1 id="简单的http协议">简单的HTTP协议</h1>
<h2 id="http协议用于客户端和服务端之间的通信">HTTP协议用于客户端和服务端之间的通信</h2>
<h2 id="通过请求和响应的交换达成通信">通过请求和响应的交换达成通信</h2>
<p>请求报文是由请求方法、请求 URI、协议版本、可选的请求首部字段和内容实体构成的。</p>
<p>响应报文基本上由协议版本、状态码（表示请求成功或失败的数字代码）、用以解释状态码的原因短语、可选的响应首部字段以及实体主体构成。</p>
<h2 id="http是不保存状态的协议">HTTP是不保存状态的协议</h2>
<h2 id="请求uri定位资源">请求URI定位资源</h2>
<h2 id="告知服务器意图的http方法">告知服务器意图的HTTP方法</h2>
<ul>
<li>
<p>GET:获取资源</p>
</li>
<li>
<p>POST：传输实体主体 虽然用 GET 方法也可以传输实体的主体，但一般不用 GET 方法进行传输，而是用 POST 方法。虽说 POST 的功能与 GET 很相似，但POST 的主要目的并不是获取响应的主体内容。</p>
</li>
<li>
<p>PUT：传输文件 鉴于 HTTP/1.1 的 PUT 方法自身不带验证机制，任何人都可以上传文件 , 存在安全性问题，因此一般的 Web 网站不使用该方法。若配合 Web 应用程序的验证机制，或架构设计采用REST（REpresentational State Transfer，表征状态转移）标准的同类Web 网站，就可能会开放使用 PUT方法</p>
</li>
<li>
<p>HEAD:获取报文首部 HEAD 方法和 GET 方法一样，只是不返回报文主体部分。用于确认URI 的有效性及资源更新的日期时间等</p>
</li>
<li>
<p>DELETE:删除文件 DELETE 方法用来删除文件，是与 PUT 相反的方法。DELETE 方法按请求 URI 删除指定的资源。</p>
</li>
<li>
<p>OPTIONS:询问支持的方法 OPTIONS 方法用来查询针对请求 URI 指定的资源支持的方法</p>
</li>
<li>
<p>TRACE：追踪路径 TRACE 方法是让 Web 服务器端将之前的请求通信环回给客户端的方法。
发送请求时，在 Max-Forwards 首部字段中填入数值，每经过一个服务器端就将该数字减 1，当数值刚好减到 0 时，就停止继续传输，最后接收到请求的服务器端则返回状态码 200 OK 的响应。
客户端通过 TRACE 方法可以查询发送出去的请求是怎样被加工修改/ 篡改的。这是因为，请求想要连接到源目标服务器可能会通过代理中转，TRACE 方法就是用来确认连接过程中发生的一系列操作。</p>
</li>
<li>
<p>CONNECT:CONNECT 方法要求在与代理服务器通信时建立隧道，实现用隧道协议进行 TCP 通信。主要使用 SSL（Secure Sockets Layer，安全套接层）和 TLS（Transport Layer Security，传输层安全）协议把通信内容加密后经网络隧道传输</p>
</li>
</ul>
<h2 id="使用方法下达命令">使用方法下达命令</h2>
<h2 id="持久连接节省通信量">持久连接节省通信量</h2>
<h3 id="持久连接">持久连接</h3>
<p>持久连接的特点是，只要任意一端没有明确提出断开连接，则保持 TCP 连接状态。
持久连接旨在建立 1 次 TCP 连接后进行多次请求和响应的交互</p>
<p>持久连接的好处在于减少了 TCP 连接的重复建立和断开所造成的额外开销，减轻了服务器端的负载。另外，减少开销的那部分时间，使HTTP 请求和响应能够更早地结束，这样 Web 页面的显示速度也就相应提高了。</p>
<h3 id="管线化">管线化</h3>
<p>持久连接使得多数请求以管线化（pipelining）方式发送成为可能。从前发送请求后需等待并收到响应，才能发送下一个请求。管线化技术出现后，不用等待响应亦可直接发送下一个请求。
<img src="https://raw.githubusercontent.com/a-b-ab/picture/main/Picgo202405020024030.png"
	
	
	
	loading="lazy"
	
	
></p>
<h2 id="使用cookie的状态管理">使用Cookie的状态管理</h2>
<p>HTTP 是无状态协议，它不对之前发生过的请求和响应的状态进行管理。也就是说，无法根据之前的状态进行本次的请求处理。不可否认，无状态协议当然也有它的优点。由于不必保存状态，自然可减少服务器的 CPU 及内存资源的消耗。从另一侧面来说，也正是因为 HTTP 协议本身是非常简单的，所以才会被应用在各种场景里</p>
<p>Cookie 会根据从服务器端发送的响应报文内的一个叫做 Set-Cookie 的首部字段信息，通知客户端保存 Cookie。当下次客户端再往该服务器发送请求时，客户端会自动在请求报文中加入 Cookie 值后发送出去。</p>
<p>服务器端发现客户端发送过来的 Cookie 后，会去检查究竟是从哪一个客户端发来的连接请求，然后对比服务器上的记录，最后得到之前的状态信息。</p>
<h1 id="http报文内的http信息">HTTP报文内的HTTP信息</h1>
<h2 id="http报文">HTTP报文</h2>
<p>用于 HTTP 协议交互的信息被称为 HTTP 报文。请求端（客户端）的HTTP 报文叫做请求报文，响应端（服务器端）的叫做响应报文。HTTP 报文本身是由多行（用 CR+LF 作换行符）数据构成的字符串文本。</p>
<p>HTTP 报文大致可分为报文首部和报文主体两块。两者由最初出现的空行（CR+LF）来划分。通常，并不一定要有报文主体。</p>
<p>请求报文和响应报文的首部内容由以下数据组成</p>
<ul>
<li>
<p>请求行
包含用于请求的方法，请求 URI 和 HTTP 版本</p>
</li>
<li>
<p>状态行
包含表明响应结果的状态码，原因短语和 HTTP 版本</p>
</li>
<li>
<p>首部字段
包含表示请求和响应的各种条件和属性的各类首部：一般有 4 种首部，分别是：通用首部、请求首部、响应首部和实体首部。</p>
</li>
<li>
<p>其他
可能包含 HTTP 的 RFC 里未定义的首部（Cookie 等）</p>
</li>
</ul>
<h2 id="编码提升传输速率">编码提升传输速率</h2>
<p>HTTP 在传输数据时可以按照数据原貌直接传输，但也可以在传输过程中通过编码提升传输速率。通过在传输时编码，能有效地处理大量的访问请求。但是，编码的操作需要计算机来完成，因此会消耗更多的 CPU 等资源。</p>
<h3 id="报文主体和实体主体的差异">报文主体和实体主体的差异</h3>
<ul>
<li>报文：是 HTTP 通信中的基本单位，由 8 位组字节流（octet sequence，其中 octet 为 8 个比特）组成，通过 HTTP 通信传输。</li>
<li>实体：作为请求或响应的有效载荷数据（补充项）被传输，其内容由实体首部和实体主体组成。</li>
</ul>
<p>HTTP 报文的主体用于传输请求或响应的实体主体。</p>
<p><em>通常，报文主体等于实体主体。只有当传输中进行编码操作时，实体主体的内容发生变化，才导致它和报文主体产生差异。</em></p>
<h3 id="压缩传输的内容编码">压缩传输的内容编码</h3>
<p>向待发送邮件内增加附件时，为了使邮件容量变小，我们会先用 ZIP压缩文件之后再添加附件发送。HTTP 协议中有一种被称为内容编码的功能也能进行类似的操作。</p>
<p>内容编码指明应用在实体内容上的编码格式，并保持实体信息原样压缩。内容编码后的实体由客户端接收并负责解码。</p>
<p>常用的内容编码有以下几种。</p>
<ul>
<li>gzip（GNU zip）</li>
<li>compress（UNIX系统的标准压缩）</li>
<li>defate（zlib）</li>
<li>identity（不进行编码）</li>
</ul>
<h3 id="分割发送的分块传输编码">分割发送的分块传输编码</h3>
<p>在 HTTP 通信过程中，请求的编码实体资源尚未全部传输完成之前，浏览器无法显示请求页面。在传输大容量数据时，通过把数据分割成多块，能够让浏览器逐步显示页面。</p>
<p>这种把实体主体分块的功能称为分块传输编码</p>
<p>分块传输编码会将实体主体分成多个部分（块）。每一块都会用十六进制来标记块的大小，而实体主体的最后一块会使用“0(CR+LF)”来标记。</p>
<h2 id="发送多种数据的多部分对象集合">发送多种数据的多部分对象集合</h2>
<p>在 MIME 扩展中会使用一种称为多部分对象集合（Multipart）的方法，来容纳多份不同类型的数据。</p>
<p>相应地，HTTP 协议中也采纳了多部分对象集合，发送的一份报文主体内可含有多类型实体。通常是在图片或文本文件等上传时使用</p>
<p>多部分对象集合包含的对象如下。</p>
<ul>
<li>
<p>multipart/form-data
在 Web 表单文件上传时使用</p>
</li>
<li>
<p>multipart/byteranges
状态码 206（Partial Content，部分内容）响应报文包含了多个范
围的内容时使用。</p>
</li>
</ul>
<p>在 HTTP 报文中使用多部分对象集合时，需要在首部字段里加上Content-type。</p>
<p>使用 boundary 字符串来划分多部分对象集合指明的各类实体。在boundary 字符串指定的各个实体的起始行之前插入“&ndash;”标记（例如：&ndash;AaB03x、&ndash;THIS_STRING_SEPARATES），而在多部分对象集合对应的字符串的最后插入“&ndash;”标记（例如：&ndash;AaB03x&ndash;、&ndash;THIS_STRING_SEPARATES&ndash;）作为结束。</p>
<h2 id="获取部分内容的范围请求">获取部分内容的范围请求</h2>
<p>以前，用户不能使用现在这种高速的带宽访问互联网，当时，下载一个尺寸稍大的图片或文件就已经很吃力了。如果下载过程中遇到网络中断的情况，那就必须重头开始。为了解决上述问题，需要一种可恢复的机制。所谓恢复是指能从之前下载中断处恢复下载。</p>
<p>要实现该功能需要指定下载的实体范围。像这样，指定范围发送的请求叫做范围请求（Range Request）。</p>
<p>对一份 10 000 字节大小的资源，如果使用范围请求，可以只请求5001~10 000 字节内的资源</p>
<h2 id="内容协商返回最合适的内容">内容协商返回最合适的内容</h2>
<p>当浏览器的默认语言为英语或中文，访问相同 URI 的 Web 页面时，则会显示对应的英语版或中文版的 Web 页面。这样的机制称为内容协商（Content Negotiation）。</p>
<p>内容协商机制是指客户端和服务器端就响应的资源内容进行交涉，然后提供给客户端最为适合的资源。内容协商会以响应资源的语言、字符集、编码方式等作为判断的基准</p>
<p>内容协商技术有以下 3 种类型。</p>
<ul>
<li>服务器驱动协商</li>
<li>客户端驱动协商</li>
<li>透明协商：是服务器驱动和客户端驱动的结合体，是由服务器端和客户端各自进行内容协商的一种方法。</li>
</ul>
<h1 id="返回结果的http状态码">返回结果的HTTP状态码</h1>
<h2 id="状态码告知从服务器端返回的请求结果">状态码告知从服务器端返回的请求结果</h2>
<p>状态码如 200 OK，以 3 位数字和原因短语组成
<img src="https://raw.githubusercontent.com/a-b-ab/picture/main/Picgo202405020112563.png"
	
	
	
	loading="lazy"
	
	
></p>
<h2 id="2xx成功">2xx成功</h2>
<h3 id="200-ok">200 ok</h3>
<h3 id="204-no-content">204 no content</h3>
<p>该状态码代表服务器接收的请求已成功处理，但在返回的响应报文中不含实体的主体部分</p>
<h3 id="206-partial-content">206 partial content</h3>
<p>该状态码表示客户端进行了范围请求，而服务器成功执行了这部分的GET 请求。响应报文中包含由 Content-Range 指定范围的实体内容。</p>
<h2 id="3xx重定向">3xx重定向</h2>
<h3 id="301-moved-permanently">301 moved permanently</h3>
<p>永久性重定向。该状态码表示请求的资源已被分配了新的 URI，以后应使用资源现在所指的 URI。</p>
<h3 id="302-found">302 found</h3>
<p>临时性重定向。该状态码表示请求的资源已被分配了新的 URI，希望用户（本次）能使用新的 URI 访问。</p>
<h3 id="303-see-other">303 see other</h3>
<p>该状态码表示由于请求对应的资源存在着另一个 URI，应使用 GET方法定向获取请求的资源</p>
<p>当 301、302、303 响应状态码返回时，几乎所有的浏览器都会把POST 改成 GET，并删除请求报文内的主体，之后请求会自动再次发送。</p>
<h3 id="304-not-modified">304 not modified</h3>
<p>该状态码表示客户端发送附带条件的请求 2 时，服务器端允许请求访问资源，但未满足条件的情况。304 状态码返回时，不包含任何响应的主体部分</p>
<h3 id="307-temporary-redirect">307 temporary redirect</h3>
<p>临时重定向。该状态码与 302 Found 有着相同的含义</p>
<h2 id="4xx客户端错误">4xx客户端错误</h2>
<h3 id="400-bad-request">400 bad request</h3>
<p>该状态码表示请求报文中存在语法错误。当错误发生时，需修改请求的内容后再次发送请求</p>
<h3 id="401-unauthorized">401 unauthorized</h3>
<p>该状态码表示发送的请求需要有通过 HTTP 认证（BASIC 认证、DIGEST 认证）的认证信息。</p>
<h3 id="403-forbidden">403 forbidden</h3>
<p>该状态码表明对请求资源的访问被服务器拒绝了</p>
<h3 id="404-not-found">404 not found</h3>
<p>该状态码表明服务器上无法找到请求的资源</p>
<h2 id="5xx服务器错误">5xx服务器错误</h2>
<h3 id="500-internal-server-error">500 internal server error</h3>
<p>该状态码表明服务器端在执行请求时发生了错误。也有可能是 Web应用存在的 bug 或某些临时的故障</p>
<h3 id="503-servicre-unavailable">503 servicre unavailable</h3>
<p>该状态码表明服务器暂时处于超负载或正在进行停机维护，现在无法处理请求</p>
<p><strong>状态码和状况的不一致</strong></p>
<p>不少返回的状态码响应都是错误的，但是用户可能察觉不到这点。比如 Web 应用程序内部发生错误，状态码依然返回 200 OK，这种情况也经常遇到。</p>
<h2 id="与http协作的web服务器">与HTTP协作的Web服务器</h2>
<p>一台 Web 服务器可搭建多个独立域名的 Web 网站，也可作为通信路径上的中转服务器提升传输效率。</p>
<h2 id="用单台虚拟主机实现多个域名">用单台虚拟主机实现多个域名</h2>
<p>所以，如果一台服务器内托管了 <a class="link" href="https://www.tricorder.jp"  target="_blank" rel="noopener"
    >www.tricorder.jp</a> 和 <a class="link" href="https://www.hackr.jp"  target="_blank" rel="noopener"
    >www.hackr.jp</a> 这两个域名，当收到请求时就需要弄清楚究竟要访问哪个域名。</p>
<p>在相同的 IP 地址下，由于虚拟主机可以寄存多个不同主机名和域名的 Web 网站，因此在发送 HTTP 请求时，必须在 Host 首部内完整指定主机名或域名的 URI。</p>
<h2 id="通信数据转发程序代理网关隧道">通信数据转发程序：代理，网关，隧道</h2>
<p>HTTP 通信时，除客户端和服务器以外，还有一些用于通信数据转发的应用程序，例如代理、网关和隧道。它们可以配合服务器工作。</p>
<p>这些应用程序和服务器可以将请求转发给通信线路上的下一站服务器，并且能接收从那台服务器发送的响应再转发给客户端。</p>
<ul>
<li>
<p>代理：代理是一种有转发功能的应用程序，它扮演了位于服务器和客户端“中间人”的角色，接收由客户端发送的请求并转发给服务器，同时也接收服务器返回的响应并转发给客户端。</p>
</li>
<li>
<p>网关：网关是转发其他服务器通信数据的服务器，接收从客户端发送来的请求时，它就像自己拥有资源的源服务器一样对请求进行处理。有时客户端可能都不会察觉，自己的通信目标是一个网关。</p>
</li>
<li>
<p>隧道：隧道是在相隔甚远的客户端和服务器两者之间进行中转，并保持双方通信连接的应用程序</p>
</li>
</ul>
<h3 id="代理">代理</h3>
<p>代理服务器的基本行为就是接收客户端发送的请求后转发给其他服务器。代理不改变请求 URI，会直接发送给前方持有资源的目标服务器。</p>
<p>持有资源实体的服务器被称为源服务器。从源服务器返回的响应经过代理服务器后再传给客户端。</p>
<p>每次通过代理服务器转发请求或响应时，会追加写入 Via 首部信息</p>
<p>在 HTTP 通信过程中，可级联多台代理服务器。请求和响应的转发会经过数台类似锁链一样连接起来的代理服务器。转发时，需要附加Via 首部字段以标记出经过的主机信息。</p>
<p>使用代理服务器的理由有：利用缓存技术（稍后讲解）减少网络带宽的流量，组织内部针对特定网站的访问控制，以获取访问日志为主要目的，等等。</p>
<p>代理有多种使用方法，按两种基准分类。一种是是否使用缓存，另一种是是否会修改报文。</p>
<ul>
<li>缓存代理
代理转发响应时，缓存代理（Caching Proxy）会预先将资源的副本（缓存）保存在代理服务器上。</li>
</ul>
<p>当代理再次接收到对相同资源的请求时，就可以不从源服务器那里获取资源，而是将之前缓存的资源作为响应返回</p>
<ul>
<li>透明代理
转发请求或响应时，不对报文做任何加工的代理类型被称为透明代理（Transparent Proxy）。反之，对报文内容进行加工的代理被称为非透明代理。</li>
</ul>
<h3 id="网关">网关</h3>
<p>利用网关可以由 HTTP 请求转化为其他协议通信</p>
<p>利用网关能提高通信的安全性，因为可以在客户端与网关之间的通信线路上加密以确保连接的安全。比如，网关可以连接数据库，使用SQL语句查询数据。另外，在 Web 购物网站上进行信用卡结算时，
网关可以和信用卡结算系统联动。</p>
<h3 id="隧道">隧道</h3>
<p>隧道可按要求建立起一条与其他服务器的通信线路，届时使用 SSL等加密手段进行通信。隧道的目的是确保客户端能与服务器进行安全的通信。</p>
<p>隧道本身不会去解析 HTTP 请求。也就是说，请求保持原样中转给之后的服务器。隧道会在通信双方断开连接时结束。</p>
<h2 id="保存资源的缓存">保存资源的缓存</h2>
<p>缓存是指代理服务器或客户端本地磁盘内保存的资源副本。利用缓存可减少对源服务器的访问，因此也就节省了通信流量和通信时间。</p>
<h3 id="缓存的有效期限">缓存的有效期限</h3>
<h3 id="客户端的缓存">客户端的缓存</h3>
<p>缓存不仅可以存在于缓存服务器内，还可以存在客户端浏览器中。以Internet Explorer 程序为例，把客户端缓存称为临时网络文件</p>
<p>浏览器缓存如果有效，就不必再向服务器请求相同的资源了，可以直接从本地磁盘内读取</p>
<p>另外，和缓存服务器相同的一点是，当判定缓存过期后，会向源服务器确认资源的有效性。若判断浏览器缓存失效，浏览器会再次请求新资源。</p>
<h1 id="http首部">HTTP首部</h1>
<h2 id="http报文首部">HTTP报文首部</h2>
<h2 id="http首部字段">HTTP首部字段</h2>
<h3 id="http首部字段传递重要信息">HTTP首部字段传递重要信息</h3>
<p>使用首部字段是为了给浏览器和服务器提供报文主体大小、所使用的语言、认证信息等内容。</p>
<h3 id="http首部字段结构">HTTP首部字段结构</h3>
<p>HTTP 首部字段是由首部字段名和字段值构成的，中间用冒号“:” 分隔。</p>
<h3 id="4种http首部字段类型">4种HTTP首部字段类型</h3>
<ul>
<li>
<p>通用首部字段
请求报文和响应报文两方都会使用的首部</p>
</li>
<li>
<p>请求首部字段
从客户端向服务器端发送请求报文时使用的首部。补充了请求的附加内容、客户端信息、响应内容相关优先级等信息。</p>
</li>
<li>
<p>响应首部字段
从服务器端向客户端返回响应报文时使用的首部。补充了响应的附加内容，也会要求客户端附加额外的内容信息</p>
</li>
<li>
<p>实体首部字段
针对请求报文和响应报文的实体部分使用的首部。补充了资源内容更新时间等与实体有关的信息</p>
</li>
</ul>
<h3 id="http11首部一览">HTTP/1.1首部一览</h3>
<p>4个表</p>
<h3 id="非http11首部字段">非HTTP/1.1首部字段</h3>
<p>还有 Cookie、Set-Cookie 和 Content-Disposition等在其他 RFC 中定义的首部字段，它们的使用频率也很高。</p>
<p>这些非正式的首部字段统一归纳在 RFC4229 HTTP Header Field Registrations 中</p>
<h3 id="end-to-end首部和hop-by-hop首部">end-to-end首部和hop-by-hop首部</h3>
<p>HTTP 首部字段将定义成缓存代理和非缓存代理的行为，分成 2 种类型</p>
<ul>
<li>
<p>端到端首部
分在此类别中的首部会转发给请求 / 响应对应的最终接收目标，且必须保存在由缓存生成的响应中，另外规定它必须被转发</p>
</li>
<li>
<p>逐跳首部
分在此类别中的首部只对单次转发有效，会因通过缓存或代理而不再转发。HTTP/1.1 和之后版本中，如果要使用 hop-by-hop 首部，需提供 Connection 首部字段。</p>
</li>
</ul>
<h2 id="http11通用首部字段">HTTP/1.1通用首部字段</h2>
<h3 id="cache-control">cache-control</h3>
<p>通过指定首部字段 Cache-Control 的指令，就能操作缓存的工作机制。</p>
<p>表示是否能缓存的指令</p>
<ul>
<li>
<p>public：当指定使用 public 指令时，则明确表明其他用户也可利用缓存</p>
</li>
<li>
<p>private：当指定 private 指令后，响应只以特定的用户作为对象，这与 public指令的行为相反。缓存服务器会对该特定用户提供资源缓存的服务，对于其他用户发送过来的请求，代理服务器则不会返回缓存。</p>
</li>
<li>
<p>no-cache
使用 no-cache 指令的目的是为了防止从缓存中返回过期的资源。</p>
</li>
</ul>
<p>控制可执行缓存的对象的指令</p>
<ul>
<li>no-store
当使用 no-store 指令 1 时，暗示请求（和对应的响应）或响应中包含机密信息。</li>
</ul>
<p>从字面意思上很容易把 no-cache 误解成为不缓存，但事实上 no-cache 代表不缓存过期的资源，缓存会向源服务器进行有效期确认后处理资源，也许称为 do-not-serve-from-cache-without-revalidation 更合适。no-store 才是真正地不进行缓存，请读者注意区别</p>
<p>因此，该指令规定缓存不能在本地存储请求或响应的任一部分。</p>
<ul>
<li>
<p>s-maxage
s-maxage 指令的功能和 max-age 指令的相同，它们的不同点是 s-maxage 指令只适用于供多位用户使用的公共缓存服务器。也就是说，对于向同一用户重复返回响应的服务器来说，这个指令没有任何作用。</p>
</li>
<li>
<p>max-age
当客户端发送的请求中包含 max-age 指令时，如果判定缓存资源的缓存时间数值比指定时间的数值更小，那么客户端就接收缓存的资源。另外，当指定 max-age 值为 0，那么缓存服务器通常需要将请求转发给源服务器。</p>
</li>
<li>
<p>min-fresh
要求缓存服务器返回至少还未过指定时间的缓存资源</p>
</li>
<li>
<p>max-stale
使用 max-stale 可指示缓存资源，即使过期也照常接收</p>
</li>
<li>
<p>only-if-cached
使用 only-if-cached 指令表示客户端仅在缓存服务器本地缓存目标资源的情况下才会要求其返回。换言之，该指令要求缓存服务器不重新加载响应，也不会再次确认资源有效性。若发生请求缓存服务器的本地缓存无响应，则返回状态码 504 Gateway Timeout。</p>
</li>
<li>
<p>must-revalidate
使用 must-revalidate 指令，代理会向源服务器再次验证即将返回的响应缓存目前是否仍然有效。</p>
</li>
<li>
<p>proxy-revaliadte
proxy-revalidate 指令要求所有的缓存服务器在接收到客户端带有该指令的请求返回响应之前，必须再次验证缓存的有效性。</p>
</li>
<li>
<p>no-transform
使用 no-transform 指令规定无论是在请求还是响应中，缓存都不能改变实体主体的媒体类型</p>
</li>
</ul>
<p>这样做可防止缓存或代理压缩图片等类似操作。</p>
<p>cache-control 扩展</p>
<p>cache-extension token</p>
<p>通过 cache-extension 标记（token），可以扩展 Cache-Control 首部字段内的指令</p>
<p>如上例，Cache-Control 首部字段本身没有 community 这个指令。借助extension tokens 实现了该指令的添加。如果缓存服务器不能理解community 这个新指令，就会直接忽略。因此，extension tokens 仅对能理解它的缓存服务器来说是有意义的</p>
<h3 id="connection">Connection</h3>
<p>Connection 首部字段具备如下两个作用。</p>
<ul>
<li>控制不再转发给代理的首部字段</li>
<li>管理持久化连接</li>
<li>控制不再转发给代理的首部字段</li>
</ul>
<p>Connection: 不再转发的首部字段名</p>
<p>HTTP/1.1 版本的默认连接都是持久连接。为此，客户端会在持久连接上连续发送请求。当服务器端想明确断开连接时，则指定Connection 首部字段的值为 Close。</p>
<h3 id="date">Date</h3>
<p>首部字段 Date 表明创建 HTTP 报文的日期和时间</p>
<h3 id="pragma">Pragma</h3>
<p>Pragma 是 HTTP/1.1 之前版本的历史遗留字段，仅作为与 HTTP/1.0的向后兼容而定义</p>
<p>所有的中间服务器如果都能以 HTTP/1.1 为基准，那直接采用 Cache-Control: no-cache 指定缓存的处理方式是最为理想的。但要整体掌握全部中间服务器使用的 HTTP 协议版本却是不现实的。因此，发送的请求会同时含有下面两个首部字段。</p>
<p>Cache-Control: no-cache
Pragma: no-cache</p>
<h3 id="trailer">Trailer</h3>
<p>首部字段 Trailer 会事先说明在报文主体后记录了哪些首部字段。该首部字段可应用在 HTTP/1.1 版本分块传输编码时</p>
<h3 id="transfer-encoding">Transfer-Encoding</h3>
<p>首部字段 Transfer-Encoding 规定了传输报文主体时采用的编码方式。</p>
<h3 id="upgrade">Upgrade</h3>
<p>首部字段 Upgrade 用于检测 HTTP 协议及其他协议是否可使用更高的版本进行通信，其参数值可以用来指定一个完全不同的通信协议</p>
<h3 id="via">Via</h3>
<p>使用首部字段 Via 是为了追踪客户端与服务器之间的请求和响应报文的传输路径。</p>
<h3 id="warning">Warning</h3>
<p>HTTP/1.1 的 Warning 首部是从 HTTP/1.0 的响应首部（Retry-After）演变过来的。该首部通常会告知用户一些与缓存相关的问题的警告。
<img src="https://raw.githubusercontent.com/a-b-ab/picture/main/Picgo202405021345456.png"
	
	
	
	loading="lazy"
	
	
></p>
<h2 id="请求首部字段">请求首部字段</h2>
<h3 id="accept">Accept</h3>
<p>Accept 首部字段可通知服务器，用户代理能够处理的媒体类型及媒体类型的相对优先级。可使用 type/subtype 这种形式，一次指定多种媒体类型。</p>
<h3 id="accept-charset">Accept-Charset</h3>
<p>Accept-Charset 首部字段可用来通知服务器用户代理支持的字符集及字符集的相对优先顺序</p>
<h3 id="accept-encoding">Accept-Encoding</h3>
<p>Accept-Encoding 首部字段用来告知服务器用户代理支持的内容编码及内容编码的优先级顺序</p>
<p>压缩方式或不压缩</p>
<h3 id="accept-language">Accept-Language</h3>
<h3 id="authorization">Authorization</h3>
<p>首部字段 Authorization 是用来告知服务器，用户代理的认证信息（证书值）。</p>
<h3 id="expect">Expect</h3>
<p>客户端使用首部字段 Expect 来告知服务器，期望出现的某种特定行为。</p>
<h3 id="from">From</h3>
<p>首部字段 From 用来告知服务器使用用户代理的用户的电子邮件地址</p>
<h3 id="host">Host</h3>
<p>首部字段 Host 会告知服务器，请求的资源所处的互联网主机名和端口号。Host 首部字段在 HTTP/1.1 规范内是唯一一个必须被包含在请求内的首部字段。</p>
<h3 id="if-match">If-Match</h3>
<p>形如 If-xxx 这种样式的请求首部字段，都可称为条件请求，服务器接收到附带条件的请求后，只有判断指定条件为真时，才会执行请求</p>
<p>只有当 If-Match 的字段值跟 ETag 值匹配一致时，服务器才会接受请求</p>
<p>服务器会比对 If-Match 的字段值和资源的 ETag 值，仅当两者一致时，才会执行请求。反之，则返回状态码 412 Precondition Failed 的响应。</p>
<p>还可以使用星号（*）指定 If-Match 的字段值。针对这种情况，服务器将会忽略 ETag 的值，只要资源存在就处理请求</p>
<h3 id="if-none-match">If-None-Match</h3>
<h3 id="if-range">If-Range</h3>
<p>首部字段 If-Range 属于附带条件之一。它告知服务器若指定的 If-Range 字段值（ETag 值或者时间）和请求资源的 ETag 值或时间相一致时，则作为范围请求处理。反之，则返回全体资源。</p>
<h3 id="if-unmodified-since">If-Unmodified-Since</h3>
<p>首部字段 If-Unmodified-Since 和首部字段 If-Modified-Since 的作用相反。它的作用的是告知服务器，指定的请求资源只有在字段值内指定的日期时间之后，未发生更新的情况下，才能处理请求。如果在指定日期时间后发生了更新，则以状态码 412 Precondition Failed 作为响应返回。</p>
<h3 id="max-forwards">Max-Forwards</h3>
<p>通过 TRACE 方法或 OPTIONS 方法，发送包含首部字段 Max-Forwards 的请求时，该字段以十进制整数形式指定可经过的服务器最大数目。服务器在往下一个服务器转发请求之前，Max-Forwards 的值减 1 后重新赋值。当服务器接收到 Max-Forwards 值为 0 的请求时，则不再进行转发，而是直接返回响应。</p>
<h3 id="proxy-authorization">Proxy-Authorization</h3>
<p>接收到从代理服务器发来的认证质询时，客户端会发送包含首部字段Proxy-Authorization 的请求，以告知服务器认证所需要的信息。</p>
<h3 id="range">Range</h3>
<p>对于只需获取部分资源的范围请求，包含首部字段 Range 即可告知服务器资源的指定范围。上面的示例表示请求获取从第 5001 字节至第10000 字节的资源。</p>
<h3 id="referer">Referer</h3>
<p>首部字段 Referer 会告知服务器请求的原始资源的 URI。</p>
<p>客户端一般都会发送 Referer 首部字段给服务器。但当直接在浏览器的地址栏输入 URI，或出于安全性的考虑时，也可以不发送该首部字段。</p>
<p>因为原始资源的 URI 中的查询字符串可能含有 ID 和密码等保密信息，要是写进 Referer 转发给其他服务器，则有可能导致保密信息的泄露。</p>
<h3 id="te">TE</h3>
<p>首部字段 TE 会告知服务器客户端能够处理响应的传输编码方式及相对优先级。它和首部字段 Accept-Encoding 的功能很相像，但是用于传输编码</p>
<h3 id="user-agent">User-Agent</h3>
<p>User-Agent 用于传达浏览器的种类</p>
<p>首部字段 User-Agent 会将创建请求的浏览器和用户代理名称等信息传达给服务器。</p>
<p>由网络爬虫发起请求时，有可能会在字段内添加爬虫作者的电子邮件地址。此外，如果请求经过代理，那么中间也很可能被添加上代理服务器的名称。</p>
<h2 id="响应首部字段">响应首部字段</h2>
<h3 id="accpet-range">Accpet-Range</h3>
<p>首部字段 Accept-Ranges 是用来告知客户端服务器是否能处理范围请求，以指定获取服务器端某个部分的资源。</p>
<p>可指定的字段值有两种，可处理范围请求时指定其为 bytes，反之则指定其为 none。</p>
<h3 id="age">Age</h3>
<p>首部字段 Age 能告知客户端，源服务器在多久前创建了响应。字段值的单位为秒。</p>
<h3 id="etag">ETag</h3>
<p>首部字段 ETag 能告知客户端实体标识。它是一种可将资源以字符串形式做唯一性标识的方式。服务器会为每份资源分配对应的 ETag值。</p>
<p>资源被缓存时，就会被分配唯一性标识。例如，当使用中文版的浏览器访问 <a class="link" href="http://www.google.com/"  target="_blank" rel="noopener"
    >http://www.google.com/</a> 时，就会返回中文版对应的资源，而使用英文版的浏览器访问时，则会返回英文版对应的资源。两者的URI 是相同的，所以仅凭 URI 指定缓存的资源是相当困难的。若在下载过程中出现连接中断、再连接的情况，都会依照 ETag 值来指定资源。</p>
<ul>
<li>
<p>强ETag值：不论实体发生多么细微的变化都会改变其值</p>
</li>
<li>
<p>弱Etag值：弱 ETag 值只用于提示资源是否相同。只有资源发生了根本改变，产生差异时才会改变 ETag 值。这时，会在字段值最开始处附加 W/</p>
</li>
</ul>
<h3 id="location">Location</h3>
<p>使用首部字段 Location 可以将响应接收方引导至某个与请求 URI 位置不同的资源。</p>
<p>几乎所有的浏览器在接收到包含首部字段 Location 的响应后，都会强制性地尝试对已提示的重定向资源的访问。</p>
<h3 id="proxy-authenticate">Proxy-Authenticate</h3>
<p>首部字段 Proxy-Authenticate 会把由代理服务器所要求的认证信息发送给客户端</p>
<h3 id="retry-after">Retry-After</h3>
<p>首部字段 Retry-After 告知客户端应该在多久之后再次发送请求。主要配合状态码 503 Service Unavailable 响应，或 3xx Redirect 响应一起使用。</p>
<h3 id="server">Server</h3>
<p>首部字段 Server 告知客户端当前服务器上安装的 HTTP 服务器应用程序的信息。不单单会标出服务器上的软件应用名称，还有可能包括版本号和安装时启用的可选项。</p>
<h3 id="vary">Vary</h3>
<p>当代理服务器接收到带有 Vary 首部字段指定获取资源的请求时，如果使用的 Accept-Language 字段的值相同，那么就直接从缓存返回响应。反之，则需要先从源服务器端获取资源后才能作为响应返回</p>
<h3 id="www-authenticate">WWW-Authenticate</h3>
<p>首部字段 WWW-Authenticate 用于 HTTP 访问认证。它会告知客户端适用于访问请求 URI 所指定资源的认证方案（Basic 或是 Digest）和带参数提示的质询</p>
<h2 id="实体首部字段">实体首部字段</h2>
<h3 id="allow">Allow</h3>
<p>首部字段 Allow 用于通知客户端能够支持 Request-URI 指定资源的所有 HTTP 方法。</p>
<h3 id="content-encodeing">Content-Encodeing</h3>
<h3 id="content-languange">Content-Languange</h3>
<h3 id="content-length">Content-Length</h3>
<p>首部字段 Content-Length 表明了实体主体部分的大小</p>
<h3 id="content-location">Content-Location</h3>
<p>首部字段 Content-Location 给出与报文主体部分相对应的 URI。和首部字段 Location 不同，Content-Location 表示的是报文主体返回资源对应的 URI。</p>
<h3 id="content-md5">Content-MD5</h3>
<p>客户端会对接收的报文主体执行相同的 MD5 算法，然后与首部字段 Content-MD5 的字段值比较</p>
<p>首部字段 Content-MD5 是一串由 MD5 算法生成的值，其目的在于检查报文主体在传输过程中是否保持完整，以及确认传输到达。</p>
<h3 id="content-range">Content-Range</h3>
<p>针对范围请求，返回响应时使用的首部字段 Content-Range，能告知客户端作为响应返回的实体的哪个部分符合范围请求</p>
<h3 id="content-type">Content-Type</h3>
<p>首部字段 Content-Type 说明了实体主体内对象的媒体类型</p>
<h3 id="expires">Expires</h3>
<p>首部字段 Expires 会将资源失效的日期告知客户端。缓存服务器在接收到含有首部字段 Expires 的响应后，会以缓存来应答请求，在Expires 字段值指定的时间之前，响应的副本会一直被保存。当超过指定的时间后，缓存服务器在请求发送过来时，会转向源服务器请求资源。</p>
<h3 id="last-modified">Last-Modified</h3>
<p>首部字段 Last-Modified 指明资源最终修改的时间</p>
<h2 id="为cookie服务的首部字段">为Cookie服务的首部字段</h2>
<p>Cookie 的工作机制是用户识别及状态管理</p>
<h3 id="set-cookie">Set-Cookie</h3>
<p>当服务器准备开始管理客户端的状态时，会事先告知各种信息<br>
<img src="https://raw.githubusercontent.com/a-b-ab/picture/main/Picgo202405021422886.png"
	
	
	
	loading="lazy"
	
	
></p>
<h3 id="cookie">Cookie</h3>
<p>首部字段 Cookie 会告知服务器，当客户端想获得 HTTP 状态管理支持时，就会在请求中包含从服务器接收到的 Cookie。接收到多个Cookie 时，同样可以以多个 Cookie 形式发送。</p>
<h2 id="其他首部字段">其他首部字段</h2>
<h3 id="x-frame-options">X-Frame-Options</h3>
<p>首部字段 X-Frame-Options 属于 HTTP 响应首部，用于控制网站内容在其他 Web 网站的 Frame 标签内的显示问题。其主要目的是为了防止点击劫持（clickjacking）攻击</p>
<ul>
<li>DENY ：拒绝</li>
<li>SAMEORIGIN ：仅同源域名下的页面（Top-level-browsing-context）匹配时许可</li>
</ul>
<h3 id="dnt">DNT</h3>
<p>首部字段 DNT 属于 HTTP 请求首部，其中 DNT 是 Do Not Track 的简称，意为拒绝个人信息被收集，是表示拒绝被精准广告追踪的一种方法。</p>
<h3 id="x-xss-protection">X-XSS-Protection</h3>
<p>首部字段 X-XSS-Protection 属于 HTTP 响应首部，它是针对跨站脚本攻击（XSS）的一种对策，用于控制浏览器 XSS 防护机制的开关。</p>
<h3 id="p3p">P3P</h3>
<p>首部字段 P3P 属于 HTTP 相应首部，通过利用 P3P（The Platform forPrivacy Preferences，在线隐私偏好平台）技术，可以让 Web 网站上的个人隐私变成一种仅供程序可理解的形式，以达到保护用户隐私的目的。</p>
<h1 id="确保web安全的https">确保Web安全的HTTPS</h1>
<h2 id="http的缺点">HTTP的缺点</h2>
<h3 id="通信使用明文可能会被窃听">通信使用明文可能会被窃听</h3>
<p>由于 HTTP 本身不具备加密的功能，所以也无法做到对通信整体（使用 HTTP 协议通信的请求和响应的内容）进行加密。即，HTTP 报文使用明文（指未经过加密的报文）方式发送</p>
<p>加密处理防止被窃听</p>
<ul>
<li>通信的加密</li>
</ul>
<p>通过和 SSL（Secure Socket Layer，安全套接层）或TLS（Transport Layer Security，安全层传输协议）的组合使用，加密 HTTP 的通信内容</p>
<p>与 SSL组合使用的 HTTP 被称为 HTTPS（HTTPSecure，超文本传输安全协议）或 HTTP over SSL</p>
<ul>
<li>内容的加密</li>
</ul>
<p>还有一种将参与通信的内容本身加密的方式。由于 HTTP 协议中没有加密机制，那么就对 HTTP 协议传输的内容本身加密。即把HTTP 报文里所含的内容进行加密处理。</p>
<h3 id="不验证通信方的身份就可能遭遇伪装">不验证通信方的身份就可能遭遇伪装</h3>
<ul>
<li>
<p>任何人都可发起请求</p>
</li>
<li>
<p>查明对手的证书
虽然使用 HTTP 协议无法确定通信方，但如果使用 SSL则可以。SSL不仅提供加密处理，而且还使用了一种被称为证书的手段，可用于确定方。</p>
</li>
</ul>
<p>证书由值得信任的第三方机构颁发，用以证明服务器和客户端是实际存在的。</p>
<h3 id="无法证明报文完整性可能已遭篡改">无法证明报文完整性，可能已遭篡改</h3>
<ul>
<li>
<p>接收到的内容可能有误</p>
</li>
<li>
<p>如何防止篡改
虽然有使用 HTTP 协议确定报文完整性的方法，但事实上并不便捷、可靠。其中常用的是 MD5 和 SHA-1 等散列值校验的方法，以及用来确认文件的数字签名方法</p>
</li>
</ul>
<h2 id="http加密认证完整性保护--https">HTTP+加密+认证+完整性保护 = HTTPS</h2>
<h3 id="https是身披ssl外壳的http">HTTPS是身披SSL外壳的HTTP</h3>
<p>通常，HTTP 直接和 TCP 通信。当使用 SSL时，则演变成先和 SSL通信，再由 SSL和 TCP 通信了</p>
<p>可以说 SSL是当今世界上应用最为广泛的网络安全技术。</p>
<h3 id="相互交换密钥的公开密钥加密技术">相互交换密钥的公开密钥加密技术</h3>
<p>在对 SSL进行讲解之前，我们先来了解一下加密方法。SSL采用一种叫做公开密钥加密（Public-key cryptography）的加密处理方式。</p>
<p>近代的加密方法中加密算法是公开的，而密钥却是保密的。通过这种方式得以保持加密方法的安全性</p>
<p>加密和解密同用一个密钥的方式称为共享密钥加密（Common keycrypto system），也被叫做对称密钥加密</p>
<p>公开密钥加密方式很好地解决了共享密钥加密的困难。</p>
<p>公开密钥加密使用一对非对称的密钥。一把叫做私有密钥（private key），另一把叫做公开密钥（public key）。顾名思义，私有密钥不能让其他任何人知道，而公开密钥则可以随意发布，任何人都可以获得。</p>
<p><img src="https://raw.githubusercontent.com/a-b-ab/picture/main/Picgo202405022254317.png"
	
	
	
	loading="lazy"
	
	
></p>
<p>HTTPS采用混合混合加密机制
HTTPS 采用共享密钥加密和公开密钥加密两者并用的混合加密机制。
若密钥能够实现安全交换，那么有可能会考虑仅使用公开密钥加密来通信。但是公开密钥加密与共享密钥加密相比，其处理速度要慢。</p>
<h3 id="证明公开密钥正确性的证书">证明公开密钥正确性的证书</h3>
<p>遗憾的是，公开密钥加密方式还是存在一些问题的。那就是无法证明公开密钥本身就是货真价实的公开密钥。</p>
<p>为了解决上述问题，可以使用由数字证书认证机构（CA，CertificateAuthority）和其相关机关颁发的公开密钥证书。</p>
<p>数字证书认证机构处于客户端与服务器双方都可信赖的第三方机构的立场上。威瑞信（VeriSign）就是其中一家非常有名的数字证书认证机构。我们来介绍一下数字证书认证机构的业务流程。首先，服务器的运营人员向数字证书认证机构提出公开密钥的申请。数字证书认证机构在判明提出申请者的身份之后，会对已申请的公开密钥做数字签名，然后分配这个已签名的公开密钥，并将该公开密钥放入公钥证书后绑定在一起。服务器会将这份由数字证书认证机构颁发的公钥证书发送给客户端，以进行公开密钥加密方式通信。公钥证书也可叫做数字证书或直接称为证书接到证书的客户端可使用数字证书认证机构的公开密钥，对那张证书上的数字签名进行验证，一旦验证通过，客户端便可明确两件事：一，认证服务器的公开密钥的是真实有效的数字证书认证机构。二，服务器的公开密钥是值得信赖的。</p>
<h3 id="可证明组织真实性的ev-ssl证书">可证明组织真实性的EV SSL证书</h3>
<p>证书的一个作用是用来证明作为通信一方的服务器是否规范，另外一个作用是可确认对方服务器背后运营的企业是否真实存在。拥有该特性的证书就是 EV SSL证书（Extended Validation SSLCertificate）</p>
<ul>
<li>
<p>用以确认客户端的客户端证书</p>
</li>
<li>
<p>认证机构信誉第一</p>
</li>
<li>
<p>由自认证机构颁发的证书称为自签名证书</p>
</li>
</ul>
<h3 id="https的安全通信机制">HTTPS的安全通信机制</h3>
<p>HTTPS通信</p>
<ul>
<li>
<p>步骤 1： 客户端通过发送 Client Hello 报文开始 SSL通信。报文中包含客户端支持的 SSL的指定版本、加密组件（Cipher Suite）列表（所使用的加密算法及密钥长度等）。</p>
</li>
<li>
<p>步骤 2： 服务器可进行 SSL通信时，会以 Server Hello 报文作为应答。和客户端一样，在报文中包含 SSL版本以及加密组件。服务器的加密组件内容是从接收到的客户端加密组件内筛选出来的</p>
</li>
<li>
<p>步骤 3：之后服务器发送 Certificate 报文。报文中包含公开密钥证书。</p>
</li>
<li>
<p>步骤 4： 最后服务器发送 Server Hello Done 报文通知客户端，最初阶段的 SSL握手协商部分结束。</p>
</li>
<li>
<p>步骤 5： SSL第一次握手结束之后，客户端以 Client Key Exchange 报文作为回应。报文中包含通信加密中使用的一种被称为 Pre-mastersecret 的随机密码串。该报文已用步骤 3 中的公开密钥进行加密。</p>
</li>
<li>
<p>步骤 6： 接着客户端继续发送 Change Cipher Spec 报文。该报文会提示服务器，在此报文之后的通信会采用 Pre-master secret 密钥加密。</p>
</li>
<li>
<p>步骤 7： 客户端发送 Finished 报文。该报文包含连接至今全部报文的整体校验值。这次握手协商是否能够成功，要以服务器是否能够正确解密该报文作为判定标准。</p>
</li>
<li>
<p>步骤 8： 服务器同样发送 Change Cipher Spec 报文。</p>
</li>
<li>
<p>步骤 9： 服务器同样发送 Finished 报文。</p>
</li>
<li>
<p>步骤 10： 服务器和客户端的 Finished 报文交换完毕之后，SSL连接就算建立完成。当然，通信会受到 SSL的保护。从此处开始进行应用层协议的通信，即发送 HTTP 请求。</p>
</li>
<li>
<p>步骤 11： 应用层协议通信，即发送 HTTP 响应。</p>
</li>
<li>
<p>步骤 12： 最后由客户端断开连接。断开连接时，发送 close_notify 报文。上图做了一些省略，这步之后再发送 TCP FIN 报文来关闭与 TCP的通信。</p>
</li>
</ul>
<p>在以上流程中，应用层发送数据时会附加一种叫做 MAC（MessageAuthentication Code）的报文摘要。MAC 能够查知报文是否遭到篡改，从而保护报文的完整性。</p>
<p>HTTPS 也存在一些问题，那就是当使用 SSL时，它的处理速度会变慢。</p>
<p>与纯文本通信相比，加密通信会消耗更多的CPU 及内存资源。如果每次通信都加密，会消耗相当多的资源，平摊到一台计算机上时，能够处理的请求数量必定也会随之减少。</p>
<p>因此，如果是非敏感信息则使用 HTTP 通信，只有在包含个人信息等敏感数据时，才利用 HTTPS 加密通信。</p>
<p>要进行 HTTPS 通信，证书是必不可少的。而使用的证书必须向认证机构（CA）购买</p>
<h1 id="确认访问用户身份的认证">确认访问用户身份的认证</h1>
<h2 id="何为认证">何为认证</h2>
<p>核对的信息通常是指以下这些。</p>
<ul>
<li>密码：只有本人才会知道的字符串信息。</li>
<li>动态令牌：仅限本人持有的设备内显示的一次性密码。</li>
<li>数字证书：仅限本人（终端）持有的信息</li>
<li>生物认证：指纹和虹膜等本人的生理信息。</li>
<li>IC 卡等：仅限本人持有的信息。</li>
</ul>
<h2 id="basic认证">BASIC认证</h2>
<h2 id="digest认证">DIGEST认证</h2>
<p>DIGEST 认证同样使用质询 / 响应的方式（challenge/response），但不会像 BASIC 认证那样直接发送明文密码。</p>
<p>所谓质询响应方式是指，一开始一方会先发送认证要求给另一方，接着使用从另一方那接收到的质询码计算生成响应码。最后将响应码返回给对方进行认证的方式。</p>
<h2 id="ssl客户端认证">SSL客户端认证</h2>
<p>SSL客户端认证是借由 HTTPS 的客户端证书完成认证的方式。凭借客户端证书（在 HTTPS 一章已讲解）认证，服务器可确认访问是否来自已登录的客户端</p>
<h3 id="ssl客户端认证采用双因素认证">SSL客户端认证采用双因素认证</h3>
<p>换言之，第一个认证因素的 SSL客户端证书用来认证客户端计算机，另一个认证因素的密码则用来确定这是用户本人的行为。</p>
<h3 id="ssl客户端认证必要的费用">SSL客户端认证必要的费用</h3>
<h2 id="基于表单认证">基于表单认证</h2>
<h3 id="认证多半为基于表单认证">认证多半为基于表单认证</h3>
<p>由于使用上的便利性及安全性问题，HTTP 协议标准提供的 BASIC 认证和 DIGEST 认证几乎不怎么使用。另外，SSL客户端认证虽然具有高度的安全等级，但因为导入及维持费用等问题，还尚未普及。</p>
<h3 id="session管理及cookie应用">Session管理及Cookie应用</h3>
<p>基于表单认证的标准规范尚未有定论，一般会使用 Cookie 来管理Session（会话）。</p>
<ul>
<li>
<p>步骤 1： 客户端把用户 ID 和密码等登录信息放入报文的实体部分，通常是以 POST 方法把请求发送给服务器。而这时，会使用 HTTPS通信来进行 HTML表单画面的显示和用户输入数据的发送</p>
</li>
<li>
<p>步骤 2： 服务器会发放用以识别用户的 Session ID。通过验证从客户端发送过来的登录信息进行身份认证，然后把用户的认证状态与Session ID 绑定后记录在服务器端。</p>
</li>
<li>
<p>步骤 3： 客户端接收到从服务器端发来的 Session ID 后，会将其作为Cookie 保存在本地。下次向服务器发送请求时，浏览器会自动发送Cookie，所以 Session ID 也随之发送到服务器。服务器端可通过验证接收到的 Session ID 识别用户和其认证状态。</p>
</li>
</ul>
<p>通常，一种安全的保存方法是，先利用给密码加盐（salt）1 的方式增加额外信息，再使用散列（hash）函数计算出散列值后保存。但是我们也经常看到直接保存明文密码的做法，而这样的做法具有导致密码泄露的风险。</p>
<h1 id="基于http的功能追加协议">基于HTTP的功能追加协议</h1>
<h2 id="基于http协议">基于HTTP协议</h2>
<h2 id="消除http瓶颈的spdy">消除HTTP瓶颈的SPDY</h2>
<h3 id="http的瓶颈">HTTP的瓶颈</h3>
<ul>
<li>一条连接上只可发送一个请求。</li>
<li>请求只能从客户端开始。客户端不可以接收除响应以外的指令。</li>
<li>请求 / 响应首部未经压缩就发送。首部信息越多延迟越大</li>
<li>发送冗长的首部。每次互相发送相同的首部造成的浪费较多</li>
<li>可任意选择数据压缩格式。非强制压缩发</li>
</ul>
<p>Ajax 的解决方法：
Ajax（Asynchronous JavaScript and XML， 异 步 JavaScript 与 XML技术）是一种有效利用 JavaScript 和 DOM（Document Object Model，文档对象模型）的操作，以达到局部 Web 页面替换加载的异步通信手段。和以前的同步通信相比，由于它只更新一部分页面，响应中传输的数据量会因此而减少，这一优点显而易见</p>
<p>Ajax 的核心技术是名为 XMLHttpRequest 的 API，通过 JavaScript 脚本语言的调用就能和服务器进行 HTTP 通信。借由这种手段，就能从已加载完毕的 Web 页面上发起请求，只更新局部页面。</p>
<p>Comet 的解决方法：
一旦服务器端有内容更新了，Comet 不会让请求等待，而是直接给客户端返回响应。这是一种通过延迟应答，模拟实现服务器端向客户端推送（Server Push）的功能。</p>
<p>通常，服务器端接收到请求，在处理完毕后就会立即返回响应，但为了实现推送功能，Comet 会先将响应置于挂起状态，当服务器端有内容更新时，再返回该响应。因此，服务器端一旦有更新，就可以立即反馈给客户端。</p>
<p>内容上虽然可以做到实时更新，但为了保留响应，一次连接的持续时间也变长了。期间，为了维持连接会消耗更多的资源</p>
<h3 id="spdy的设计与功能">SPDY的设计与功能</h3>
<p>SPDY 没有完全改写 HTTP 协议，而是在 TCP/IP 的应用层与运输层之间通过新加会话层的形式运作。同时，考虑到安全性问题，SPDY 规定通信中使用 SSL
SPDY 以会话层的形式加入，控制对数据的流动，但还是采用 HTTP建立通信连接。因此，可照常使用 HTTP 的 GET 和 POST 等方 法、Cookie 以及 HTTP 报文等</p>
<p>使用 SPDY 后，HTTP 协议额外获得以下功能。</p>
<ul>
<li>
<p>多路复用流：通过单一的 TCP 连接，可以无限制处理多个 HTTP 请求。所有请求的处理都在一条 TCP 连接上完成，因此 TCP 的处理效率得到提高</p>
</li>
<li>
<p>赋予请求优先级:这样主要是为了在发送多个请求时，解决因带宽低而导致响应变慢的问题。</p>
</li>
<li>
<p>压缩 HTTP 首部</p>
</li>
<li>
<p>推送功能</p>
</li>
<li>
<p>服务器提示功能: 服务器可以主动提示客户端请求所需的资源。由于在客户端发现资源之前就可以获知资源的存在，因此在资源已缓存等情况下，可以避免发送不必要的请求。</p>
</li>
</ul>
<h2 id="使用浏览器进行全双工通信的websocket">使用浏览器进行全双工通信的WebSocket</h2>
<h3 id="websocket-的设计与功能">WebSocket 的设计与功能</h3>
<p>WebSocket，即 Web 浏览器与 Web 服务器之间全双工通信标准</p>
<h3 id="websocket协议">WebSocket协议</h3>
<p>一旦确立 WebSocket 通信连接，不论服务器还是客户端，任意一方都可直接向对方发送报文。</p>
<p>主要特点。</p>
<ul>
<li>推送功能</li>
<li>减少通信量</li>
</ul>
<p>为了实现 WebSocket 通信，在 HTTP 连接建立之后，需要完成一次“握手”（Handshaking）的步骤</p>
<h2 id="期盼已久的http20">期盼已久的HTTP/2.0</h2>
<h2 id="web服务器管理文件的webdav">Web服务器管理文件的WebDAV</h2>
<p>WebDAV（Web-based Distributed Authoring and Versioning，基于万维网的分布式创作和版本控制）是一个可对 Web 服务器上的内容直接进行文件复制、编辑等操作的分布式文件系统。</p>
<h3 id="扩展http11d的webdav">扩展HTTP/1.1D的WebDAV</h3>
<p>针对服务器上的资源，WebDAV 新增加了一些概念</p>
<ul>
<li>集合（Collection）：是一种统一管理多个资源的概念。以集合为单位可进行各种操作。也可实现类似集合的集合这样的叠加</li>
<li>资源（Resource）：把文件或集合称为资源。</li>
<li>属性（Property）：定义资源的属性。定义以“名称 = 值”的格式执行。</li>
<li>锁（Lock）：把文件设置成无法编辑状态。多人同时编辑时，可防止在同一时间进行内容写入。</li>
</ul>
<h3 id="webdav内新增的方法及状态码">WebDAV内新增的方法及状态码</h3>
<p>WebDAV 为实现远程文件管理，向 HTTP/1.1 中追加了以下这些方法。</p>
<ul>
<li>
<p>PROPFIND ：获取属性</p>
</li>
<li>
<p>PROPPATCH ：修改属性</p>
</li>
<li>
<p>MKCOL ：创建集合</p>
</li>
<li>
<p>COPY ：复制资源及属性</p>
</li>
<li>
<p>MOVE ：移动资源</p>
</li>
<li>
<p>LOCK ：资源加锁</p>
</li>
<li>
<p>UNLOCK ：资源解锁</p>
</li>
<li>
<p>102 Processing ：可正常处理请求，但目前是处理中状态</p>
</li>
<li>
<p>207 Multi-Status ：存在多种状态</p>
</li>
<li>
<p>422 Unprocessible Entity ：格式正确，内容有误</p>
</li>
<li>
<p>423 Locked ：资源已被加锁</p>
</li>
<li>
<p>424 Failed Dependency ：处理与某请求关联的请求失败，因此不再维持依赖关系</p>
</li>
<li>
<p>507 Insufficient Storage ：保存空间不足</p>
</li>
</ul>
<p>为何 HTTP 协议受众如此广泛
其中与企业或组织的防火墙设定有着莫大的关系。防火墙的基本功能就是禁止非指定的协议和端口号的数据包通过。因此如果使用新协议或端口号则必须修改防火墙设置。</p>
<h1 id="构建web内容的技术">构建Web内容的技术</h1>
<h2 id="html">HTML</h2>
<h3 id="web-页面几乎全由-html-构建">Web 页面几乎全由 HTML 构建</h3>
<p>HTML（HyperText Markup Language，超文本标记语言）是为了发送 Web 上的超文本（Hypertext）而开发的标记语言。超文本是一种文档系统，可将文档中任意位置的信息与其他信息（文本或图片等）建立关联，即超链接文本。标记语言是指通过在文档的某部分穿插特别的字符串标签，用来修饰文档的语言。我们把出现在 HTML文档内的这种特殊字符串叫做 HTML标签（Tag）</p>
<h3 id="设计应用css">设计应用CSS</h3>
<p>CSS（Cascading Style Sheets，层叠样式表）可以指定如何展现 HTML内的各种元素，属于样式表标准之一。</p>
<h2 id="动态html">动态HTML</h2>
<h3 id="让-web-页面动起来的动态-html">让 Web 页面动起来的动态 HTML</h3>
<p>所谓动态 HTML（Dynamic HTML），是指使用客户端脚本语言将静态的 HTML内容变成动态的技术的总称。鼠标单击点开的新闻、Google Maps 等可滚动的地图就用到了动态 HTML。</p>
<p>动态 HTML技术是通过调用客户端脚本语言 JavaScript，实现对HTML的 Web 页面的动态改造。利用 DOM（Document ObjectModel，文档对象模型）可指定欲发生动态变化的 HTML元素。</p>
<h3 id="更易控制html的dom">更易控制HTML的DOM</h3>
<p>DOM 是用以操作 HTML文档和 XML文档的 API（ApplicationProgramming Interface，应用编程接口）。使用 DOM 可以将 HTML内的元素当作对象操作，如取出元素内的字符串、改变那个 CSS 的属性等，使页面的设计发生改变。</p>
<h2 id="web应用">Web应用</h2>
<h3 id="通过web提供功能的web应用">通过Web提供功能的Web应用</h3>
<p>Web 应用是指通过 Web 功能提供的应用程序。比如购物网站、网上银行、SNS、BBS、搜索引擎和 e-learning 等。互联网（Internet）或企业内网（Intranet）上遍布各式各样的 Web 应用。</p>
<p>类似这种由程序创建的内容称为动态内容，而事先准备好的内容称为静态内容。Web 应用则作用于动态内容之上。</p>
<h3 id="与服务器及程序协作的cgi">与服务器及程序协作的CGI</h3>
<p>CGI（Common Gateway Interface，通用网关接口）是指 Web 服务器在接收到客户端发送过来的请求后转发给程序的一组机制。在 CGI 的作用下，程序会对请求内容做出相应的动作，比如创建 HTML等动态内容。</p>
<p>使用 CGI 的程序叫做 CGI 程序，通常是用 Perl、PHP、Ruby 和 C 等编程语言编写而成。</p>
<h3 id="因java而普及的servlet">因Java而普及的Servlet</h3>
<p>Servlet是一种能在服务器上创建动态内容的程序。Servlet 是用 Java语言实现的一个接口，属于面向企业级 Java（JavaEE，JavaEnterprise Edition）的一部分。</p>
<p>之前提及的 CGI，由于每次接到请求，程序都要跟着启动一次。因此一旦访问量过大，Web 服务器要承担相当大的负载。而 Servlet 运行在与 Web 服务器相同的进程中，因此受到的负载较小 2。Servlet 的运行环境叫做 Web 容器或 Servlet 容器。</p>
<h2 id="数据发布的格式及语言">数据发布的格式及语言</h2>
<h3 id="可扩展标记语言">可扩展标记语言</h3>
<p>XML（eXtensible Markup Language，可扩展标记语言）是一种可按应用目标进行扩展的通用标记语言。旨在通过使用 XML，使互联网数据共享变得更容易。</p>
<p>从 XML文档中读取数据比起 HTML更为简单。由于 XML的结构基本上都是用标签分割而成的树形结构，因此通过语法分析器（Parser）的解析功能解析 XML结构并取出数据元素，可更容易地对数据进行读取。</p>
<h3 id="发布更新信息的rssatom">发布更新信息的RSS/Atom</h3>
<p>RSS（简易信息聚合，也叫聚合内容）和 Atom 都是发布新闻或博客日志等更新信息文档的格式的总称。两者都用到了 XML。</p>
<h3 id="javascript衍生的轻量级易用api">JavaScript衍生的轻量级易用API</h3>
<p>JSON（JavaScript Object Notation）是一种以JavaScript（ECMAScript）的对象表示法为基础的轻量级数据标记语言。能够处理的数据类型有 false/null/true/ 对象 / 数组 / 数字 / 字符
串，这 7 种类型。</p>
<h1 id="web的攻击技术">Web的攻击技术</h1>
<h2 id="针对-web-的攻击技术">针对 Web 的攻击技术</h2>
<p>应用 HTTP 协议的服务器和客户端，以及运行在服务器上的 Web 应用等资源才是攻击目标。</p>
<h3 id="http-不具备必要的安全功能">HTTP 不具备必要的安全功能</h3>
<h3 id="在客户端即可篡改请求">在客户端即可篡改请求</h3>
<h3 id="针对-web-应用的攻击模式">针对 Web 应用的攻击模式</h3>
<ul>
<li>以服务器为目标的主动攻击</li>
<li>以服务器为目标的被动攻击</li>
</ul>
<h3 id="因输出值转义不完全引发的安全漏洞">因输出值转义不完全引发的安全漏洞</h3>
<h2 id="跨站脚本攻击">跨站脚本攻击</h2>
<p>跨站脚本攻击（Cross-Site Scripting，XSS）是指通过存在安全漏洞的Web 网站注册用户的浏览器内运行非法的 HTML标签或 JavaScript 进行的一种攻击。</p>
<h3 id="sql-注入攻击">SQL 注入攻击</h3>
<p>SQL是用来操作关系型数据库管理系统（Relational DataBaseManagement System，RDBMS）的数据库语言，可进行操作数据或定义数据等。</p>
<h3 id="os-命令注入攻击">OS 命令注入攻击</h3>
<p>OS 命令注入攻击（OS Command Injection）是指通过 Web 应用，执行非法的操作系统命令达到攻击的目的。只要在能调用 Shell 函数的地方就有存在被攻击的风险。</p>
<h3 id="http-首部注入攻击">HTTP 首部注入攻击</h3>
<h3 id="邮件首部注入攻击">邮件首部注入攻击</h3>
<h3 id="目录遍历攻击">目录遍历攻击</h3>
<p>目录遍历（Directory Traversal）攻击是指对本无意公开的文件目录，通过非法截断其目录路径后，达成访问目的的一种攻击。这种攻击有时也称为路径遍历（Path Traversal）攻击。</p>
<h3 id="远程文件包含漏洞">远程文件包含漏洞</h3>
<h2 id="因设置或设计上的缺陷引发的安全漏洞">因设置或设计上的缺陷引发的安全漏洞</h2>
<h3 id="强制浏览">强制浏览</h3>
<h3 id="不正确的错误消息处理">不正确的错误消息处理</h3>
<h3 id="开放重定向">开放重定向</h3>
<h2 id="因会话管理疏忽引发的安全漏洞">因会话管理疏忽引发的安全漏洞</h2>
<h3 id="会话劫持">会话劫持</h3>
<p>会话劫持（Session Hijack）是指攻击者通过某种手段拿到了用户的会话 ID，并非法使用此会话 ID 伪装成用户，达到攻击的目的。</p>
<h3 id="会话固定攻击">会话固定攻击</h3>
<h3 id="跨站点请求伪造">跨站点请求伪造</h3>
<h2 id="其他安全漏洞">其他安全漏洞</h2>
<h3 id="密码破解">密码破解</h3>
<h3 id="点击劫持">点击劫持</h3>
<p>点击劫持（Clickjacking）是指利用透明的按钮或链接做成陷阱，覆盖在 Web 页面之上。然后诱使用户在不知情的情况下，点击那个链接访问内容的一种攻击手段。这种行为又称为界面伪装</p>
<h3 id="dos-攻击">DoS 攻击</h3>
<p>DoS 攻击（Denial of Service attack）是一种让运行中的服务呈停止状态的攻击。有时也叫做服务停止攻击或拒绝服务攻击。DoS 攻击的对象不仅限于 Web 网站，还包括网络设备及服务器等</p>
<p>其中，集中利用访问请求的 DoS 攻击，单纯来讲就是发送大量的合法请求。服务器很难分辨何为正常请求，何为攻击请求，因此很难防止 DoS 攻击。</p>
<h3 id="后门程序">后门程序</h3>
<p>后门程序（Backdoor）是指开发设置的隐藏入口，可不按正常步骤使用受限功能。利用后门程序就能够使用原本受限制的功能。</p>
<ul>
<li>开发阶段作为 Debug 调用的后门程序</li>
<li>开发者为了自身利益植入的后门程序</li>
<li>攻击者通过某种方法设置的后门程序</li>
</ul>

</section>


    <footer class="article-footer">
    

    
    <section class="article-copyright">
        <svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-copyright" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z"/>
  <circle cx="12" cy="12" r="9" />
  <path d="M14.5 9a3.5 4 0 1 0 0 6" />
</svg>



        <span>Licensed under CC BY-NC-SA 4.0</span>
    </section>
    <section class="article-lastmod">
        <svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-clock" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z"/>
  <circle cx="12" cy="12" r="9" />
  <polyline points="12 7 12 12 15 15" />
</svg>



        <span>
            最后更新于 May 14, 2024 23:00 CST
        </span>
    </section></footer>


    
</article>

    

    

     
    
        
    <div class="disqus-container">
    <div id="disqus_thread"></div>
<script>
    window.disqus_config = function () {
    
    
    
    };
    (function() {
        if (["localhost", "127.0.0.1"].indexOf(window.location.hostname) != -1) {
            document.getElementById('disqus_thread').innerHTML = 'Disqus comments not available by default when the website is previewed locally.';
            return;
        }
        var d = document, s = d.createElement('script'); s.async = true;
        s.src = '//' + "hugo-theme-stack" + '.disqus.com/embed.js';
        s.setAttribute('data-timestamp', +new Date());
        (d.head || d.body).appendChild(s);
    })();
</script>
<noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
<a href="https://disqus.com" class="dsq-brlink">comments powered by <span class="logo-disqus">Disqus</span></a>
</div>

<style>
    .disqus-container {
        background-color: var(--card-background);
        border-radius: var(--card-border-radius);
        box-shadow: var(--shadow-l1);
        padding: var(--card-padding);
    }
</style>

<script>
    window.addEventListener('onColorSchemeChange', (e) => {
        if (typeof DISQUS == 'object') {
            DISQUS.reset({
                reload: true
            });
        }
    })
</script>

    

    <footer class="site-footer">
    <section class="copyright">
        &copy; 
        
        2024 乌鸦
    </section>
    
    <section class="powerby">
        使用 <a href="https://gohugo.io/" target="_blank" rel="noopener">Hugo</a> 构建 <br />
        主题 <b><a href="https://github.com/CaiJimmy/hugo-theme-stack" target="_blank" rel="noopener" data-version="3.24.1">Stack</a></b> 由 <a href="https://jimmycai.com" target="_blank" rel="noopener">Jimmy</a> 设计
    </section>
</footer>


    
<div class="pswp" tabindex="-1" role="dialog" aria-hidden="true">

    
    <div class="pswp__bg"></div>

    
    <div class="pswp__scroll-wrap">

        
        <div class="pswp__container">
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
        </div>

        
        <div class="pswp__ui pswp__ui--hidden">

            <div class="pswp__top-bar">

                

                <div class="pswp__counter"></div>

                <button class="pswp__button pswp__button--close" title="Close (Esc)"></button>

                <button class="pswp__button pswp__button--share" title="Share"></button>

                <button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>

                <button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button>

                
                
                <div class="pswp__preloader">
                    <div class="pswp__preloader__icn">
                        <div class="pswp__preloader__cut">
                            <div class="pswp__preloader__donut"></div>
                        </div>
                    </div>
                </div>
            </div>

            <div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap">
                <div class="pswp__share-tooltip"></div>
            </div>

            <button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)">
            </button>

            <button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)">
            </button>

            <div class="pswp__caption">
                <div class="pswp__caption__center"></div>
            </div>

        </div>

    </div>

</div><script 
                src="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe.min.js"integrity="sha256-ePwmChbbvXbsO02lbM3HoHbSHTHFAeChekF1xKJdleo="crossorigin="anonymous"
                defer
                >
            </script><script 
                src="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe-ui-default.min.js"integrity="sha256-UKkzOn/w1mBxRmLLGrSeyB4e1xbrp4xylgAWb3M42pU="crossorigin="anonymous"
                defer
                >
            </script><link 
                rel="stylesheet" 
                href="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/default-skin/default-skin.min.css"crossorigin="anonymous"
            ><link 
                rel="stylesheet" 
                href="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe.min.css"crossorigin="anonymous"
            >

            </main>
        </div>
        <script 
                src="https://cdn.jsdelivr.net/npm/node-vibrant@3.1.6/dist/vibrant.min.js"integrity="sha256-awcR2jno4kI5X0zL8ex0vi2z&#43;KMkF24hUW8WePSA9HM="crossorigin="anonymous"
                
                >
            </script><script type="text/javascript" src="/ts/main.js" defer></script>
<script>
    (function () {
        const customFont = document.createElement('link');
        customFont.href = "https://fonts.googleapis.com/css2?family=Lato:wght@300;400;700&display=swap";

        customFont.type = "text/css";
        customFont.rel = "stylesheet";

        document.head.appendChild(customFont);
    }());
</script>
<style>
    @font-face {
      font-family: 'homework';
      src: url(https://example.com/font/CEFFontsCJK-Regular.ttf) format('truetype');
    }
  
    :root {
      --base-font-family: 'homework';
      --code-font-family: 'homework';
    }
</style>
    </body>
</html>
