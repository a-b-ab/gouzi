+++
title = 'python项目管理'
date = 2024-04-22T13:28:01+08:00
draft = false
+++
<img src="https://raw.githubusercontent.com/a-b-ab/picture/main/Picgo202404221613371.jpg"/>

# Python项目管理
*事情起因是这样，我开开心心把代码提交到码云后，结果师兄跟我说去看他发的项目管理，按他的流程改好代码格式，属实把我小吓了一下，感觉自己作为一个学校里学生，有幸在学校间接触到这些观念，是很幸运的。*

## 环境管理

**使用Anaconda和Pipenv共同管理Python项目环境**

Anaconda包含了许多常用的Python库、工具和环境，使得安装和管理这些工具变得更加容易。它包括了Python解释器本身以及许多流行的科学计算库，比如NumPy、SciPy、Pandas、Matplotlib等。此外，Anaconda还提供了一个名为Conda的包管理器，用于安装、更新和管理这些库，以及创建和管理不同的Python环境。

对于Python新手来说，Anaconda是一个很好的选择，因为它提供了一个完整的Python环境，无需手动安装和配置每个库。你只需安装Anaconda，就可以开始编写Python代码并使用各种科学计算工具了。

Pipenv 是 Python 项目的包管理器和虚拟环境管理器。它旨在提供一种简单的方式来创建和管理项目的依赖项，并确保这些依赖项在不同环境中的一致性

下面是 Pipenv 的一些主要功能：

* 虚拟环境管理：Pipenv 可以为每个项目创建独立的虚拟环境，这意味着每个项目都有自己的 Python 解释器和依赖项，而不会干扰系统中的其他项目。

* 依赖项管理：Pipenv 使用 Pipfile 和 Pipfile.lock 文件来管理项目的依赖项。Pipfile 是项目的声明性文件，用于指定所需的包和版本，而 Pipfile.lock 文件则记录了确切的依赖项版本，以确保在不同环境中的一致性。

* 自动环境激活：当你进入项目目录时，Pipenv 会自动激活该项目的虚拟环境，这意味着你可以立即开始使用项目的依赖项而无需手动激活虚拟环境。

* 命令行工具：Pipenv 提供了一组简单的命令行工具，用于安装、更新和删除依赖项，以及管理虚拟环境。

胎教版：

    当你开始一个新的 Python 项目时，你需要安装各种各样的库来帮助你完成任务。Pipenv 就像一个保姆，帮助你照顾这些库，确保它们安装正确且不会互相冲突。

    想象一下你在一个大杂货店里购物，每个库就像是你要买的商品。Pipenv 就是你的购物清单和购物车。你列出你要买的东西（依赖库），然后 Pipenv 帮你把它们一个一个加到你的购物车里（项目环境）。

    同时，Pipenv 还能确保你购物车里的东西都是正确的版本，就像是每个商品上都有一个标签标明它的准确型号和规格一样。这样，当你需要重建你的购物车时，你就可以确保每个东西都是一样的。

    最后，Pipenv 还能帮你管理购物车的整个过程。它会告诉你什么时候需要买新的东西（更新库），或者什么时候需要把一些东西扔掉（删除库）。

    总的来说，Pipenv 就像是你的 Python 项目的好帮手，确保你所需的库都安装正确，没有任何混乱

师兄画的图
<img src="https://raw.githubusercontent.com/a-b-ab/picture/main/Picgo202404171846878.png"/>

## 编码标准
对于编码标准，推荐跟着社区的PEP8走

PEP8 是 Python Enhancement Proposal 8 的缩写，它是 Python 社区中的一项规范，用于指导 Python 代码的编写风格和格式。PEP8 旨在提高代码的可读性，并促进代码在不同项目和团队之间的一致性。

以下是 PEP8 涵盖的一些主要方面：

    缩进：使用 4 个空格作为缩进的标准，而不是制表符。

    行长度：每行代码应尽量控制在 79 个字符以内，但可以允许最多 99 个字符。

    命名约定：变量名应该采用小写字母，单词之间使用下划线分隔（例如，my_variable），而类名应采用驼峰命名法（例如，MyClass）。

    空格：在逗号、冒号、分号等符号后应添加一个空格，但在圆括号内部不需要添加空格。

    导入：每个导入应该独立一行，避免使用通配符导入（例如，from module import *）。

    注释：使用适当的注释来解释代码的作用和目的，注释应该清晰、简洁且易于理解。

    代码布局：遵循统一的代码布局规范，包括适当的缩进、空行和代码段分隔。

pep8链接：  https://pep8.org/

## 规范化

black：代码格式化 
Black 是一个自动化代码格式化工具，它可以帮助你自动将 Python 代码按照一致的规范进行格式化，从而使得代码风格更加统一，减少手动调整格式的工作量。

pylint：代码检查
Pylint 是 Python 中一种静态代码分析工具，它的主要作用是检查 Python 代码中的语法错误、代码风格问题以及潜在的逻辑错误，并提供相应的建议和警告，以帮助开发者编写更加规范、可靠和易于维护的代码。

    语法错误检查：Pylint 可以检测出代码中的语法错误，并指出出错的位置和可能的原因。

    代码风格检查：Pylint 可以根据 PEP8 等 Python 代码规范，检查代码中的格式问题，如缩进、空格、命名规范等，并提供相应的建议。

    代码质量检查：Pylint 可以评估代码的质量，并提供一些度量指标，如代码的复杂度、重复代码等，帮助开发者识别出代码中的潜在问题。

    错误和警告提示：Pylint 可以检测出代码中的潜在逻辑错误、不安全的操作、未使用的变量等，并给出相应的警告或错误提示，帮助开发者尽早发现并修复问题。

isort：导包规划化
isort 的作用就是帮助开发者自动将导入语句按照指定的规范进行排序和格式化，以保持代码的清晰易读，并且符合约定俗成的编码规范。

    导入语句排序：isort 可以自动将导入语句按照特定的顺序排序，例如将标准库模块、第三方库模块和本地模块分组，并按字母顺序排列。

    分组和对齐：isort 可以将导入语句分组，并且对齐每个组内的导入语句，使得代码结构更加清晰易读。

    移除重复导入：isort 可以检测并移除重复的导入语句，避免在代码中出现不必要的重复导入。

    自定义配置：isort 提供了丰富的配置选项，可以根据项目的需要进行定制，包括导入顺序、分组规则、对齐方式等。


flake8(mccabe)：代码复杂度检查
flake8是一个Python工具，用于检查你的代码是否符合PEP 8样式指南
Flake8 是 Python 中常用的代码质量检查工具之一，而 mccabe 则是 Flake8 的一个插件，用于检测代码中的复杂度。

使用方法：
    终端激活虚拟环境 activate 环境名
    进入所需项目 cd 路径
    进行pipenv初始化 
    进行对应的工具处理

## 文件作用

### setup.cfg
setup.cfg文件是一个配置文件，用于存储与项目相关的各种设置

### Pipfile.lock
是由Pipenv生成的一个文件，用于锁定项目的依赖包的精确版本。这个文件确保了你的项目在不同的环境和时间点上都能使用相同版本的依赖，从而避免了因为依赖版本不一致导致的问题

### Pipfile
是由Pipenv工具使用的一个文件，用于管理Python项目的依赖。它类似于requirements.txt文件，但提供了更强大的功能，例如锁定依赖的精确版本，区分开发和生产环境的依赖，以及自动管理虚拟环境。

- [[source]]：这个部分定义了包的源。在这个例子中，包的源被设置为PyPI。

- [packages]：这个部分列出了项目的主要依赖。在这个例子中，项目依赖了requests，lxml，black，isort，pylint，flake8这几个包。

- [dev-packages]：这个部分列出了项目的开发依赖。这些依赖只在开发环境中需要，例如测试工具，代码格式化工具等。在这个例子中，项目的开发依赖包括black，pylint，isort，pytest。

- [requires]这个部分定义了项目需要的Python版本。在这个例子中，项目需要Python 3.10。

- [scripts]：在Pipfile中用于定义一些自定义的命令。这些命令可以是任何你想要的shell命令，它们可以帮助你自动化一些常见的任务，例如运行测试，构建项目，或者启动开发服务器

当你运行pipenv install命令时，Pipenv会查看Pipfile，然后安装列出的所有依赖。如果你运行pipenv install --dev，Pipenv还会安装[dev-packages]中列出的依赖。

*[packages]和[dev-packages]两个部分都是用来列出项目的依赖的，但它们的用途有所不同。

[packages]部分列出的是项目运行时需要的依赖。这些依赖是项目的核心部分，无论是在开发环境还是在生产环境，都需要这些依赖。例如，如果你的项目是一个Web应用，那么你可能需要像Flask或Django这样的Web框架，这些依赖应该被列在[packages]部分。

[dev-packages]部分列出的是只在开发环境中需要的依赖。这些依赖在生产环境中通常是不需要的。例如，你可能需要像pytest这样的测试框架来运行你的测试，或者需要像flake8或black这样的工具来检查你的代码格式，这些依赖应该被列在[dev-packages]部分。

当你运行pipenv install命令时，Pipenv会安装[packages]部分列出的所有依赖。如果你运行pipenv install --dev命令，Pipenv会额外安装[dev-packages]部分列出的依赖。这样，你可以在开发环境中安装所有的依赖，而在生产环境中只安装必要的依赖，从而减少生产环境的复杂性和安全风险。*

### Dockerfile
这个文件是一个Dockerfile，它是一种文本文档，用于自动化Docker镜像的构建过程。Dockerfile中的每一行都代表在镜像中执行的一条命令。

Docker作用：

Docker是一个开源的应用容器引擎，它允许开发者将应用及其依赖打包到一个可移植的容器中，然后发布到任何流行的Linux或Windows机器上，也可以实现虚拟化。容器是完全使用沙箱机制，相互之间不会有任何接口。

以下是Docker的一些主要用途：

- 提供一致的环境：Docker可以确保在不同的环境中（开发，测试，生产等）运行相同的软件和配置。

- 简化配置：Docker使得配置应用环境变得更加简单。你只需要编写一个Dockerfile或者docker-compose.yml文件，就可以定义你的整个环境。

- 隔离应用：每个Docker容器都在其自己的环境中运行，这意味着你可以在同一台机器上运行多个不同版本的同一软件，而不会有冲突。

- 微服务架构：Docker非常适合微服务架构，因为它允许你为每个服务创建一个单独的容器。

- 持续集成/持续部署（CI/CD）：Docker可以与CI/CD工具（如Jenkins，GitLab CI等）集成，使得自动化构建，测试和部署变得更加简单。

- 快速部署：Docker容器比传统的虚拟机启动得更快，这使得它非常适合需要快速扩展的应用。

总的来说，Docker是一种使得软件开发，测试和部署变得更加简单和一致的工具。

### .pylintrc
这个文件是一个.pylintrc文件，它是Pylint工具的配置文件。Pylint是一个Python代码静态分析工具，它可以检查代码中的错误，查找不符合PEP 8编码规范的代码，以及查找代码中的其他问题

总的来说，这个.pylintrc文件定义了Pylint如何检查你的Python代码。你可以根据你的需要修改这个文件，以定制Pylint的行为

### .gitinore
这个文件是一个.gitignore文件，它告诉Git哪些文件或目录不应该被版本控制系统跟踪
在这个.gitignore文件中，每一行都代表一个忽略规则，Git将忽略与这些规则匹配的文件和目录

__pycache__/和*.py[cod]规则告诉Git忽略Python编译的字节码文件和优化的字节码文件。

- *.so规则告诉Git忽略C扩展的共享对象文件。

- build/，dist/，*.egg-info/等规则告诉Git忽略Python打包和分发过程中生成的文件和目录。

- *.manifest和*.spec规则告诉Git忽略PyInstaller生成的文件。

- htmlcov/，.tox/，.coverage等规则告诉Git忽略单元测试和覆盖率报告生成的文件和目录。

总的来说，.gitignore文件帮助你管理你的Git仓库，确保只有需要跟踪的文件被包含在版本控制中。

### .gitattributes
这个文件是一个.gitattributes文件，它用于设置Git仓库的特定行为

在这个.gitattributes文件中，Dockerfile linguist-language=Python这行告诉GitHub的Linguist工具将Dockerfile文件识别为Python语言。Linguist是GitHub用来在仓库中进行语言检测的工具，它决定了在GitHub仓库概览中显示的语言比例，以及在"搜索"功能中如何对代码进行语法高亮

通常，Linguist会自动识别文件的语言，但有时你可能希望覆盖这个行为。在这个例子中，即使Dockerfile实际上是Docker的语言，但这行设置让Linguist将其识别为Python语言

总的来说，.gitattributes文件允许你自定义Git在你的仓库中的行为

### .env
这个文件是一个.env文件，它用于设置环境变量。在这个文件中，PYTHONPATH=${PYTHONPATH}:${PWD}这行代码将当前工作目录（${PWD}）添加到PYTHONPATH环境变量中。

PYTHONPATH是一个环境变量，它告诉Python解释器在哪里查找模块。当你尝试导入一个模块时，Python解释器会在PYTHONPATH中列出的目录中查找这个模块。

在这个例子中，${PWD}是一个环境变量，它表示当前工作目录。所以，这行代码的效果是将当前工作目录添加到PYTHONPATH中。这意味着你可以直接导入当前工作目录中的Python模块，而不需要将它们移动到Python的安装目录或其他位置。

总的来说，.env文件允许你设置环境变量，这可以帮助你配置你的应用的运行环境。

### .dockerignore
这个文件是一个.dockerignore文件，它的作用类似于.gitignore文件，但是它是用于Docker的。.dockerignore文件告诉Docker在构建镜像时应该忽略哪些文件和目录。

在这个.dockerignore文件中：

.idea/：这个规则告诉Docker忽略.idea/目录。这个目录通常包含由JetBrains IDE（如PyCharm）生成的项目设置和配置文件。

.git/：这个规则告诉Docker忽略.git/目录。这个目录包含Git的版本控制信息。

.vscode/：这个规则告诉Docker忽略.vscode/目录。这个目录通常包含由Visual Studio Code生成的项目设置和配置文件。

总的来说，.dockerignore文件帮助你管理你的Docker镜像，确保只有需要的文件被包含在镜像中，从而减小镜像的大小并提高构建速度。

### test文件夹
在Python项目中，test文件夹通常用于存放所有的测试代码。这些测试代码用于验证你的应用的功能和行为，确保它们按照预期工作。

以下是test文件夹的一些主要用途：

- 单元测试：这些是针对单个函数或类的测试，用于验证它们的行为。例如，你可能有一个测试用例来验证你的函数是否正确地处理边界条件。

- 集成测试：这些是针对多个组件或模块的测试，用于验证它们是否能够正确地一起工作。

- 回归测试：当你修改或添加新的代码时，你可以运行你的测试套件来确保你没有引入新的错误。

- 性能测试：这些测试用于检查你的代码的性能，例如，检查一个函数是否在给定的时间内完成。

在Python中，你可以使用unittest库来编写测试用例，并使用pytest或nose等工具来运行你的测试。

总的来说，test文件夹是你的项目的重要组成部分，它帮助你保持你的代码的质量和可靠性。

### src文件夹
在Python项目中，src文件夹通常用于存放项目的源代码。这个目录通常包含一个__init__.py文件，这个文件告诉Python这个目录应该被视为一个包

以下是src文件夹的一些主要用途：

- 代码组织：src文件夹提供了一个地方，你可以在其中组织你的Python模块和包。你可以在src文件夹中创建子目录来进一步组织你的代码。

- 导入模块：当你的Python文件在src文件夹中时，你可以使用相对导入来导入其他模块。例如，如果你有一个在src/my_package目录中的my_module.py文件，你可以在src/my_package目录中的其他Python文件中使用from . import my_module来导入它。

- 测试：将你的源代码放在src文件夹中可以使得测试更加容易。你可以在一个单独的tests文件夹中编写测试，然后在测试中导入src文件夹中的模块。

总的来说，src文件夹是你的项目的重要组成部分，它帮助你组织和管理你的源代码。

### docs文件夹
在Python项目中，docs文件夹通常用于存放项目的文档。这些文档可能包括：

- 项目说明：对项目的概述，包括它的目的，主要功能，以及如何使用它。

- API文档：对项目中的类，函数，方法和模块的详细描述。

- 开发者指南：对如何为项目贡献代码的指南，包括代码风格指南，测试策略，以及代码提交流程。

- 用户手册：对如何使用项目的详细指南，包括安装指南，教程，以及常见问题解答。

这些文档可以使用Markdown，reStructuredText，或其他标记语言编写，然后使用工具如Sphinx生成HTML或PDF格式的文档。

总的来说，docs文件夹是你的项目的重要组成部分，它帮助用户和开发者理解和使用你的项目。

### .vscode文件夹
.vscode文件夹是Visual Studio Code（VS Code）编辑器为特定项目创建的一个配置文件夹。这个文件夹通常包含两个文件：settings.json和launch.json。

- settings.json：这个文件包含了VS Code的工作区设置。这些设置会覆盖用户级别和全局的VS Code设置。例如，你可以在这个文件中设置特定的Python解释器，或者设置代码格式化工具的参数。

- launch.json：这个文件定义了调试配置。例如，你可以在这个文件中设置启动和调试Python程序的参数。

.vscode文件夹通常会被添加到.gitignore文件中，因为这个文件夹通常包含特定用户或特定环境的设置，这些设置可能不适用于其他用户或环境。

### .pytestcache文件夹
.pytest_cache文件夹是由pytest测试框架自动创建的。pytest在运行测试时使用这个文件夹来存储一些中间数据和测试结果，以便在后续的测试运行中重用。

以下是.pytest_cache文件夹中可能包含的一些文件和目录：

- v/cache/lastfailed：这个文件包含了上次测试失败的测试用例的信息。pytest可以使用这个信息来首先运行失败的测试用例。

- v/cache/nodeids：这个文件包含了所有测试用例的节点ID。pytest使用节点ID来唯一标识每个测试用例。

- d/：这个目录包含了一些由pytest插件生成的数据。

通常，你不需要手动修改.pytest_cache文件夹中的内容。这个文件夹通常会被添加到.gitignore文件中，因为它包含的是特定于本地环境的数据，不应该被添加到版本控制系统中

### CACHEDIR.TAG
这个文件名为CACHEDIR.TAG，它是一个缓存目录标签文件。这种文件通常用于标记一个目录被用作缓存，也就是说，该目录中的文件是可以被安全删除的，因为它们可以被重新生成。

在这个特定的情况下，CACHEDIR.TAG文件是由pytest测试框架创建的，用于标记.pytest_cache目录为缓存目录。

文件中的Signature: 8a477f597d28d172789f06886806bc55是一个固定的签名，用于标识这个文件是一个缓存目录标签。

总的来说，CACHEDIR.TAG文件的存在告诉其他工具和用户，.pytest_cache目录中的文件是临时的，可以被安全删除。

### _pycache_文件
__pycache__是Python自动创建的一个目录，用于存储编译后的Python代码，也就是字节码文件。当你运行一个Python程序时，Python解释器会首先将源代码（.py文件）编译成字节码（.pyc文件），然后执行这个字节码。

字节码文件的主要目的是加速程序的启动。当Python解释器再次运行同一个程序时，如果源代码没有改变，解释器可以直接加载字节码文件，而不需要再次编译源代码。

__pycache__目录中的文件通常有如下的命名格式：module.version.pyc，其中module是源代码文件的名称，version是Python解释器的版本。

通常，你不需要手动管理__pycache__目录或其中的文件。Python解释器会自动创建和更新这些文件。这个目录通常会被添加到.gitignore文件中，因为字节码文件是特定于Python解释器的，不应该被添加到版本控制系统中。